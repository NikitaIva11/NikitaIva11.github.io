["John Resig \r\n \r\n \r\nPro JavaScript™ \r\nTechniques \r\n \r\n \r\n \r\nДжон Рейсиг \r\n \r\n \r\nJavaScript \r\nПрофессиональные приёмы \r\nпрограммирования\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n2008 \r\n","\r\n 2\r\nОглавление \r\nОб авторе................................................................................................................................................................................................................. 7 \r\nО техническом редакторе............................................................................................................................................................................ 7 \r\nСлова благодарности....................................................................................................................................................................................... 7 \r\n \r\nГлава 1. Современное программирование на JavaScript............................................................................................. 9 \r\nОбъектно-ориентированный JavaScript........................................................................................................................................... 9 \r\nТестирование кода................................................................................................................................................................................... 10 \r\nСоздание пакета распространения................................................................................................................................................. 11 \r\nНенавязчивое создание DOM-сценариев..................................................................................................................................... 12 \r\nОбъектная модель документа (DOM).............................................................................................................................................. 13 \r\nСобытия......................................................................................................................................................................................................... 14 \r\nJavaScript и CSS........................................................................................................................................................................................ 15 \r\nAjax.................................................................................................................................................................................................................. 15 \r\nПоддержка со стороны браузеров................................................................................................................................................... 18 \r\nВыводы.......................................................................................................................................................................................................... 21 \r\n \r\nГлава 2. Объектно-ориентированный JavaScript............................................................................................................ 22 \r\nСвойства языка................................................................................................................................................................................................ 22 \r\nСсылки........................................................................................................................................................................................................... 22 \r\nПерегрузка функций и проверка типов........................................................................................................................................ 24 \r\nОбласть видимости переменных....................................................................................................................................................... 28 \r\nЗамкнутые выражения........................................................................................................................................................................... 29 \r\nКонтекст........................................................................................................................................................................................................ 32 \r\nОбъектно-ориентированные основы JavaScript.............................................................................................................................. 34 \r\nОбъекты........................................................................................................................................................................................................ 34 \r\nСоздание объектов.................................................................................................................................................................................. 35 \r\nПубличные методы.................................................................................................................................................................................. 36 \r\nЧастные методы........................................................................................................................................................................................ 37 \r\nПривилегированные методы............................................................................................................................................................... 38 \r\nСтатические методы................................................................................................................................................................................ 40 \r\nВыводы................................................................................................................................................................................................................ 40 \r\n \r\nГлава 3. Создание кода широкого применения................................................................................................................ 41 \r\nСтандартизация объектно-ориентированного кода...................................................................................................................... 41 \r\nНаследование с использованием прототипов............................................................................................................................ 41 \r\nКлассическое наследование............................................................................................................................................................... 42 \r\nБиблиотека Base....................................................................................................................................................................................... 45 \r\nБиблиотека Prototype............................................................................................................................................................................. 47 \r\nСоздание пакета............................................................................................................................................................................................. 50 \r\nОрганизация пространства имен...................................................................................................................................................... 51 \r\nDojo................................................................................................................................................................................................................. 51 \r\nYUI.................................................................................................................................................................................................................... 53 \r\nОчистка программного кода...................................................................................................................................................................... 53 \r\nОбъявление переменных...................................................................................................................................................................... 54 \r\nОператоры != и == против операторов !== и ===............................................................................................................... 54 \r\nБлоки и скобки.......................................................................................................................................................................................... 55 \r\nТочки с запятой......................................................................................................................................................................................... 55 \r\nСжатие................................................................................................................................................................................................................. 56 \r\nJSMin............................................................................................................................................................................................................... 56 \r\nPacker............................................................................................................................................................................................................. 57 \r\nРаспространение............................................................................................................................................................................................. 58 \r\nВыводы................................................................................................................................................................................................................ 59 \r\n \r\nГлава 4. Инструменты для отладки и тестирования...................................................................................................... 61 \r\nОтладка............................................................................................................................................................................................................... 61 \r\nКонсоль ошибок........................................................................................................................................................................................ 61 \r\nInternet Explorer........................................................................................................................................................................................ 61 \r\nFirefox............................................................................................................................................................................................................. 62 \r\nSafari............................................................................................................................................................................................................... 63 \r\nOpera..................................................................................................................................................................................................................... 64 \r\nИнспекторы DOM............................................................................................................................................................................................ 65 \r\nИнспектор DOM, имеющийся в Firefox........................................................................................................................................... 65 \r\nDOM-инспектор, имеющийся в Safari............................................................................................................................................. 66 \r\nНаглядное представление источника................................................................................................................................................... 67 \r\nFirebug............................................................................................................................................................................................................ 68 \r\nVenkman........................................................................................................................................................................................................ 69 \r\nТестирование.................................................................................................................................................................................................... 70 \r\nJSUnit.............................................................................................................................................................................................................. 70 \r\nJ3Unit.............................................................................................................................................................................................................. 72 \r\nTest.Simple................................................................................................................................................................................................... 73 \r\nВывод................................................................................................................................................................................................................... 74 \r\n \r\nГлава 5. Объектная модель документа................................................................................................................................... 76 \r\nВведение в объектную модель документа......................................................................................................................................... 76 \r\nПереходы по DOM.......................................................................................................................................................................................... 76 \r\nКак справиться в DOM с пустым пространством............................................................................................................................. 79 \r\n","\r\n 3\r\nПростое перемещение по DOM-структуре......................................................................................................................................... 81 \r\nПривязка к каждому HTML-элементу.................................................................................................................................................... 82 \r\nСтандартные методы DOM......................................................................................................................................................................... 83 \r\nОжидание загрузки HTML DOM................................................................................................................................................................ 85 \r\nОжидание загрузки страницы............................................................................................................................................................ 85 \r\nОжидание загрузки основной части DOM.................................................................................................................................... 86 \r\nВычисление окончания загрузки DOM.......................................................................................................................................... 86 \r\nОбнаружение элементов в документе HTML..................................................................................................................................... 89 \r\nОбнаружение элементов по имени класса.................................................................................................................................. 89 \r\nОбнаружение элементов по селектору CSS................................................................................................................................ 90 \r\ncssQuery........................................................................................................................................................................................................ 91 \r\njQuery............................................................................................................................................................................................................. 91 \r\nXPath............................................................................................................................................................................................................... 92 \r\nПолучение содержимого элемента........................................................................................................................................................ 93 \r\nПолучение текста, находящегося внутри элемента................................................................................................................ 94 \r\nПолучение HTML, находящегося внутри элемента.................................................................................................................. 95 \r\nРабота с атрибутами элементов.............................................................................................................................................................. 96 \r\nПолучение и установка значений атрибута................................................................................................................................ 97 \r\nМодификация DOM......................................................................................................................................................................................100 \r\nСоздание узлов с использованием DOM..................................................................................................................................... 100 \r\nВставка в DOM.........................................................................................................................................................................................101 \r\nВставка в DOM кода HTML.................................................................................................................................................................103 \r\nУдаление узлов из DOM......................................................................................................................................................................105 \r\nВывод.................................................................................................................................................................................................................107 \r\n \r\nГлава 6. События.................................................................................................................................................................................108 \r\nВведение в события JavaScript..............................................................................................................................................................108 \r\nАсинхронные события против потоков........................................................................................................................................ 108 \r\nПотоки JavaScript....................................................................................................................................................................................108 \r\nАсинхронные обратные вызовы...................................................................................................................................................... 109 \r\nФазы события...........................................................................................................................................................................................110 \r\nОбщие свойства событий..........................................................................................................................................................................113 \r\nОбъект события.......................................................................................................................................................................................113 \r\nКлючевое слово this..............................................................................................................................................................................113 \r\nПрекращение всплытия событий.................................................................................................................................................... 114 \r\nПодмена исходных действий браузера....................................................................................................................................... 116 \r\nПривязка перехватчиков событий....................................................................................................................................................... 118 \r\nТрадиционная привязка......................................................................................................................................................................119 \r\nПреимущества традиционной привязки...................................................................................................................................... 119 \r\nНедостатки традиционного способа привязки.........................................................................................................................120 \r\nDOM-привязка: W3C...................................................................................................................................................................................120 \r\nПреимущества W3C-привязки.......................................................................................................................................................... 121 \r\nНедостаток W3C-привязки.................................................................................................................................................................121 \r\nDOM-привязка: IE........................................................................................................................................................................................121 \r\nПреимущество IE-привязки...............................................................................................................................................................122 \r\nНедостатки IE-привязки......................................................................................................................................................................122 \r\naddEvent и removeEvent............................................................................................................................................................................122 \r\nПреимущества addEvent......................................................................................................................................................................124 \r\nНедостаток addEvent.............................................................................................................................................................................125 \r\nВиды событий.................................................................................................................................................................................................125 \r\nСоздание ненавязчивых DOM-сценариев........................................................................................................................................ 126 \r\nПредупреждение отключения JavaScript.................................................................................................................................... 126 \r\nОбеспечение независимости ссылок от JavaScript................................................................................................................127 \r\nОтслеживание блокировки CSS...................................................................................................................................................... 127 \r\nДоступность события............................................................................................................................................................................128 \r\nВывод.................................................................................................................................................................................................................129 \r\n \r\nГлава 7 .  JavaScript и CSS.................................................................................................................................................................130 \r\nДоступ к информации о стилях.............................................................................................................................................................130 \r\nДинамические элементы...........................................................................................................................................................................132 \r\nПозиция элемента..................................................................................................................................................................................132 \r\nПолучение позиции...............................................................................................................................................................................137 \r\nУстановка позиции.................................................................................................................................................................................139 \r\nРазмер элемента.....................................................................................................................................................................................140 \r\nВидимость элемента..............................................................................................................................................................................143 \r\nАнимация..........................................................................................................................................................................................................145 \r\nВыплывание..............................................................................................................................................................................................145 \r\nПроявление...............................................................................................................................................................................................146 \r\nБраузер..............................................................................................................................................................................................................147 \r\nПозиция указателя мыши...................................................................................................................................................................147 \r\nОбласть просмотра......................................................................................................................................................................................148 \r\nРазмер страницы.....................................................................................................................................................................................148 \r\nПозиции полос прокрутки..................................................................................................................................................................149 \r\nПеремещение полос прокрутки....................................................................................................................................................... 149 \r\nРазмер области просмотра.................................................................................................................................................................150 \r\nПеретаскивание............................................................................................................................................................................................151 \r\nБиблиотеки......................................................................................................................................................................................................156 \r\nmoo.fx и jQuery........................................................................................................................................................................................157 \r\nScriptaculous..............................................................................................................................................................................................158 \r\n","\r\n 4\r\nПерестроение путем перетаскивания.......................................................................................................................................... 158 \r\nПолзунок для ввода данных.............................................................................................................................................................159 \r\nВывод.................................................................................................................................................................................................................160 \r\n \r\nГлава 8. Усовершенствование форм...................................................................................................................................... 161 \r\nПроверка данных формы..........................................................................................................................................................................161 \r\nОбязательные поля...............................................................................................................................................................................164 \r\nСоответствие шаблону...............................................................................................................................................................................166 \r\nАдреса электронной почты................................................................................................................................................................166 \r\nURL.................................................................................................................................................................................................................166 \r\nТелефонные номера..............................................................................................................................................................................167 \r\nДата...............................................................................................................................................................................................................168 \r\nНабор правил...........................................................................................................................................................................................168 \r\nОтображение сообщений об ошибках................................................................................................................................................ 170 \r\nПроверка приемлемости данных.................................................................................................................................................... 170 \r\nКогда следует проводить проверку..................................................................................................................................................... 174 \r\nПроверка, предшествующая отправке данных формы.......................................................................................................174 \r\nПроверка после внесения в поле изменений...........................................................................................................................175 \r\nПроверка после загрузки страницы.............................................................................................................................................. 176 \r\nПовышение качества работы с формами.......................................................................................................................................... 176 \r\nНакладные надписи..............................................................................................................................................................................176 \r\nПометка обязательных полей........................................................................................................................................................... 179 \r\nВыводы..............................................................................................................................................................................................................180 \r\n \r\nГлава 9. Создание галерей изображений...........................................................................................................................182 \r\nПримеры галерей..........................................................................................................................................................................................182 \r\nLightbox.......................................................................................................................................................................................................182 \r\nThickBox......................................................................................................................................................................................................184 \r\nСоздание галереи.........................................................................................................................................................................................186 \r\nНенавязчивая загрузка.............................................................................................................................................................................188 \r\nНаложение затемнения.............................................................................................................................................................................190 \r\nПозиционируемый контейнер.................................................................................................................................................................192 \r\nПереходы..........................................................................................................................................................................................................196 \r\nДемонстрация изображений...................................................................................................................................................................198 \r\nВывод.................................................................................................................................................................................................................201 \r\n \r\nГлава 10. Введение в Ajax........................................................................................................................................................... 201 \r\nИспользование Ajax....................................................................................................................................................................................202 \r\nHTTP-запросы.................................................................................................................................................................................................202 \r\nУстановка соединения.........................................................................................................................................................................203 \r\nПреобразование данных в последовательную форму.........................................................................................................204 \r\nСоздание GET-запроса.........................................................................................................................................................................206 \r\nСоздание POST-запроса......................................................................................................................................................................206 \r\nHTTP ответ..................................................................................................................................................................................................208 \r\nОбработка ошибок.................................................................................................................................................................................209 \r\nПроверка истечения времени запроса........................................................................................................................................ 210 \r\nОбработка ответных данных..................................................................................................................................................................211 \r\nПолноценный Ajax-пакет..........................................................................................................................................................................212 \r\nПримеры различного использования данных................................................................................................................................ 215 \r\nRSS-поток, основанный на формате XML................................................................................................................................... 215 \r\nВставка HTML............................................................................................................................................................................................217 \r\nJSON и JavaScript: Удаленное выполнение...............................................................................................................................218 \r\nВывод.................................................................................................................................................................................................................219 \r\n \r\nГлава 11. Усовершенствование блогов с помощью Ajax........................................................................................220 \r\nБесконечный блог........................................................................................................................................................................................220 \r\nШаблон блога.................................................................................................................................................................................................220 \r\nИсточник данных..........................................................................................................................................................................................223 \r\nОпределение наступления событий.................................................................................................................................................... 224 \r\nЗапрос................................................................................................................................................................................................................225 \r\nРезультат..........................................................................................................................................................................................................226 \r\nНаблюдение за ведением блога в режиме реального времени............................................................................................229 \r\nВывод.................................................................................................................................................................................................................232 \r\n \r\nГлава 12. Поиск автозаполнения............................................................................................................................................. 233 \r\nПримеры поиска автозаполнения........................................................................................................................................................ 233 \r\nПостроение страницы.................................................................................................................................................................................235 \r\nОтслеживание ввода с клавиатуры..................................................................................................................................................... 236 \r\nИзвлечение результатов...........................................................................................................................................................................240 \r\nПереход по списку результатов............................................................................................................................................................243 \r\nПеремещения с помощью клавиатуры......................................................................................................................................... 243 \r\nПеремещение с помощью мыши..................................................................................................................................................... 244 \r\nОкончательный результат........................................................................................................................................................................244 \r\nВывод.................................................................................................................................................................................................................250 \r\n \r\nГлава  13. Ajax Wiki.............................................................................................................................................................................251 \r\nЧто такое Wiki?..............................................................................................................................................................................................251 \r\nОбращение к базе данных.......................................................................................................................................................................252 \r\nAjax-запрос......................................................................................................................................................................................................253 \r\n","\r\n 5\r\nКод на стороне сервера............................................................................................................................................................................254 \r\nОбработка запроса................................................................................................................................................................................254 \r\nВыполнение и форматирование SQL............................................................................................................................................ 256 \r\nОбработка JSON-ответа.............................................................................................................................................................................258 \r\nДополнительный учебный пример: JavaScript блог....................................................................................................................259 \r\nКод приложения............................................................................................................................................................................................260 \r\nОсновной код JavaScript.....................................................................................................................................................................261 \r\nJavaScript SQL-библиотека................................................................................................................................................................264 \r\nRuby-код на стороне сервера........................................................................................................................................................... 265 \r\nВывод.................................................................................................................................................................................................................268 \r\n \r\nГлава 14. В каком направлении движется JavaScript?............................................................................................269 \r\nJavaScript 1.6 и 1.7......................................................................................................................................................................................269 \r\nJavaScript 1.6............................................................................................................................................................................................269 \r\nECMAScript для XML (E4X)..................................................................................................................................................................269 \r\nДополнительные возможности по работе с массивами.......................................................................................................271 \r\nJavaScript 1.7............................................................................................................................................................................................272 \r\nВключения в массив.............................................................................................................................................................................272 \r\nУправление областью видимости переменных (Let Scoping)...........................................................................................273 \r\nДеструктуризация..................................................................................................................................................................................274 \r\nWeb Applications 1.0....................................................................................................................................................................................275 \r\nСоздание часов........................................................................................................................................................................................276 \r\nПростая модель планет.............................................................................................................................................................................280 \r\nComet..................................................................................................................................................................................................................282 \r\nВывод.................................................................................................................................................................................................................285 \r\n \r\nПриложение А. Справочник по DOM................................................................................................................................. 287 \r\nResources..........................................................................................................................................................................................................287 \r\nТерминология.................................................................................................................................................................................................287 \r\nПредок.........................................................................................................................................................................................................288 \r\nАтрибут........................................................................................................................................................................................................288 \r\nДочерний элемент..................................................................................................................................................................................288 \r\nЭлемент Document.................................................................................................................................................................................288 \r\nПотомки.......................................................................................................................................................................................................288 \r\nЭлемент.......................................................................................................................................................................................................288 \r\nУзел...............................................................................................................................................................................................................288 \r\nРодитель......................................................................................................................................................................................................288 \r\nСестры..........................................................................................................................................................................................................289 \r\nТекстовые узлы.......................................................................................................................................................................................289 \r\nГлобальные переменные..........................................................................................................................................................................289 \r\ndocument.....................................................................................................................................................................................................289 \r\nHTMLElement.............................................................................................................................................................................................289 \r\nПеремещение по DOM................................................................................................................................................................................290 \r\nbody...............................................................................................................................................................................................................290 \r\nchildNodes...................................................................................................................................................................................................290 \r\ndocumentElement....................................................................................................................................................................................290 \r\nfirstChild.......................................................................................................................................................................................................291 \r\ngetElementById( элемID )...................................................................................................................................................................291 \r\ngetElementsByTagName( имяТега )................................................................................................................................................ 291 \r\nlastChild.......................................................................................................................................................................................................292 \r\nnextSibling..................................................................................................................................................................................................292 \r\nparentNode.................................................................................................................................................................................................293 \r\npreviousSibling..........................................................................................................................................................................................293 \r\nИнформация об узле...................................................................................................................................................................................293 \r\ninnerText......................................................................................................................................................................................................293 \r\nnodeName...................................................................................................................................................................................................294 \r\nnodeType.....................................................................................................................................................................................................294 \r\nnodeValue....................................................................................................................................................................................................295 \r\nАтрибуты...........................................................................................................................................................................................................296 \r\nclassName...................................................................................................................................................................................................296 \r\ngetAttribute( имяАтрибута )...............................................................................................................................................................296 \r\nremoveAttribute( имяАтрибута )...................................................................................................................................................... 297 \r\nsetAttribute( attrName, attrValue ).................................................................................................................................................. 297 \r\nМодификация DOM......................................................................................................................................................................................298 \r\nappendChild( добавляемыйУзел )................................................................................................................................................... 298 \r\ncloneNode( true|false )..........................................................................................................................................................................298 \r\ncreateElement( имяТега )....................................................................................................................................................................299 \r\ncreateElementNS( пространство_имен, имяТега )..................................................................................................................299 \r\ncreateTextNode( тесктоваяСтрока )............................................................................................................................................... 300 \r\ninnerHTML...................................................................................................................................................................................................300 \r\ninsertBefore( узелДляВставки, узелПередКоторымВставлять)........................................................................................301 \r\nremoveChild( удаляемыйУзел )........................................................................................................................................................ 301 \r\nreplaceChild( вставляемыйУзел, заменяемыйУзел )..............................................................................................................302 \r\n \r\nПриложение Б. Справочник по событиям....................................................................................................................303 \r\n      Источники информации.............................................................................................................................................................................303 \r\nТерминология.................................................................................................................................................................................................303 \r\nАсинхронный............................................................................................................................................................................................303 \r\nПрикрепление  / Привязка / Регистрация обратного вызова..........................................................................................303 \r\n","\r\n 6\r\nВсплытие.....................................................................................................................................................................................................303 \r\nЗахват...........................................................................................................................................................................................................303 \r\nИсходное действие (или действие по умолчанию)................................................................................................................304 \r\nСобытие.......................................................................................................................................................................................................304 \r\nОбработчик события.............................................................................................................................................................................304 \r\nПотоковый..................................................................................................................................................................................................304 \r\nОбъект события.............................................................................................................................................................................................304 \r\nОбщие свойства.......................................................................................................................................................................................304 \r\ntype................................................................................................................................................................................................................304 \r\ntarget / srcElement.................................................................................................................................................................................305 \r\nstopPropagation() / cancelBubble..................................................................................................................................................... 305 \r\npreventDefault() / returnValue = false........................................................................................................................................... 306 \r\nСвойства мыши........................................................................................................................................................................................307 \r\nclientX / clientY.........................................................................................................................................................................................307 \r\npageX / pageY...........................................................................................................................................................................................307 \r\nlayerX / layerY и offsetX / offsetY..................................................................................................................................................... 307 \r\nbutton...........................................................................................................................................................................................................307 \r\nrelatedTarget.............................................................................................................................................................................................308 \r\nСвойства клавиатуры...........................................................................................................................................................................309 \r\nctrlKey...........................................................................................................................................................................................................309 \r\nkeyCode.......................................................................................................................................................................................................309 \r\nshiftKey........................................................................................................................................................................................................311 \r\nСобытия страницы.......................................................................................................................................................................................311 \r\nload................................................................................................................................................................................................................311 \r\nbeforeunload..............................................................................................................................................................................................312 \r\nerror...............................................................................................................................................................................................................312 \r\nresize.............................................................................................................................................................................................................313 \r\nscroll..............................................................................................................................................................................................................313 \r\nunload...........................................................................................................................................................................................................313 \r\nСобытия пользовательского интерфейса (UI)...............................................................................................................................314 \r\nfocus..............................................................................................................................................................................................................314 \r\nblur.................................................................................................................................................................................................................314 \r\nСобытия мыши...............................................................................................................................................................................................314 \r\nclick................................................................................................................................................................................................................314 \r\ndblclick..........................................................................................................................................................................................................315 \r\nmousedown................................................................................................................................................................................................315 \r\nmouseup......................................................................................................................................................................................................315 \r\nmousemove................................................................................................................................................................................................315 \r\nmouseover..................................................................................................................................................................................................316 \r\nmouseout.....................................................................................................................................................................................................316 \r\nСобытия клавиатуры...................................................................................................................................................................................317 \r\nkeydown / keypress................................................................................................................................................................................317 \r\nkeyup............................................................................................................................................................................................................318 \r\nСобытия форма..............................................................................................................................................................................................318 \r\nselect.............................................................................................................................................................................................................318 \r\nchange..........................................................................................................................................................................................................318 \r\nsubmit...........................................................................................................................................................................................................319 \r\nreset...............................................................................................................................................................................................................319 \r\n \r\nПриложение В. Браузеры.........................................................................................................................................................321 \r\nСовременные браузеры.............................................................................................................................................................................321 \r\nInternet Explorer............................................................................................................................................................................................321 \r\nВерсии 5.5 и 6.0......................................................................................................................................................................................321 \r\nВерсия 7......................................................................................................................................................................................................321 \r\nMozilla.................................................................................................................................................................................................................321 \r\nFirefox 1.0, Netscape 8 и Mozilla 1.7.............................................................................................................................................. 322 \r\nFirefox 1.5 и 2.0.......................................................................................................................................................................................322 \r\nSafari.............................................................................................................................................................................................................322 \r\nOpera.............................................................................................................................................................................................................322 \r\nВерсия 8.5..................................................................................................................................................................................................322 \r\nВерсия 9.0..................................................................................................................................................................................................322 \r\n","\r\n 7\r\nОб авторе \r\n \r\n \r\nДжон Ресиг (John Resig)  — программист и предприниматель, испытывающий пристрастие к языку \r\nпрограммирования JavaScript. Он является создателем и ведущим разработчиком JavaScript-библиотеки jQuery, а \r\nтакже ведущим разработчиком многих других веб-проектов. В свободное от программирования время он любит \r\nсмотреть кино, вести записи в своем блог-журнале (http://ejohn.org/), и общаться со своей подружкой Джулией.  \r\n \r\nО техническом редакторе \r\nДэн Уэбб (Dan Webb) — свободный разработчик веб-приложений, в последнее время сотрудничающий с \r\nVivabit, где он разрабатывает Event Wax, веб-систему управления событиями. Также недавно он стал соавтором  \r\nвнешнего модуля для Rails — Unobtrusive JavaScript, и расширения Low Pro для Prototype.  \r\nДэн является общепризнанным специалистом по JavaScript, выступавшим на @media 2006, RailsConf и The \r\nAjax Experience. Он написал ряд статей для «A List Apart», «HTML Dog» и  «SitePoint», и является членом группы \r\nUK web design group the Brit Pack. Он регулярно публикует на своем веб-сайте http://www.danwebb.net/ заметки о \r\nRuby, Rails и JavaScript. Недавно он стал членом воссозданной команды разработчиков Prototype Core Team. \r\nСлова благодарности \r\nХочу воспользоваться возможностью поблагодарить всех, кто содействовал выходу этой книги. Нами \r\nпроделан огромный объем работы, и я благодарен всем за помощь и  подсказку, полученные мной на всем \r\nпротяжении работы над книгой.  \r\nСпасибо моему редактору, Крису Миллзу (Chris Mills), за то, что он нашел и вдохновил меня на написание \r\nэтой книги. Именно он сформировал представление о большей части структуры, развития и канвы повествования \r\nэтой книги, без него этот проект просто бы не состоялся. \r\nТакже хочу поблагодарить моего технического редактора, Дена Уэбба (Dan Webb), за тщательную \r\nпроверку моего кода и напоминания о более тонких особенностях языка JavaScript. Благодаря его усилиям \r\nпрограммный код этой книги работает вполне предсказуемо и представлен в правильном и понятном виде.  \r\nЯ благодарен литературному редактору, Дженнифер Уайппл (Jennifer Whipple), и выпускающему \r\nредактору, Лауре Эстерман (Laura Esterman), которые помогли сделать книгу более легкой для чтения и \r\nпонимания, и устранили многие допущенные мной недосказанности и непоследовательности в изложении \r\nматериала.  \r\n","\r\n 8\r\nЯ также благодарен моему руководителю проекта, Трейси Браун Коллинзу (Tracy Brown Collins), за то что \r\nон был направляющей и организующей силой всей моей работы,  и в целом заставлял меня работать с полной \r\nотдачей.  \r\nХочу поблагодарить Джулию Вест (Julia West) и Джоша Кинга (Josh King) за поддержку в течение долгих \r\nдней и недель работы над книгой, когда я уклонялся от всех других своих обязанностей. Джулия ежедневно была \r\nрядом со мной, постоянно убеждаясь в том, что я выполнил свою норму, придавая мне силы и вдохновляя на \r\nупорный труд.  \r\nИ в завершение я хочу поблагодарить за многолетнюю поддержку и содействие свою семью и друзей. \r\n","\r\n 9\r\nГлава 1 Современное программирование на JavaScript \r\nРазвитие JavaScript шло постепенно, но имело постоянный характер. За прошедшее десятилетие \r\nвосприятие JavaScript изменилось от простого, игрушечного до вполне уважаемого языка программирования, \r\nиспользуемого по всему миру корпорациями и разработчиками для создания великолепных приложений. \r\nСовременный JavaScript такой же, каким был всегда — цельный, надежный и невероятно мощный язык \r\nпрограммирования. Многое из того, что рассматривается в этой книге, станет демонстрацией всего, что отличает \r\nсовременные JavaScript-приложения от их предшественников. Многие из представленных в этой главе идей при \r\nвсем своем развитии уже не новы, но то признание, которое они завоевали у тысяч способных программистов, \r\nпомогло усовершенствовать методы их применение и сделать их более современными. Итак, давайте без лишних \r\nслов приступим к рассмотрению современного программирования на JavaScript. \r\nОбъектно-ориентированный JavaScript \r\nС точки зрения языка, вы не найдете здесь абсолютно ничего нового ни об объектно-ориентированном \r\nпрограммировании, ни об объектно-ориентированном JavaScript, поскольку этот язык с самого начала создавался \r\n как полностью объектно-ориентированный. Тем не менее,  по мере того, как JavaScript «развивается» в своем \r\nприменении и признании, программисты, работающие на других языками (таких как Ruby, Python и Perl) его \r\nзаметили и стали переносить на него свои приемы программирования. \r\nОбъектно-ориентированный код JavaScript по внешнему виду и поведению отличается от кода, \r\nнаписанного на других языках, поддерживающих объектное программирование. Углубленное рассмотрение этого \r\nвопроса и различных аспектов, составляющих уникальность языка, я планирую во второй главе, а теперь, чтобы \r\nполучить представление о том, как пишется современный код JavaScript, давайте обратимся к некоторым основам. \r\nВ листинге 1.1 приведены примеры двух объектных конструкторов, показывающих образование пары объектов, \r\nпригодной для использования в учебном процессе. \r\nЛистинг 1.1. Объектно-ориентированный JavaScript, представляющий лекции и  расписание их проведения \r\n// Конструктор для нашей лекции — 'Lecture' \r\n// принимает две строки — name и teacher \r\nfunction Lecture( name, teacher ) { \r\n    // Сохранение строк в качестве локальных свойств объекта \r\n    this.name = name; \r\n    this.teacher = teacher; \r\n} \r\n  \r\n// Метод класса Lecture, используемый для генерации \r\n// строки, которую можно использовать для отображения информации о лекции \r\nLecture.prototype.display = function(){ \r\n    return this.teacher + \" преподает \" + this.name; \r\n}; \r\n  \r\n// Конструктор расписания лекций, принимающий \r\n// массив лекций \r\nfunction Schedule( lectures ) { \r\n    this.lectures = lectures; \r\n} \r\n  \r\n// Метод, предназначенный для построения строки, представляющей \r\n","\r\n 10\r\n// расписание лекций \r\nSchedule.prototype.display = function(){ \r\n    var str = \"\"; \r\n  \r\n    // Перебор всех лекций, построение \r\n    // информационной строки \r\n    for ( var i = 0; i < this.lectures.length; i++ ) \r\n       str += this.lectures[i].display() + \" \"; \r\n  \r\n    return str; \r\n}; \r\nПри просмотре Листинга 1.1 можно заметить, что в его коде присутствует большинство основных \r\nэлементов объектно-ориентированного программирования, которые по сравнению с элементами других, более \r\nраспространенных языков объектно-ориентированного программирования структурированы несколько по-\r\nдругому. Вы можете создавать конструкторы объектов, методы, обращаться к свойствам объектов и извлекать их \r\nзначения. Пример использования в приложении двух классов показан в Листинге 1.2. \r\nЛистинг 1.2. Предоставление пользователю списка классов \r\n// Создание нового объекта расписания — Schedule и его сохранение в \r\n// переменной 'mySchedule' \r\nvar mySchedule = new Schedule([ \r\n    // Создание массива объектов Lecture, который передается \r\n    // объекту Lecture как единое свойство \r\n    new Lecture( \"Gym\", \"Mr. Smith\" ), \r\n    new Lecture( \"Math\", \"Mrs. Jones\" ), \r\n    new Lecture( \"English\", \"TBD\" ) \r\n]); \r\n  \r\n// Отображение информации о расписании в виде всплывающего уведомления \r\nalert( mySchedule.display() ); \r\nС завоеванием признания JavaScript в программистской среде, стало более популярным использование \r\nкачественно спроектированного объектно-ориентированного кода. Я попытаюсь наполнить всю книгу различными \r\nпоказательными фрагментами объектно-ориентированного кода JavaScript, которые, как  я считаю, лучше всего \r\nпроиллюстрируют  разработку и реализацию кода.  \r\nТестирование кода \r\nПосле определения качественной объектно-ориентированной базы программного  кода, вторым аспектом \r\nразработки профессионального кода JavaScript является обеспечение надежной среды тестирования. Потребность \r\nв качественном тестировании становится особенно очевидной при разработке кода, который будет активно \r\nиспользоваться или поддерживаться другими разработчиками. Проведение тестирования с целью закладки  \r\nнадежной базы для других разработчиков — неотъемлемая составляющая практики разработки поддерживаемого \r\nпрограммного кода. \r\nВ главе 4 будут рассмотрена различные инструменты, пригодные для создания нужных режимов \r\nтестирования и эксплуатации, а также простая отладка сложных приложений. Один из таких инструментов — \r\n  дополнительный модуль Firebug для Firefox. Этот модуль предоставляет целый ряд полезных инструментов, \r\n","\r\n 11\r\nсреди которых консоль ошибок,  регистрация HTTP-запросов, отладка и обследование элементов. На рис. 1.1 \r\nпоказана реальная копия экрана дополнительного модуля Firebug в режиме отладки кодового фрагмента. \r\n \r\nРис. 1.1. Копия экрана, иллюстрирующая работу дополнительного модуля Firefox Firebug \r\nВажность разработки свободного от ошибок и хорошо тестируемого кода невозможно переоценить. Как \r\nтолько вы приступите к разработке высококачественного объектно-ориентированного кода и подберете для него \r\nнадлежащий набор программ для тестирования, я уверен, что вы согласитесь с этим утверждением. \r\nСоздание пакета распространения \r\nЗавершающим аспектом разработки современного, профессионального кода JavaScript является создание \r\nпакета программного кода с целью его распространения или реального применения. Поскольку разработчики \r\nстали применять на своих страницах все больше кода JavaScript, возросла вероятность возникновения \r\nконфликтных ситуаций. Если в каждой из двух JavaScript-библиотек есть переменная по имени data, или в обеих \r\nиз них решено добавить различную обработку одного и того же события, то могут возникнуть фатальные \r\nконфликты и трудноопределимые ошибки. \r\nИдеальный вариант создания качественной JavaScript-библиотеки дает разработчикам возможность просто \r\nуказать на нее, используя <script>-тег, и быть уверенным, что  она заработает, не требуя никаких изменений. \r\nЧтобы обеспечить качество и универсальную совместимость своего кода, разработчики используют ряд \r\nтехнологий и решений. \r\nНаиболее распространенной технологией устранения помех и влияния на код со стороны другого кода \r\nJavaScript, является использование пространства имен. Элементарным (но не обязательно лучшим или наиболее \r\nполезным) примером его применения является общедоступная библиотека пользовательского интерфейса, \r\nразработанная компанией Yahoo. Пример использования этой библиотеки показан в листинге 1.3. \r\nЛистинг 1.3. Добавление обработчика события, используя библиотеку Yahoo UI, обладающую развитым \r\nпространством имен \r\n// Добавление обработчика события mouseover для элемента, имеющего \r\n// в качестве ID значение 'body' \r\nYAHOO.util.Event.addListener('body','mouseover',function(){ \r\n  \r\n    // и изменение фонового цвета элемента на красный \r\n    this.style.backgroundColor = 'red'; \r\n  \r\n}); \r\n","\r\n 12\r\nНо у такого метода использования пространства имен есть одна проблема, заключающаяся в отсутствии \r\nкакой-либо внутренней согласованности между библиотеками относительно порядка или структуры их \r\nиспользования. И здесь особую роль приобретают централизованные хранилища кода, такие как JSAN (JavaScript \r\nArchive Network). Это хранилище предоставляет согласованный набор правил для структурируемых библиотек, а \r\nтакже способ быстрого и легкого импорта других библиотек, от которых зависит работа вашего кода. Копия \r\nэкрана основного центра распространения JSAN показана на рис. 1.2. Обсуждение всех хитросплетений \r\nразработки свободного от ошибок, пригодного для создания пакетов распространения кода предстоит в главе 3. В \r\nдополнение к этому внимательное отношение к другим, часто встречающимся «камням преткновения», среди \r\nкоторых противоречия, возникающие при обработке событий, будет рассмотрено в главе 6. \r\n \r\nРис. 1.2. Копия экрана общедоступного хранилища кода JSAN \r\nНенавязчивое создание DOM-сценариев \r\nПостроение продукта на основе качественного, тестируемого кода и совместимого пакета распространения \r\nявляется концепцией ненавязчивого создания DOM-сценария. Написание ненавязчивого кода предполагает \r\nполное отделение от вашего HTML-содержимого: от данных, приходящих с сервера, и от кода JavaScript, \r\nиспользуемого для придания им динамичности. Наиболее важный сопутствующий эффект от такого полного \r\nотделения заключается в том, что теперь вы будете располагать кодом, который всецело поддается упрощению \r\nили усложнению в зависимости от используемого браузера. Этим можно воспользоваться, предлагая более \r\nсовременное содержимое на тех браузерах, которые его поддерживают, и, в то же время, элегантно снижая \r\nуровень содержимого для браузеров с более скромными возможностями. \r\nСоздание современного, ненавязчивого кода имеет две составляющие: объектную модель документа — \r\nDocument Object Model (DOM), и JavaScript-события. В этой книге предстоит глубокое рассмотрение их обеих. \r\n","\r\n 13\r\nОбъектная модель документа (DOM) \r\nDOM является  весьма распространенным способом представления XML-документов. Он не самый быстрый, \r\nлегкий или простой в использовании, но это и не обязательно, зато его отличают наибольшая распространенность \r\nи реализация на большинстве языков, используемых разработчиками веб-приложений (среди которых Java, Perl, \r\nPHP, Ruby, Python и JavaScript). DOM был сконструирован с прицелом на интуитивно понятный для разработчиков \r\nспособ перемещения по XML-иерархии. \r\nПоскольку действующий HTML — это просто подмножество XML, наличие эффективного способа \r\nсинтаксического разбора и просмотра DOM-документа абсолютно необходимо для облегчения разработки кода на \r\nJavaScript. В конце концов в основном взаимодействие в JavaScript происходит между кодом JavaScript и \r\nразличными HTML-элементами,  имеющимися на веб-странице, поэтому DOM является великолепным \r\nинструментом для упрощения этого процесса.  В листинге 1.4. приводится ряд примеров использования DOM для \r\nнавигации по различным элементам страницы, для их поиска и последующих манипуляций. \r\nЛистинг 1.4. Использование объектной модели документа для определения местоположения различных \r\nэлементов DOM и манипуляций с ними \r\n<html> \r\n<head> \r\n    <title>Введение в DOM</title> \r\n    <script> \r\n    // Мы не можем применять DOM, \r\n    // пока не загружен весь документ \r\n    window.onload = function(){ \r\n  \r\n       // Поиск всех элементов <li>, имеющихся в документе \r\n       var li = document.getElementsByTagName(\"li\"); \r\n  \r\n       // и добавление к ним красного обрамления \r\n       for ( var j = 0; j < li.length; j++ ) { \r\n           li[j].style.border = \"1px solid #000\"; \r\n       } \r\n  \r\n       // Определение местоположения элемента, имеющего ID \r\n       // со значением 'everywhere' \r\n       var every = document.getElementById( \"everywhere\" ); \r\n  \r\n       // и удаление его из документа \r\n       every.parentNode.removeChild( every ); \r\n    }; \r\n  \r\n    </script> \r\n</head> \r\n<body> \r\n    <h1>Введение в DOM</h1> \r\n    <p class=\"test\">Существует ряд причин по которым    DOM можно \r\n       считать превосходной моделью, и вот некоторые из них:</p> \r\n    <ul> \r\n       <li id=\"everywhere\">Ее повсюду можно найти.</li> \r\n","\r\n 14\r\n       <li class=\"test\">Она проста в использовании.</li> \r\n <li class=\"test\">Она способна помочь вам найти что угодно, \r\n                   и с завидной быстротой.</li> \r\n    </ul> \r\n</body> \r\n</html> \r\nDOM является первым шагом на пути разработки ненавязчивого кода JavaScript. Быстрота и простота \r\nнавигации по HTML-документу, приводит к значительному упрощению взаимодействия между JavaScript и HTML. \r\nСобытия \r\nСобытия являются тем самым связующим элементом, который скрепляет все пользовательское \r\nвзаимодействие с приложением. В хорошо сконструированном приложении JavaScript, вы стремитесь получить \r\nдоступ к источнику данных и его визуальному представлению (изнутри HTML DOM). Чтобы синхронизировать эти \r\nдва аспекта,  вы стараетесь получить возможность отслеживать пользовательские действия, пытаясь в \r\nсоответствии с ними обновлять пользовательский интерфейс. Сочетание использования DOM и событий \r\nJavaScript — это фундаментальный союз, придающий всем современным веб-приложениям присущие им свойства. \r\nВсе современные браузеры предоставляют ряд событий, которые заявляют о себе, когда происходят \r\nкакие-то определенные моменты взаимодействия, в частности, перемещение пользователем указателя мыши, \r\nнажатие клавиш или выход из страницы. Используя эти события, вы можете указать код, который будет выполнен \r\nпри их наступлении. Пример такого взаимодействия показан в листинге 1.5, где фоновый цвет элементов <li> \r\nизменяется, когда пользователь проводит над ними указателем мыши. \r\nЛистинг 1.5. Использование DOM и событий для обеспечения визуальных эффектов \r\n<html> \r\n<head> \r\n    <title>Введение в DOM</title> \r\n    <script> \r\n    // Мы не можем применять DOM, \r\n    // пока не загружен весь документ \r\n    window.onload = function(){ \r\n  \r\n       // Поиск всех элементов <li>, для прикрепления к ним \r\n       // обработчиков событий \r\n       var li = document.getElementsByTagName(\"li\"); \r\n       for ( var i = 0; i < li.length; i++ ) { \r\n  \r\n           // Прикрепление обработчика события наложения указателя мыши \r\n           // на элемент <li>, изменяющего фоновый цвет \r\n           // элемента <li> на синий. \r\n           li[i].onmouseover = function() { \r\n               this.style.backgroundColor = 'blue'; \r\n           }; \r\n  \r\n           // Прикрепление обработчика события выхода указателя мыши \r\n           // за пределы элемента <li>,возвращающего фоновому цвету \r\n           // элемента <li> его исходное белое значение. \r\n","\r\n 15\r\n           li[i].onmouseout = function() { \r\n               this.style.backgroundColor = 'white'; \r\n           }; \r\n       } \r\n    }; \r\n    </script> \r\n</head> \r\n<body> \r\n    <h1>Введение в DOM</h1> \r\n    <p class=\"test\">Существует ряд причин по которым    DOM можно \r\n       считать превосходной моделью, и вот некоторые из них:</p> \r\n    <ul> \r\n       <li id=\"everywhere\">Ее повсюду можно найти.</li> \r\n       <li class=\"test\">Она проста в использовании.</li> \r\n <li class=\"test\">Она способна помочь вам найти что угодно, \r\n                   и с завидной быстротой.</li> \r\n</body> \r\n</html> \r\nСобытия JavaScript сложны и разнообразны. В том или ином виде они используются в большей части кода \r\nи приложений, представленных в этой книге. Глава 6 и приложение Б полностью посвящены событиям и их \r\nвзаимодействию. \r\nJavaScript и CSS \r\nСоздание приложений на основе DOM и организация взаимодействия с использованием событий \r\nпредставляют собой динамический HTML. В своей основе динамический HTML является взаимодействием, \r\nосуществляемым между JavaScript и CSS-информацией, прикрепленной к элементам DOM. \r\nКаскадные таблицы стилей (Cascading style sheets, CSS) служат стандартом разметки простых, обычных \r\nвеб-страниц, который до сих пор предоставляет разработчикам наиболее мощный инструмент созидания, \r\nдоставляя пользователям меньше всего проблем совместимости. В конечном счете, динамический HTML \r\nзанимается исследованием возможностей организации взаимодействия JavaScript и CSS, и поиском наилучших \r\nспособов использования их сочетания для получения наиболее впечатляющих результатов. \r\nНекоторые примеры расширенного взаимодействия, в частности, перетаскивание элементов и \r\nмультипликацию, можно увидеть в главе 7, где они подробно рассматриваются. \r\nAjax \r\nАсинхронный JavaScript и XML, Ajax — это термин, придуманный Джесси Джеймсом Гарретом (Jesse James \r\nGarrett), соучредителем и президентом Adaptive Path, фирмы по разработке архитектуры информационных систем, \r\nв статье «Ajax: A New Approach to Web Applications» («Ajax: новый подход к веб-приложениям») \r\n (http://www.adaptivepath.com/publications/essays/archives/000385.php). В ней описывается расширенное \r\nвзаимодействие, происходящее между клиентом и сервером при запросе и передаче дополнительной информации. \r\nТермин Ajax охватывает сотни комбинаций обмена данными, но все они концентрируются вокруг основного \r\nисходного условия: дополнительные запросы делаются от клиента к серверу даже после того как страница \r\nполностью загружена. Это дает разработчикам приложений дополнительные возможности по организации \r\nвзаимодействия, избавляющие пользователя от медленного, традиционного хода работы приложения. На рис. 1.3 \r\nпредставлена диаграмма из статьи Гарретта об Ajax, на которой показано, как изменяется поток взаимодействия в \r\n","\r\n 16\r\nпределах приложения благодаря дополнительным запросам, осуществляемых в фоновом режиме (зачастую, без \r\nведома пользователя). \r\n \r\nРис. 1.3. Диаграмма из статьи «Ajax: A New Approach to Web Applications», показывающая расширенное, \r\nасинхронное взаимодействие, осуществляемое между клиентом и сервером \r\nПервый выход статьи Гарретта возбудил интерес пользователей, разработчиков, конструкторов и \r\nуправленцев, обусловив бурный рост новых приложений, использовавших существенно расширившийся уровень \r\nвзаимодействия. Как ни странно, несмотря на этот всплеск интереса, технологические приемы, положенные в \r\nоснову Ajax не отличались новизной (и использовались в коммерческих продуктах примерно с 2000 года). Тем не \r\nменее, главным отличием было использование в прежних приложениях средств связи с сервером, присущих \r\n","\r\n 17\r\nконкретному браузеру (например, свойств, имевшихся только в Internet Explorer). С тех пор, как все современные \r\nбраузеры стали поддерживать XMLHttpRequest (основной метод отправки или получения XML-данных с сервера), \r\nигровое поле было выровнено, позволяя всем получать удовольствие от преимуществ применения новой \r\nтехнологии. \r\nЕсли говорить о компании, занимающей передовые позиции по созданию впечатляющих приложений, в \r\nкоторых используется технология Ajax, то в первую очередь следует упомянуть Google. Еще до выхода первой \r\nстатьи по Ajax эта компания создала чрезвычайно интерактивную демонстрационную версию — Google Suggest, \r\nпозволяющую вводить запрос и получать в режиме реального времени возможность его автозавершения. \r\nПолучить это свойство при использовании старой системы перезагрузки страницы было невозможно. Копия \r\nэкрана, показывающая Google Suggest в действии, показана на рис. 1.4. \r\n \r\nРис. 1.4. Копия экрана приложения Google Suggest, в котором на момент выхода статьи Гарретта об Ajax \r\nуже использовались асинхронные XML-технологии  \r\nВ то же время у Google было и другое революционное приложение — Google Maps, позволявшее \r\nпользователю перемещаться по карте и просматривать нужные ему, локализованные результаты, отображаемые в \r\nреальном масштабе времени. Уровень скорости и удобства, предоставляемый этим приложением за счет \r\nиспользования технологий Ajax, резко отличался от уровня других доступных приложений, работающих с \r\nкартами,  в результате чего рынок интерактивных карт был полностью реконструирован. Копия экрана Google \r\nMaps показана на рис. 1.5. \r\nХотя за последние несколько лет язык JavaScript не претерпел каких-либо существенных физических \r\nизменений, его принятие в качестве полноценной среды программирования такими компаниями как Google и \r\nYahoo, показало, сколь существенно изменилось его восприятие и популярность. \r\n","\r\n 18\r\n \r\nРис. 1.5. Приложение Google Maps, использующее ряд Ajax-технологий для динамической загрузки \r\nлокализованной информации \r\nПоддержка со стороны браузеров \r\nРазработка на JavaScript связана с одним грустным обстоятельством — привязанностью к браузерам, \r\nосуществляющим ее реализацию и поддержку, получается, что она отдана на откуп тем браузерам, которые на \r\nданный момент обладают наибольшей популярностью. Поскольку пользователи не всего используют браузеры, \r\nобладающие наилучшей поддержкой JavaScript, мы вынуждены определять, какие свойства считать наиболее \r\nважными. \r\nМногие разработчики стали отказываться от поддержки своих программ теми браузерами, которые \r\nдоставляют слишком много проблем при разработке с учетом их особенностей. Существует тонкое соотношение \r\nмежду поддержкой браузеров на основе контингента их пользователей, и их поддержкой на основе наличия в них \r\nтребуемых свойств. \r\nНедавно компания Yahoo выпустила JavaScript-библиотеку,  которую можно использовать для расширения \r\nсвоих веб-приложений. Вместе с этой библиотекой был выпущен ряд указаний по приемам конструирования, \r\nкоторых должны придерживаться разработчики веб-приложений. На мой взгляд, наиболее важным из \r\nвыпущенных компанией Yahoo документов является официальный список браузеров, в которых  поддерживается и \r\nне поддерживается работа библиотеки. Любой человек, и любая корпорация могли бы сделать то же самое, \r\nопубликовав документ, который трудно переоценить, на одном из своих самых посещаемых веб-сайтов Интернета. \r\n","\r\n 19\r\nВ Yahoo разработана система категорирования браузерной поддержки, присваивающая браузерам \r\nопределенную категорию на основе их возможностей. В ней браузерам присваивается одна из трех категорий: A, \r\nX и C: \r\n• Браузеры категории A протестированы на полную поддержку, и приложения Yahoo могут гарантированно \r\nработать под их управлением. \r\n• Браузеры категории X — это те же браузеры категории A, о существовании которых компания Yahoo знает, \r\nно еще не имела возможности полностью протестировать их работу, или это новые браузеры, с которыми \r\nона еще никогда не имела дело. Браузеры категории X получают такое же содержимое, что и браузеры \r\nкатегории A, в надежде, что они смогут справиться с этим расширенным содержимым. \r\n• Браузеры категории C известны как «плохие», не поддерживающие свойства, необходимые для \r\nполноценной работы приложений Yahoo. Это такие браузеры, которые обслуживают функциональные \r\nконтенты приложений, в которых не используется JavaScript, поскольку приложения Yahoo абсолютно \r\nненавязчивы в этом вопросе (в том смысле, что они продолжают работать и в отсутствие JavaScript). \r\nКстати, совершенно случайно тот выбор категорий, который был сделан компанией Yahoo, совпал с моим \r\nсобственным, что придало ему особую привлекательность. В этой книге я часто употребляю термин современный \r\nбраузер, используя который я подразумеваю любой браузер, который в таблице браузеров Yahoo отнесен к \r\nкатегории A. Наличие постоянного набора свойств, с которыми можно работать, позволяет сделать процесс \r\nобучения и разработки намного более интересным и менее тягостным (благодаря игнорированию вопросов \r\nнесовместимости браузеров). \r\nЯ настоятельно рекомендую ознакомиться с документами, относящимися к категорированию браузерной \r\nподдержки (которые можно найти по адресу http://developer.yahoo.com/yui/articles/gbs/gbs.html), включая и \r\nсоответствующую таблицу, изображенную на рис. 1.6, чтобы оценить предпринятую Yahoo попытку. Открывая \r\nдоступ к этой информации широкому кругу веб-разработчиков, Yahoo предоставляет неоценимый «золотой \r\nстандарт», к которому следует стремиться и всем остальным, что само по себе уже трудно переоценить. \r\nДополнительную информацию о поддерживаемых браузерах можно найти в приложении В, где подробно \r\nрассмотрены  все недостатки и преимущества каждого браузера. Практически всегда те браузеры, которые \r\nотнесены к категории A, будут находится на переднем крае разработки, обеспечивая исчерпывающим набором \r\nсвойств, необходимых для ее осуществления. Выбор браузеров, от которых вы хотите добиться поддержки своих \r\nприложений, в конечном счете обусловливается тем набором свойств, который будет в состоянии поддержать \r\nваше приложение. Если вы (к примеру) хотите добиться поддержки Netscape Navigator 4 или Internet Explorer 5, \r\nэто сильно сократит то количество свойств, которые можно будет использовать в вашем приложении, в силу того, \r\nчто эти браузеры ограничены в поддержке современных технологий программирования. \r\n","\r\n 20\r\n \r\nРис. 1.6. Таблица категорирования браузерной поддержки, предоставленная компанией Yahoo \r\nЗная, какие из браузеров можно отнести к современным, вы можете воспользоваться их сильными \r\nсторонами, и получить надежную базу для дальнейших разработок. Эта база может быть определена наличием \r\nследующего набора свойств: \r\nЯдра JavaScript 1.5: Самой последней, широко распространенной версии JavaScript, обладающей всеми \r\nсвойствами, необходимыми для полной функциональной поддержки объектно-ориентированного языка JavaScript. \r\nInternet Explorer 5.0 не обладает полной поддержкой версии 1.5, что является главной причиной нежелания \r\nразработчиков заниматься поддержкой этого браузера. \r\n   \r\nXML Document Object Model (DOM) 2: Стандарта рассмотрения HTML и XML-документов. Это абсолютно \r\nнеобходимое условие для создания быстро работающих приложений. \r\n   \r\nXMLHttpRequest: Основы Ajax — простого уровня инициирования удаленных http-запросов. Этот объект \r\nподдерживается всеми браузерами по умолчанию, за исключением Internet Explorer 5.5–6.0; тем не менее оба они \r\nподдерживают инициирование совместимого объекта, используя ActiveX. \r\n   \r\nCSS: Основного компонента, необходимого для разработки веб-страниц. Это требование может показаться \r\nстранным, но наличие CSS жизненно важное требование для разработчиков веб-приложений. Поскольку таблицы \r\nCSS поддерживаются всеми современными браузерами, это обычно сводится к несоответствиям в представлениях, \r\nвызывающим наибольшее количество проблем. Это главная причина, по которой Internet Explorer для Mac \r\nподдерживается реже всех браузеров. \r\n","\r\n 21\r\nСочетание всех этих свойств браузера и составляет основу разработки приложений на JavaScript. \r\nПоскольку ранее перечисленные свойства так или иначе поддерживаются всеми современными браузерами, вы \r\nполучаете твердую платформу для создания всего, что будет встречаться в остальной части этой книги. Все, что \r\nрассматривается в книге будет основано на предположении, что используемый вами браузер по крайней мере \r\nподдерживает эти свойства. \r\nВыводы \r\nВ этой книге делается попытка всецело охватить все современные, профессиональные технологии \r\nпрограммирования на JavaScript, поскольку они используются всеми, от индивидуальных разработчиков до \r\nбольших корпораций, делая их код более удобным, понятным и интерактивным.  \r\nВ этой главе мы получили короткий обзор всего, о чем собираемся вести речь в этой книге. Сюда входят \r\nосновы профессионального программирования на JavaScript: создание объектно-ориентированного кода, его \r\nтестирование и создание пакета распространения. Затем вы увидели, в чем заключаются фундаментальные \r\nаспекты создания ненавязчивых DOM-сценариев, включая краткий обзор объектной модели документа, событий и \r\nвопросов взаимодействия между JavaScript и CSS. И, наконец, вы взглянули на исходные условия, лежащие в \r\nоснове технологии Ajax и на проблему поддержки JavaScript в современные браузерах. Изучение всех этих тем \r\nболее чем достаточное условие освоения уровня профессионального программирования на JavaScript. \r\n","\r\n 22\r\nГлава 2 Объектно-ориентированный JavaScript \r\nОбъекты являются основными элементами JavaScript. В сущности все в JavaScript является объектом, со \r\nвсеми вытекающими из этого преимуществами. Но чтобы заработать репутацию надежного объектно-\r\nориентированного языка, JavaScript включает широкий арсенал свойств, делающих его весьма оригинальным \r\nязыком, как по возможностям, так и по стилю. \r\nВ этой главе я хочу начать с охвата некоторых наиболее важных аспектов языка JavaScript, среди которых \r\n ссылки, область видимости, замыкания и контекст, которым слишком мало уделено внимания в других книгах по \r\nJavaScript. После того, как будет заложен прочный фундамент, мы перейдем к исследованию других важных \r\nаспектов объектно-ориентированного JavaScript, куда будут включены тонкости поведения объектов, способы \r\nсоздания новых объектов и установка методов со специфическими полномочиями. Если отнестись к ней со всей \r\nсерьезностью, то вполне возможно, что эта глава — самая важная в книге, поскольку она должна полностью \r\nизменить ваш взгляд на JavaScript, как на язык программирования. \r\nСвойства языка \r\nВ языке JavaScript имеется ряд свойств, составляющих основу его самобытности. Подобными свойствами \r\nобладают очень немногие другие языки. Лично я считаю, что сочетание свойств и придает языку ту самую \r\nскрытую мощь. \r\nСсылки \r\nОсновным аспектом JavaScript является понятие ссылок. Ссылка — это указатель на фактическое \r\nместонахождение объекта. Это невероятно мощное свойство, в отношении которого действует предположение, что \r\nфизический объект никогда не может быть ссылкой. Строка — это всегда строка, а массив — всегда массив. Но на \r\nодин и тот же объект могут ссылаться многие переменные. Именно на такой системе ссылок построен JavaScript. \r\nПоддерживая наборы ссылок на другие объекты, язык предоставляет вам гораздо больше гибкости. \r\nВдобавок к этому объект может содержать набор свойств, целиком состоящий из простых ссылок на другие \r\nобъекты (такие как строки, числа, массивы и т.д.). Когда несколько переменных указывают на один и тот же \r\nобъект, модификация исходного типа этого объекта отразится на всех переменных. Соответствующий пример \r\nпоказан в листинге 2.1, где две переменные указывают на один и тот же объект, а модификация содержимого \r\nобъекта имеет глобальный эффект. \r\nЛистинг 2.1. Пример нескольких переменных, ссылающихся на один и тот же объект \r\n// Установка obj на пустой объект \r\nvar obj = new Object(); \r\n  \r\n// теперь objRef является ссылкой на другой объект \r\nvar objRef = obj; \r\n  \r\n// Модификация свойства исходного объекта \r\nobj.oneProperty = true; \r\n  \r\n// Теперь мы видим, что это изменение представлено в обеих переменных \r\n// (Поскольку обе они ссылаются на один и тот же объект) \r\nalert( obj.oneProperty === objRef.oneProperty ); \r\nПрежде я уже упоминал, что самомодифицирующиеся объекты составляют для JavaScript большую \r\nредкость. Рассмотрим один довольно известный случай, когда это все-таки происходит. Объект массива способен \r\n","\r\n 23\r\nсамостоятельно дополняться элементами, используя метод push(). Поскольку в ядре объекта Array значения \r\nсохранены как свойства объекта, в результате возникает ситуация, подобная той, что показана в листинге 2.1, где \r\nобъект становится глобально модифицированным (приводящая к одновременным изменениям в содержимом \r\nмножества переменных). При мер подобной ситуации приведен в листинге 2.2. \r\nЛистинг 2.2. Пример самомодифицирующегося объекта \r\n// Создание массива элементов \r\nvar items = new Array( \"one\", \"two\", \"three\" ); \r\n  \r\n// Создание ссылки на массив элементов \r\nvar itemsRef = items; \r\n  \r\n// Добавление элемента к исходному массиву \r\nitems.push( \"four\" ); \r\n  \r\n// Длина обоих массивов должна быть одинаковой, \r\n// поскольку оба они указывают на один и то же объект массива \r\nalert( items.length == itemsRef.length ); \r\nВажно запомнить, что ссылки всего лишь указывают на конечный объект, на который они ссылаются, и не \r\nявляются ссылками друг на друга. К примеру, в Perl есть возможность иметь ссылку, указывающую на другую \r\nпеременную, которая также является ссылкой. Но в JavaScript ссылка опускается по цепочке ссылок, и указывает \r\nтолько на основной объект. Эта ситуация проиллюстрирована в листинге 2.3, где физический объект претерпевает \r\nизменения, но ссылка продолжает указывать на старый объект. \r\nЛистинг 2.3. Изменение ссылки на объект Changing the Reference of an Object While Maintaining Integrity \r\n// Установка items на массив строковых значений (объект) \r\nvar items = new Array( \"one\", \"two\", \"three\" ); \r\n  \r\n// Установка itemsRef в качестве ссылки на items \r\nvar itemsRef = items; \r\n  \r\n// Установка items на новый объект \r\nitems = new Array( \"new\", \"array\" ); \r\n  \r\n// Теперь items и itemsRef указывают на разные объекты. \r\n// items указывает на new Array( \"new\", \"array\" ) \r\n// itemsRef указывает на new Array( \"one\", \"two\", \"three\" ) \r\nalert( items !== itemsRef ); \r\nИ, наконец, взглянем на удивительный случай, возникающий при самомодификации объекта, но \r\nприводящий к возникновению нового объекта, ссылки на который отсутствуют. При объединении строк всегда \r\nобразуется новый объект строки, а не модифицированная версия исходной строки. Этот случай показан в \r\nлистинге 2.4. \r\nЛистинг 2.4. Пример модификации объекта, в результате которой возникает не самомодифицированный, а \r\nновый объект \r\n// Установка item на новый строковый объект \r\n","\r\n 24\r\nvar item = \"test\"; \r\n  \r\n// Теперь itemRef ссылается на тот же самый строковый объект \r\nvar itemRef = item; \r\n  \r\n// Объединение строкового объекта в новым текстом \r\n// Учтите, что при этом создается новый объект, \r\n// а не модифицируется исходный. \r\nitem += \"ing\"; \r\n  \r\n// Значения item и itemRef не равны друг другу, поскольку \r\n// был создан абсолютно новый строковый объект \r\nalert( item != itemRef ); \r\nЕсли вы плохо знакомы со ссылками, то в них не сложно и запутаться. Но понимание  порядка их \r\nработы является основой для создания высококачественного и свободного от ошибок кода JavaScript. В \r\nнескольких следующих разделах мы рассмотрим ряд свойств, которые может быть и не отличаются новизной или \r\nособой привлекательностью, но играют важную роль в написании безупречного программного кода. \r\nПерегрузка функций и проверка типов \r\nРаспространенным свойством других объектно-ориентированных языков, к которым относиться и язык \r\nJava, является возможность «перегрузки» функций, изменяющей ее поведение в зависимости от количества или \r\nтипов переданных им аргументов. Хотя напрямую это свойство в JavaScript не доступно, ряд имеющихся в нем \r\nинструментов предоставляет точно такую же возможность. \r\nДля перегрузки функций требуются две вещи: возможность определения количества предоставленных \r\nаргументов, и возможность определения типа аргументов. Начнем с количества предоставленных аргументов. \r\nВнутри каждой функции JavaScript существует контекстно-зависимая переменная под названием \r\narguments, которая ведет себя как псевдомассив, содержащий все переданные функции аргументы. Переменная \r\nArguments не является настоящим массивом (т.е. вы не можете вносить в нее изменения  или вызывать метод \r\n.push( ) для добавления новых элементов), но можете обращаться к элементам массива и использовать свойство \r\n.length. Это подтверждается двумя примерами, показанными в листинге 2.5. \r\nЛистинг 2.5. Два примера перегрузки функции в  JavaScript \r\n// Простая функция отправки сообщения \r\nfunction sendMessage( msg, obj ) { \r\n  \r\n    // если предоставлен и текст сообщения и объект \r\n    if ( arguments.length == 2 ) \r\n       // Отправить сообщение объекту \r\n       obj.handleMsg( msg ); \r\n  \r\n    // В противном случае предположить, что предоставлен только текст \r\n    // сообщения \r\n    else \r\n       // Поэтому ограничиться выводом задаваемого по умолчанию сообщения \r\n       // об ошибке \r\n       alert( msg ); \r\n","\r\n 25\r\n} \r\n  \r\n// Вызов функции с одним аргументом  приводит к отображения сообщения \r\n// с использованием метода alert \r\nsendMessage( \"Hello, World!\" ); \r\n  \r\n// Также функции можно передать свой собственный объект, который \r\n// осуществляет другой способ отображения информации \r\n  \r\nsendMessage( \"How are you?\", { \r\n    handleMsg: function( msg ) { \r\n       alert( \"This is a custom message: \" + msg ); \r\n    } \r\n}); \r\n  \r\n// Функция, принимающая любое количество аргументов и составляющая из них \r\n// массив \r\n  \r\nfunction makeArray() { \r\n    // Временный массив \r\n    var arr = []; \r\n  \r\n    // Перебор всех переданных аргументов \r\n    for ( var i = 0; i < arguments.length; i++ ) { \r\n       arr.push( arguments[i] ); \r\n    } \r\n    \r\n    // Возвращение получившегося массива \r\n    return arr; \r\n} \r\nСуществует также и другой метод определения количества аргументов, переданных функции. Но он имеет \r\nнесколько более изощренную природу использования.  В нем применяется тот факт, что любой, не переданный \r\nаргумент  имеет значение неопределенного типа — undefined. В листинге 2.6 показана простая функция, \r\nпредназначенная для отображения сообщения об ошибке, и предоставляющая сообщение по умолчанию, если \r\nникакое сообщение ей не передано. \r\nЛистинг 2.6. Отображение сообщения об ошибке и сообщения по умолчанию \r\nfunction displayError( msg ) { \r\n    // Проверка на то, что значение msg не определено (undefined) \r\n    if ( typeof msg == 'undefined' ) { \r\n       // Если оно не определено, установить значение по умолчанию \r\n       msg = \"Произошла ошибка.\"; \r\n    } \r\n  \r\n    // Отображение сообщения \r\n    alert( msg ); \r\n} \r\n","\r\n 26\r\nИспользование оператора typeof помогает нам перейти к теме проверки типов. Поскольку JavaScript на \r\nданный момент является языком с динамическим определением типов, то эта тема может оказаться очень \r\nполезной и интересной. Существует несколько различных способов проверки типа переменной, но мы собираемся \r\nрассмотреть два самых полезных. \r\nПервый способ проверки типа объекта заключается в использовании интуитивно понятного оператора \r\ntypeof. Этот оператор дает нам строковое имя, представляющее тип содержимого переменной. Применение этого \r\nспособа было бы великолепным решением, за исключением того, что для переменных типа object или array, или \r\nпользовательского объекта, к примеру, user, этот оператор возвращает строку object, не позволяя понять, в чем \r\nсостоит разница между всеми этими объектами. Пример применения этого способа показан в листинге 2.7. \r\nЛистинг 2.7. Пример использования Typeof для определения типа объекта \r\n// Проверка, не является ли наше число на самом деле строкой \r\nif ( typeof num == \"string\" ) \r\n    // Если является, выделение из нее численной составляющей \r\n    num = parseInt( num ); \r\n  \r\n// Проверка, не является ли наш массив на самом деле строкой \r\nif ( typeof arr == \"string\" ) \r\n    // Если так оно и есть, создание массива,за счет разбиения строки \r\n    // по элементам, разделенным запятыми \r\n    arr = arr.split(\",\"); \r\nВторой способ проверки типа объекта заключается в использовании ссылки на свойство, присущее всем \r\nобъектам JavaScript, которое называется constructor. Это свойство является ссылкой на функцию, используемую \r\nдля первоначального создания этого объекта. Пример использования этого способа показан в листинге 2.8. \r\nЛистинг 2.8. Пример использования свойства constructor для определения типа объекта \r\n// Проверка, не является ли наше число на самом деле строкой \r\nif ( num.constructor == String ) \r\n    // Если является, выделение из нее численной составляющей \r\n    num = parseInt( num ); \r\n  \r\n// Проверка, не является ли наша строка на самом деле массивом \r\nif ( str.constructor == Array ) \r\n    // Если так оно и есть, создание строки за счет объединения элементов \r\n    // массива через запятые \r\n    str = str.join(','); \r\nВ таблице 2.1 показаны результаты проверки типа различных объектов с использованием двух, \r\nрассмотренных нами методов. В первом столбце таблицы показан объект, тип которого мы пытаемся определить. \r\nВо втором столбце показан результат работы оператора typeof Переменная (где Переменная — это значение, \r\nсодержащееся в первом столбце). Все результаты, представленные в этом столбце являются строками. И, наконец, \r\nв третьем столбце показан результат работы Переменная.constructor по отношению к объектам, содержащимся в \r\nпервом столбце. Все результаты, представленные в этом столбце, являются объектами. \r\nТаблица 2.1. Проверка типов переменных \r\nПеременная Тип переменной Конструктор переменной \r\n","\r\n 27\r\n{ an: “object” }                           object                                                Object \r\n[ “an”, “array” ]                          object                                                Array \r\nfunction(){} function              Function \r\n“a string”                                    string                                                 String \r\n55 number Number \r\ntrue boolean Boolean \r\nnew User()                                  object                                                User \r\nТеперь, воспользовавшись информацией из таблицы 2.1, вы можете создать универсальную функцию для \r\nпроведения внутри нее проверки типа. Теперь уже, наверное, очевидно, что использование конструктора \r\nпеременной в качестве ссылки на тип объекта — это наиболее надежный и безошибочный способ проверки типов. \r\nСтрогая проверка типов может помочь в тех случаях, когда вам нужно убедиться, что вашим функциям передано \r\nабсолютно точное количество аргументов абсолютно правильного типа. Практический пример такой проверки \r\nпоказан в листинге 2.9. \r\nЛистинг 2.9. Функция, которую можно использовать для строгого утверждения всех аргументов, \r\nпереданных функции \r\n// Строгая проверка списка типов переменных по списку аргументов \r\nfunction strict( types, args ) { \r\n  \r\n    // Проверка совпадения количества типов и аргументов \r\n    if ( types.length != args.length ) { \r\n  \r\n       // Если количество не совпадает, выдача полезного исключения \r\n       throw \"Неверное число аргументов. Ожидалось \" + types.length + \r\n           \", а вместо этого получено \" + args.length + \".\"; \r\n    } \r\n  \r\n    // Перебор всех аргументов и проверка их типов \r\n    for ( var i = 0; i < args.length; i++ ) { \r\n       // \r\n       if ( args[i].constructor != types[i] ) { \r\n           throw \"Неверный тип аргумента. Ожидался\" + types[i].name + \r\n               \", а получен \" + args[i].constructor.name + \".\"; \r\n       } \r\n    } \r\n} \r\n  \r\n// Простая функция, предназначенная для распечатки списка пользователей \r\nfunction userList( prefix, num, users ) { \r\n    // Проверка, что prefix — строка, num — число, \r\n    // а users — массив \r\n    strict( [ String, Number, Array ], arguments ); \r\n  \r\n    // Выполнение итерации до 'num' пользователей \r\n    for ( var i = 0; i < num; i++ ) { \r\n","\r\n 28\r\n       // Отображение сообщения о каждом пользователе \r\n       print( prefix + \": \" + users[i] ); \r\n    } \r\n} \r\nПроверка типа переменных и проверка длины массива аргументов по сути являются весьма простыми \r\nпонятиями, но могут использоваться для обеспечения сложных методов, которые могут быть к ним \r\nприспособлены, и создавать о вашем коде наилучшие впечатления у разработчиков и пользователей. Далее мы \r\nсобираемся рассмотреть область видимости, существующую в JavaScript, и как ею лучше всего управлять. \r\nОбласть видимости переменных \r\nВ JavaScript область видимости имеет свои особенности. Те или иные формы проявления области \r\nвидимости присутствуют во всех объектно-ориентированных языках программирования; а какие именно — \r\nзависит от того, в каком контексте сохраняется эта область. В JavaScript область видимости сохраняется внутри \r\nфункций, а не блоков (образуемых такими операторами, как while, if и for). В итоге может получиться код, \r\nимеющий, казалось бы, несколько странный результат работы (если вы ранее работали с языками, имеющими \r\nпоблочные области видимости). В листинге 2.10 показан пример результата работы кода с областью видимости, \r\nпроявляемой  внутри функции. \r\nЛистинг 2.10. Пример работы области видимости переменных в JavaScript \r\n// Установка значения 'test' для глобальной переменной foo \r\nvar foo = \"test\"; \r\n  \r\n// Внутри блока if \r\nif ( true ) { \r\n    // Присвоение foo значения 'new test' \r\n    // ПРИМЕЧАНИЕ: все это внутри глобальной области видимости! \r\n    var foo = \"new test\"; \r\n} \r\n  \r\n// Здесь мы видим, что foo теперь равна 'new test' \r\nalert( foo == \"new test\" ); \r\n  \r\n// Создание функции, изменяющей значение переменной foo \r\nfunction test() { \r\n    var foo = \"old test\"; \r\n} \r\n  \r\n// Тем не менее, когда осуществляется ее вызов, воздействие на 'foo' \r\n// проявляется только в области видимости внутри функции \r\ntest(); \r\n  \r\n// что подтверждается тем, что значение foo по-прежнему равно 'new test' \r\nalert( foo == \"new test\" ); \r\nОбратите внимание на то, что в листинге 2.10 переменные находятся внутри глобальной области \r\nвидимости. Интересной особенностью встроенных в браузеры версий JavaScript является то, что переменные, \r\nимеющие глобальную область видимости, фактически являются лишь свойствами объекта window. Хотя в \r\nнекоторых устаревших версиях Opera и Safari этого не происходит, все-таки лучше придерживаться того, что \r\n","\r\n 29\r\nбраузер именно так себя и ведет. В листинге 2.11 показан пример такого проявления глобальной области \r\nвидимости. \r\nЛистинг 2.11. Пример глобальной области видимости в JavaScript и в объекте Window \r\n// Глобальная переменная, в которой содержится строка 'test' \r\nvar test = \"test\"; \r\n  \r\n// Обратите внимание на то, что наша 'глобальная' переменная и свойство test \r\n// объекта window идентичны друг другу \r\nalert( window.test == test ); \r\nИ, наконец, посмотрим, что произойдет когда объявление переменной не определено. В листинге 2.12 \r\nзначение переменной foo присвоено в области видимости внутри функции test( ). Тем не менее, в этом листинге \r\nфактически нигде не объявлена область видимости этой переменной (не использовано объявление var foo). Когда \r\nпеременная foo не объявлена явным образом, она становиться глобальной, даже если она используется только в \r\nобласти видимости внутри функции. \r\nЛистинг 2.12. Пример скрытого объявления глобальной переменной \r\n// Функция, внутри которой устанавливается значение переменной foo \r\nfunction test() { \r\n    foo = \"test\"; \r\n} \r\n  \r\n// Вызов функции для установки значения foo \r\ntest(); \r\n  \r\n// Мы видим, что теперь foo имеет глобальную область видимости \r\nalert( window.foo == \"test\" ); \r\nХотя в JavaScript механизм области видимости и не такой строгий, как у языков, где он имеет блочный \r\nхарактер, теперь уже не остается сомнений в том, что он все же обладает достаточной мощностью и \r\nвыразительностью. А когда это еще и сочетается с понятием замкнутых выражений, которое будет рассмотрено в \r\nследующем разделе, JavaScript проявляет себя очень мощным языком сценариев. \r\nЗамкнутые выражения \r\nЗамкнутые выражения — это средства, через которые внутренние функции могут сослаться на \r\nпеременные, представленные в их внешних функциях, в которые они были включены, после того, как их \r\nродительские функции уже завершили свою работу. Именно эта тема может сильно повлиять на ваши \r\nпредставления и может стать слишком сложной для восприятия. Я настоятельно рекомендую обратиться к веб-\r\nсайту, упомянутому в конце этого раздела, поскольку на нем выложена превосходная информация по теме \r\nзамкнутых выражений. \r\nНачнем с рассмотрения двух простых примеров замкнутых выражений, показанных в листинге 2.13. \r\nЛистинг 2.13. Два примера, показывающие, как замкнутые выражения могут сделать ваш код более \r\nпонятным \r\n// Поиск элемента, ID которого равен 'main' \r\nvar obj = document.getElementById(\"main\"); \r\n","\r\n 30\r\n  \r\n// Изменение стиля его обрамления \r\nobj.style.border = \"1px solid red\"; \r\n  \r\n// Инициализация обратного вызова, который должен произойти через одну \r\n// секунду \r\nsetTimeout(function(){ \r\n    // и сделать объект невидимым \r\n    obj.style.display = 'none'; \r\n}, 1000); \r\n  \r\n// Типичная функция для отображения задержанного сообщения   \r\nfunction delayedAlert( msg, time ) { \r\n    // Инициализация вложенного обратного вызова \r\n    setTimeout(function(){ \r\n       // в котором используется сообщение, переданное из включающей его \r\n       // функции \r\n       alert( msg ); \r\n    }, time ); \r\n} \r\n  \r\n// Вызов функции delayedAlert с двумя аргументами \r\ndelayedAlert( \"Добро пожаловать!\", 2000 ); \r\nПервый вызов функции setTimeout демонстрирует распространенный случай, когда у неопытных \r\nразработчиков на JavaScript возникают проблемы. Зачастую в их программах можно увидеть примерно следующий \r\nкод: \r\nsetTimeout(\"otherFunction()\", 1000); \r\n  \r\n// или даже ...; \r\nsetTimeout(\"otherFunction(\" + num + \",\" + num2 + \")\", 1000); \r\nИспользуя понятие замкнутых выражений, можно вполне обойтись и без этой мешанины программного \r\nкода. В первом примере все очень просто. В нем имеется обратный вызов, выполняемый через 1000 миллисекунд \r\nпосле первого вызова, в котором есть ссылка на переменную obj (которая определена как глобальная \r\nпеременная, содержащая ссылку на элемент с ID равным main). Вторая, определенная в примере функция, \r\ndelayedAlert, показывает решение  по выводу сообщения с помощью setTimeout, а также возможность иметь \r\nзамкнутые выражения в пределах областей видимости функций. \r\nВы можете убедиться, что использование простых замкнутых выражений, подобных тому, которое \r\nприменено в нашем коде, делает содержание программы более понятным,  не давая ему превращаться в \r\nсинтаксический винегрет. \r\nРассмотрим один интересный побочный эффект, который можно получить при  использовании замкнутых \r\nвыражений. В некоторых функциональных языках программирования существует понятие карринга (currying). По \r\nсвоей сути, карринг — это способ предварительного наполнения функции некоторым количеством аргументов, \r\nпутем создания новой, более простой функции. В листинге 2.14 приведен простой пример карринга, создающего \r\nновую функцию, преднаполняемую аргументом другой функции. \r\nЛистинг 2.14. Пример осуществления карринга функции с использованием замкнутых выражений  \r\n","\r\n 31\r\n// Функция, генерирующая новую функцию сложения чисел \r\nfunction addGenerator( num ) { \r\n  \r\n    // Возврат простой функции, выполняющей сложение двух чисел, где первое \r\n    // число позаимствовано у генератора \r\n    return function( toAdd ) { \r\n       return num + toAdd \r\n    }; \r\n} \r\n  \r\n// Теперь addFive содержит функцию, которая берет один аргумент прибавляет к \r\n// нему число пять, и возвращает полученный результат \r\nvar addFive = addGenerator( 5 ); \r\n  \r\n// Здесь мы можем убедиться, что результат работы функции addFive равен 9, \r\n// когда ей в качестве аргумента передается число 4 \r\nalert( addFive( 4 ) == 9 ); \r\nПри программировании на JavaScript возникает еще одна, довольно распространенная проблема, которую \r\nможно решить с помощью замкнутых выражений. Дело в том, что неопытные разработчики имеют привычку \r\nслучайно оставлять в глобальной области видимости большое количество абсолютно ненужных переменных. Эта \r\nпрактика всегда считалась порочной, поскольку эти лишние переменные могут создавать скрытую помеху работе \r\nкаких-нибудь  библиотек, вызывая возникновение запутанных проблем. В листинге 2.15 показано, как используя \r\nсамовыполняемые, безымянные функции, вы можете фактически скрыть от всего остального кода все \r\nпеременные, которые обычно получают глобальную область видимости. \r\nЛистинг 2.15. Пример использования безымянных функций для скрытия переменных от глобального \r\nобозрения \r\n// Создание новой безымянной функции, используемой в качестве оболочки \r\n(function(){ \r\n    // Переменная, обычно имеющая глобальную область видимости \r\n    var msg = \"Спасибо за визит!\"; \r\n  \r\n    // Привязка к глобальному объекту новой функции, \r\n    window.onunload = function(){ \r\n       // которая использует 'скрытую' переменную \r\n       alert( msg ); \r\n    }; \r\n  \r\n// Закрытие безымянной функции и ее выполнение \r\n})(); \r\nВ заключение рассмотрим одну проблему, связанную с использованием замкнутых выражений. Вспомним, \r\nчто замкнутые выражения дают возможность ссылаться на переменные, которые существуют внутри родительской \r\nфункции. Но они не предоставляют значений этих переменных, присвоенных им в момент создания, а дают самые \r\nпоследние значения этих переменных, которые были получены ими в родительских функциях. Наиболее часто эта \r\nпроблема проявляется при работе цикла. Представим, что есть переменная, используемая в качестве итератора \r\n(например, i). Внутри цикла for создается новая функция, использующая замкнутое выражение, для ссылки на \r\nитератор. Проблема в том, что к тому времени, когда будет происходить вызов новых замкнутых функций, они \r\n","\r\n 32\r\nбудут ссылаться на последнее значение итератора (например, на последнюю позицию массива), а не на то \r\nзначение, которое, возможно, вами ожидалось. В листинге 2.16 показан пример использования безымянных \r\nфункций, порождающих область видимости для создания экземпляра, в котором можно использовать ожидаемое \r\nзамкнутое выражение. \r\nЛистинг 2.16. Пример использования безымянной функции для порождения области видимости, \r\nнеобходимой для создания множества функций, использующих замкнутые выражения \r\n// Элемент, у которого значение ID равно main \r\nvar obj = document.getElementById(\"main\"); \r\n  \r\n// Массив элементов для привязки \r\nvar items = [ \"click\", \"keypress\" ]; \r\n  \r\n// Итерация по всем элементам \r\nfor ( var i = 0; i < items.length; i++ ) { \r\n    // Создание самовыполняемой безымянной функции для порождения области \r\n    // видимости \r\n    (function(){ \r\n       // Запоминание значения внутри этой области видимости \r\n       var item = items[i]; \r\n       // Привязка функции к элементу \r\n       obj[ \"on\" + item ] = function() { \r\n           // элемент обращается к родительской переменной, которая была \r\n           // успешно увидена в содержимом этого цикла for \r\n           alert( \"Спасибо за ваш \" + item ); \r\n       }; \r\n    })(); \r\n} \r\nПонятие замкнутых выражений не так-то легко усвоить; мне понадобилось потратить массу времени и \r\nусилий, что бы по-настоящему осознать ту мощность, которая в них заключена. Хорошо, что нашелся \r\nзамечательный источник, в котором объясняется работа замкнутых выражений в JavaScript — статья Джима Джея \r\n(Jim Jey) «JavaScript Closures» опубликованная по адресу http://jibbering.com/faq/faq_notes/closures.html. \r\nВ заключение, мы рассмотрим понятие контекста, которое является той самой  строительной конструкцией, \r\nвокруг которой выстраивается вся объектно-ориентированная функциональность JavaScript. \r\nКонтекст \r\nУ вашего кода в JavaScript всегда будет какая-то разновидность контекста (объект, внутри которого он \r\nработает). Это свойственно и другим объектно-ориентированным языкам, но без тех экстремальных \r\nобстоятельств, которые встречаются в JavaScript. \r\nКонтекст проявляется посредством переменной this. Эта переменная всегда будет ссылаться на объект, \r\nвнутри которого код в данный момент работает. Следует помнить, что глобальные объекты фактически являются \r\nсвойствами объекта window. Это означает, что даже в глобальном контексте переменная this будет ссылаться на \r\nобъект. Контекст может быть довольно мощным инструментом, одним из самых  важных для объектно-\r\nориентированного кода. В листинге 2.17 показаны несколько простых примеров контекста. \r\n","\r\n 33\r\nЛистинг 2.17. Пример использования функций в пределах контекста с последующим переключением их \r\nконтекста на другую переменную \r\nvar obj = { \r\n    yes: function(){ \r\n       // this == obj \r\n       this.val = true; \r\n    }, \r\n    no: function(){ \r\n       this.val = false; \r\n    } \r\n}; \r\n  \r\n// Мы видим, что свойство в объекте 'obj' отсутствует \r\nalert( obj.val == null ); \r\n  \r\n// Мы запускаем функцию yes и она вносить изменения в свойство val, \r\n// связанное с объектом 'obj' \r\nobj.yes(); \r\nalert( obj.val == true ); \r\n  \r\n// А теперь указываем window.no на метод obj.no, и запускаем его \r\nwindow.no = obj.no; \r\nwindow.no(); \r\n  \r\n// Это приводит к тому, что объект obj остается неизменным (поскольку \r\n// контекст был переключен на объект window) \r\nalert( obj.val == true ); \r\n  \r\n// а свойство val объекта window стало обновленным. \r\nalert( window.val == false ); \r\nВозможно, вы обратили внимание, на то, какой неуклюжий код был использован в листинге 2.17 для \r\nпереключения контекста метода obj.no на переменную window. К счастью, в JavaScript есть несколько методов, \r\nупрощающих понимание и реализацию этого процесса. В листинге 2.18 показаны два разных метода, call и apply, \r\nспособные справиться с этой задачей. \r\nЛистинг 2.18. Примеры изменения контекста функций \r\n// Простая функция, устанавливающая цветовой стиль своего контекста \r\nfunction changeColor( color ) { \r\n    this.style.color = color; \r\n} \r\n  \r\n// Ее вызов для объекта window, заканчивающийся неудачей, поскольку в нем \r\n// нет объекта style \r\nchangeColor( \"white\" ); \r\n  \r\n// Поиск элемента, ID которого равен main \r\nvar main = document.getElementById(\"main\"); \r\n","\r\n 34\r\n  \r\n// Установка для него черного цвета, используя метод call \r\n// Этот метод устанавливает контекст по первому аргументу, и передает все \r\n// остальные аргументы в качестве аргументов функции \r\nchangeColor.call( main, \"black\" ); \r\n  \r\n// Функция, устанавливающая цвет элемента body \r\nfunction setBodyColor() { \r\n    // Метод apply устанавливает контекст на элемент body, указанный в \r\n    // качестве первого аргумента, второй аргумент представляет собой массив \r\n    // аргументов, передаваемых функции \r\n    changeColor.apply( document.body, arguments ); \r\n} \r\n  \r\n// Установка для элемента body черного цвета \r\nsetBodyColor( \"black\" ); \r\nВозможно, польза от применения контекста не покажется сразу же столь очевидной, но она несомненно \r\nпроявится в следующем разделе, где мы рассмотрим объектно-ориентированные свойства JavaScript. \r\nОбъектно-ориентированные основы JavaScript \r\nФраза «объектно-ориентированный JavaScript» страдает явной избыточностью, поскольку язык JavaScript \r\nявляется полностью объектно-ориентированным, и использовать его как-то по-другому просто невозможно. Тем не \r\nменее, недостаток многих неопытных программистов (включая и работающих на JavaScript) проявляется в том, что \r\nони пишут свой код с функциональным подходом, не используя контекст или группировку. Чтобы обрести \r\nисчерпывающее понятие о том, как пишется оптимальный код JavaScript, нужно понять, как работают объекты \r\nJavaScript, в чем состоят их отличия от объектов в других языках программирования, и как этими отличиями \r\nможно воспользоваться. \r\nВ остальной части этой главы мы изучим основы написания объектно-ориентированного кода в JavaScript, \r\nа затем, в следующих главах пройдем практикум создания такого кода. \r\nОбъекты \r\nОбъекты являются основой JavaScript. Фактически все внутри языка является объектом. Основная \r\nсоставляющая мощности языка базируется именно на этом факте. На своем самом базовом уровне объекты \r\nсуществуют как семейства свойств, чем-то напоминая хэш-конструкции, которые можно увидеть в других языках. \r\nВ листинге 2.19 показаны два основных примера создания объекта с набором свойств. \r\nЛистинг 2.19. Два примера создания простого объекта и установки его свойств \r\n// создание нового Object-объекта и сохранение его в 'obj' \r\nvar obj = new Object(); \r\n  \r\n// Присвоение некоторым свойствам объекта различных значений \r\nobj.val = 5; \r\nobj.click = function(){ \r\n    alert( \"hello\" ); \r\n}; \r\n  \r\n","\r\n 35\r\n// Эквивалентный код, использующий для определения свойств \r\n// сокращенную запись {...;} и пар ключ-значение \r\nvar obj = { \r\n  \r\n    // Установка имен свойств и значений с использованием пар \r\n    // ключ-значение \r\n    val: 5, \r\n    click: function(){ \r\n       alert( \"hello\" ); \r\n    } \r\n  \r\n}; \r\nВ действительности для объектов ничего кроме этого и не нужно. Но при создании новых объектов, \r\nособенно тех, которые наследуют свойства других объектов все уже не так просто. \r\nСоздание объектов \r\nВ отличие от многих других объектно-ориентированных языков, понятие классов в JavaScript фактически \r\nотсутствует. Большинство других объектно-ориентированных языков дает возможность реализовать экземпляр \r\nконкретного класса, но к JavaScript это не относится. В JavaScript объекты могут создавать другие объекты, и \r\nобъекты могут быть унаследованы от других объектов. В общем смысле это понятие называется наследованием \r\nпрототипов и будет рассмотрено чуть позже в разделе «Публичные методы». \r\nИ все-таки в JavaScript должен быть способ создания нового объекта, независимо от того какая объектная \r\nсхема в нем используется. JavaScript делает так, что любая функция может быть также создана в качестве \r\nэкземпляра объекта. Это звучит  несколько запутаннее, чем есть на самом деле. Все очень похоже на разделку \r\nкуска теста (заготовки объекта) при помощи формы для печенья (в качестве которой выступает конструктор \r\nобъекта, использующий его прототип). \r\nПример того, как это все работает, показан в листинге 2.20. \r\nЛистинг 2.20. Создание и использование простого объекта \r\n// Простая функция, принимающая имя и сохраняющая \r\n// его в текущем контексте \r\nfunction User( name ) { \r\n    this.name = name; \r\n} \r\n  \r\n// Создание нового экземпляра этой функции с указанием имени \r\nvar me = new User( \"My Name\" ); \r\n  \r\n// Мы можем убедиться в том, ее имя было установлено в качестве ее \r\n// собственного свойства \r\nalert( me.name == \"My Name\" ); \r\n  \r\n// И что это экземпляр объекта User \r\nalert( me.constructor == User ); \r\n  \r\n// Теперь, поскольку User() по-прежнему является функцией, что будет, если \r\n","\r\n 36\r\n// мы воспользуемся ею именно в этом качестве? \r\nUser( \"Test\" ); \r\n  \r\n// Поскольку ее 'this' контекст не был установлен, он по умолчанию \r\n// устанавливается на глобальный объект 'window', значит, свойство \r\n// window.name равно переданному имени \r\nalert( window.name == \"Test\" ); \r\nЛистинг 2.20 показывает работу свойства constructor. Это свойство существует в каждом объекте, и всегда \r\nбудет указывать в обратном направлении, на функцию, создавшую этот объект. Благодаря ему можно довольно \r\nэффективно получать дубликат объекта, создавая новый объект того же базового типа, но не с теми же \r\nсвойствами. Пример этому показан в листинге 2.21. \r\nЛистинг 2.21. Пример использования свойства constructor \r\n// Создание нового, простого объекта User \r\nfunction User() {} \r\n  \r\n// Создание нового объекта User \r\nvar me = new User(); \r\n   \r\n// Также создание нового объекта User (из конструктора, ссылающегося на \r\n// первый объект) \r\nvar you = new me.constructor(); \r\n  \r\n// Мы можем увидеть, что свойства constructor фактически одинаковы \r\nalert( me.constructor == you.constructor ); \r\nТеперь, зная, как создаются простые объекты, настало время их дополнить компонентами, придающими им \r\nреальную пользу: контекстными методами и свойствами. \r\nПубличные методы \r\nПубличные (Public) методы  полностью доступны конечному пользователю в пределах контекста объекта. \r\nЧтобы успешно пользоваться этими публичными методами, доступными каждому экземпляру конкретного объекта, \r\nнужно узнать о свойстве под названием prototype (прототип), в котором просто содержится объект, действующий \r\nв качестве основной ссылки для всех новых копий его родительского объекта. Фактически любое свойство \r\nпрототипа будет доступно в любом экземпляре объекта. Этот процесс создания и ссылки предоставляет нам \r\nлегкую версию наследования, обсуждаемую в главе 3. \r\nПоскольку прототип объекта тоже является объектом, вы можете присоединять к нему новые свойства, как \r\nко всякому другому объекту. Присоединение к прототипу новых свойств сделает их частью каждого объекта \r\nсозданного в качестве экземпляра прототипа, придавая всем этим свойствам публичность (и всеобщую \r\nдоступность). Соответствующий пример показан в листинге 2.22. \r\nЛистинг 2.22. Пример объекта с методами, присоединенными через объект prototype \r\n// Создание нового конструктора User \r\nfunction User( name, age ){ \r\n    this.name = name; \r\n    this.age = age; \r\n","\r\n 37\r\n} \r\n  \r\n// Добавление к объекту prototype новой функции \r\nUser.prototype.getName = function(){ \r\n    return this.name; \r\n}; \r\n  \r\n// Добавление еще одной функции к prototype \r\n// Обратите внимание, что ее контекстом будут и объекты, созданные в \r\n// качестве экземпляра прототипа \r\nUser.prototype.getAge = function(){ \r\n    return this.age; \r\n}; \r\n  \r\n// Создание экземпляра нового объекта User \r\nvar user = new User( \"Bob\", 44 ); \r\n  \r\n// Мы можем убедиться в том, что те два метода, которые мы присоединили \r\n// вместе с объектом, действуют в пределах надлежащего контекста \r\nalert( user.getName() == \"Bob\" ); \r\nalert( user.getAge() == 44 ); \r\nПри создании новых приложений простые конструкторы и простая обработка прототипа объекта входят в \r\nарсенал многих разработчиков кода JavaScript. В остальной части этого раздела я собираюсь объяснить суть ряда \r\nдругих технологических приемов, которыми вы можете воспользоваться для извлечения из объектно-\r\nориентированного кода еще больших преимуществ. \r\nЧастные методы \r\nЧастные (Private) методы и переменные доступны только другим частным методам, частным переменным, и \r\nпривилегированным методам (рассматриваемым в следующем разделе). Они представляют собой способ \r\nопределения кода который будет доступен только внутри самого объекта, но не за его пределами. Эта технология \r\nоснована на работе Дугласа Крокфорда (Douglas Crockford), на чьем веб-сайте представлен ряд документов, \r\nдетализирующих работу и порядок использования объектно-ориентированных объектов: \r\n• Список статей по JavaScript: http://javascript.crockford.com/ \r\n• Статья «Private Members in JavaScript»: http://javascript.crockford.com/private.html \r\nВ листинге 2.23 мы можем увидеть пример того, как частный метод может быть использован в приложении. \r\nЛистинг 2.23. Пример частного метода, пригодного только для использования функцией constructor \r\n// Конструктор объекта, представляющего учебный класс \r\nfunction Classroom( students, teacher ) { \r\n    // частный метод, используемый для отображения всех учащихся класса \r\n    function disp() { \r\n       alert( this.names.join(\", \") ); \r\n    } \r\n  \r\n    // Сохранение данных о классе в качестве публичных свойств объекта \r\n","\r\n 38\r\n    this.students = students; \r\n    this.teacher = teacher; \r\n  \r\n    // Вызов частного метода для отображения ошибки \r\n    disp(); \r\n} \r\n  \r\n// Создание нового объекта classroom \r\nvar class = new Classroom( [ \"John\", \"Bob\" ], \"Mr. Smith\" ); \r\n  \r\n// Невыполнимый код, поскольку disp не является публичным свойством объекта \r\nclass.disp(); \r\nНесмотря на свою простоту, частные методы и переменные играют важную роль в избавлении кода от \r\nконфликтных ситуаций, позволяя лучше управлять тем, что видят и с чем работают ваши пользователи. Далее мы \r\nсобираемся рассмотреть привилегированные методы, представляющие собой сочетание частных и публичных \r\nметодов, которые можно использовать в ваших объектах. \r\nПривилегированные методы \r\nТермин привилегированные методы создал Дуглас Крокфорд (Douglas Crockford) для ссылки на методы, \r\nкоторые могут видеть частные переменные и работать с ними (внутри объекта), будучи доступными \r\nпользователям в качестве публичных методов. В листинге 2.24 показан пример использования \r\nпривилегированных методов. \r\nЛистинг 2.24. Пример использования привилегированных методов \r\n// Создание нового конструктора объекта User \r\nfunction User( name, age ) { \r\n    // Попытка определить год рождения пользователя \r\n    var year = (new Date()).getFullYear() – age; \r\n  \r\n    // Создание нового привилегированного метода, имеющего доступ к \r\n    // переменной year, сохраняя при этом публичную доступность \r\n    this.getYearBorn = function(){ \r\n       return year; \r\n    }; \r\n} \r\n  \r\n// создание нового экземпляра объекта user \r\nvar user = new User( \"Bob\", 44 ); \r\n  \r\n// Проверка правильности возвращенного года \r\nalert( user.getYearBorn() == 1962 ); \r\n  \r\n// И уведомление о том, что нам недоступено частное свойство объекта year \r\nalert( user.year == null ); \r\nВ основном, привилегированные методы являются динамически сгенерированными, поскольку они \r\nдобавляются к объекту во время выполнения программы, а не при первой компиляции кода. Хотя эта технология с \r\n","\r\n 39\r\nточки зрения вычислительных ресурсов считается более затратной, чем привязка простого метода к прототипу \r\nобъекта, но помимо этого она является более мощной и гибкой. В листинге 2.25 показан пример того, что можно \r\nсделать, используя динамически генерируемые методы. \r\nЛистинг 2.25. Пример динамически генерируемых методов, которые создаются при создании нового \r\nэкземпляра объекта \r\n// Создание нового объекта user, принимающего объект свойств (properties) \r\nfunction User( properties ) { \r\n    // Последовательный перебор свойств объекта, и обеспечение \r\n    // для них нужной области видимости (как ранее рассматривалось) \r\n    for ( var i in properties ) { (function(){ \r\n       // Создание для свойства нового получателя \r\n       this[ \"get\" + i ] = function() { \r\n           return properties[i]; \r\n       }; \r\n    \r\n       // создание для свойства нового установщика \r\n       this[ \"set\" + i ] = function(val) { \r\n           properties[i] = val; \r\n       }; \r\n    })(); } \r\n} \r\n  \r\n// Создание нового экземпляра объекта user и передача в него объекта, \r\n// наполняющего его свойства \r\nvar user = new User({ \r\n    name: \"Bob\", \r\n    age: 44 \r\n}); \r\n  \r\n// Обратите внимание, что свойства имя (name) не существует, поскольку \r\n// внутри объекта properties оно является частным \r\nalert( user.name == null ); \r\n  \r\n// Тем не менее, мы можем получить доступ к его значению, используя новый \r\n// метод getname(), который был динамически сгенерирован \r\nalert( user.getname() == \"Bob\" ); \r\n  \r\n// В заключение, мы можем убедиться в том, что у нас есть возможность \r\n// установить и получить возраст (age) используя недавно сгенерированные \r\n// функции \r\nuser.setage( 22 ); \r\nalert( user.getage() == 22 ); \r\nМощность динамически генерируемого кода трудно переоценить. Возможность создавать код на основе \r\nсуществующих переменных  — исключительно полезное качество; именно оно делает столь мощными \r\nмакрокоманды в других языках программирования (таких как Lisp), не выходя за контекст современного языка \r\nпрограммирования. Далее мы рассмотрим тип метода, который полезен исключительно своими организационными \r\nпреимуществами. \r\n","\r\n 40\r\nСтатические методы \r\nЗамысел, положенный в основу статических методов практически не отличается от замысла, касающегося \r\nлюбой другой нормальной функции. Тем не менее основное отличие состоит в том, что они существуют как \r\nстатические свойства объекта. Будучи свойствами, они не доступны в контексте экземпляра этого объекта; доступ \r\nк ним открыт только в том же контексте, в котором существует и сам основной объект. Тем, кто знаком с \r\nтрадиционным наследованием, существующем в классах, это напоминает статические методы класса. \r\nФактически единственным преимуществом от создания кода подобным методом является поддержание \r\nчистоты пространства имен объекта, понятия, которое более подробно будет рассмотрено в главе 3. В \r\nлистинге 2.26 показан пример статического метода, присоединенного к объекту. \r\nЛистинг 2.26. Простой пример статического метода \r\n// Статический метод, присоединенный к объект User \r\nUser.cloneUser = function( user ) { \r\n    // Создание и возвращение нового пользователя (user) \r\n    return new User( \r\n       // это клон другого объекта user \r\n       user.getName(), \r\n       user.getAge() \r\n    ); \r\n}; \r\nСтатические методы являются первыми из тех, с которыми мы уже имели дело, чье назначение имеет \r\nчисто организационный характер. Это важная ступенька для перехода к теме, обсуждаемой в следующей главе. \r\nФундаментальным аспектом разработки кода JavaScript профессионального качества является его возможность \r\nбыстро и спокойно взаимодействовать с другими частями кода, оставаясь при этом ясным и доступным. Это \r\nважная цель, за достижение которой стоит побороться, и одна из тех целей, которую мы надеемся достичь в \r\nследующей главе. \r\nВыводы \r\nВажность усвоения понятий, затронутых в этой главе трудно переоценить. Первая половина главы, давая \r\nвам хорошее представление о том, как ведет себя язык JavaScript, и как он может быть использован наилучшим \r\nобразом, является отправной точкой для полного понимания профессионального подхода к использованию \r\nJavaScript. Простое представление о том, как действуют объекты, обрабатываются ссылки и определяется область \r\nвидимости бесспорно может изменить ваш подход к написанию кода на JavaScript. \r\nПо мере освоении навыков грамотного программирования на  JavaScript, становится все более очевидной \r\nважность создания качественного объектно-ориентированного   JavaScript-кода. Во второй половине этой главы \r\nмною были охвачены вопросы написания различного объектно-ориентированного кода, которые должны были \r\nустроить всех, кто пришел из других языков программирования. Это то самое искусство, на котором основана \r\nбольшая часть современного языка JavaScript, дающее вам существенное преимущество при разработке новых и \r\nтехнически прогрессивных приложений. \r\n","\r\n 41\r\nГлава 3 Создание кода широкого применения \r\nРазработка кода в сотрудничестве с другими программистами является стандартом для многих \r\nкорпоративных и командных проектов, и здесь особую важность приобретает хорошая система разработки, \r\nспособствующая совершению заранее продуманных действий. В связи с тем, что в последние годы JavaScript \r\nполучил широкое признание, объем программного кода, разработанного профессиональными программистами, \r\nсущественно возрос. Эти подвижки в восприятии и использовании JavaScript привели к существенному прогрессу \r\nв сопутствующей практике разработки.  \r\nВ данной главе мы собираемся рассмотреть ряд способов улучшения кода, совершенствования его \r\nорганизации и повышения качества, которые определяют его пригодность для использования другими \r\nпрограммистами.  \r\nСтандартизация объектно-ориентированного кода \r\nПервым и наиболее важным шагом в создании кода широкого применения станет стандартизация способов \r\nего написания в рамках всего приложения, что особенно важно для  объектно-ориентированного кода. \r\nРассматривая в предыдущей главе поведение объектно-ориентированного кода JavaScript, мы убедились в его \r\nособой гибкости, позволяющей придерживаться нескольких различных стилей программирования.  \r\nДля начала важно продумать наиболее отвечающую вашим потребностям систему написания объектно-\r\nориентированного кода и осуществления объектного наследования (клонирования свойств объекта в новые \r\nобъекты). Наверное у всех, кто когда-либо создавал какой-нибудь объектно-ориентированный код на JavaScript, \r\nвыработался свой собственный подход к этой работе, в котором может быть немало неразберихи. В этом разделе \r\nмы собираемся рассмотреть, как в JavaScript  работает наследование, после чего рассмотрим, как работают \r\nразличные альтернативные вспомогательные методы, и как можно будет ими воспользоваться в вашем \r\nприложении.  \r\nНаследование с использованием прототипов \r\nВ JavaScript используется уникальная форма создания объектов и наследования, которая называется \r\n прототипным наследованием. Суть этого метода (в отличие от классической схемы класс-объект, знакомой \r\nбольшинству программистов) состоит в том, что конструктор объекта может наследовать методы от другого \r\nобъекта, создавая прототип объекта — prototype, на основе которого строятся все остальные новые объекты. \r\nВесь этот процесс облегчается наличием свойства prototype (Это свойство есть у любой функции, а раз \r\nконструктором может стать любая функция, то это свойство есть и у конструктора). Прототипное наследование \r\nсконструировано для одиночного,  а не для множественного наследования, тем не менее существуют способы \r\nобхода этого ограничения, которые мы рассмотрим в следующем разделе. \r\nЭта форма наследования особенно сложна для понимания в той части, что прототипы не наследуют \r\nсвойства от других прототипов или других конструкторов; они наследуют их от физических объектов. В \r\nлистинге 3.1. показан ряд примеров конкретного применения свойства prototype для осуществления простого \r\nнаследования.  \r\nЛистинг 3.1. Примеры прототипного наследования \r\n// Создание конструктора для объекта Person \r\nfunction Person( name ) { \r\n    this.name = name; \r\n} \r\n  \r\n","\r\n 42\r\n// Добавление нового метода к объекту Person \r\nPerson.prototype.getName = function() { \r\n    return this.name; \r\n}; \r\n  \r\n// Создание нового конструктора объекта User \r\nfunction User( name, password ) { \r\n    // Учтите, что здесь не поддерживается постепенная \r\n    // перегрузка-наследование, например возможность вызова \r\n    // конструктора суперкласса \r\n    this.name = name; \r\n    this.password = password; \r\n}; \r\n  \r\n// Объект User наследует все методы объекта Person \r\nUser.prototype = new Person(); \r\n  \r\n// Для объекта User мы добавляет свой собственный метод \r\nUser.prototype.getPassword = function() { \r\n    return this.password; \r\n};  \r\nВ предыдущем примере наиболее важной для нас является строка User.prototype = new Person( );. Давайте \r\nразберемся в ее назначении более детально. User — это ссылка на функцию конструктора объекта User. При \r\nпомощи выражения new Person( ) создается новый объект Person, использующий конструктор Person. Результат \r\nего работы присваивается в качестве значения свойству prototype конструктора User. Это означает, что при \r\nкаждом использовании выражения new User( ), новый объект User будет обладать всеми методами, которые были \r\nу объекта Person, на тот момент, когда вы использовали выражение  new Person( ). \r\nПомня об особенностях этой технологии, рассмотрим ряд различных надстроек, которые были написаны \r\nпрограммистами для упрощения процесса наследования в JavaScript.  \r\nКлассическое наследование \r\nКлассическое наследование представляет собой форму, знакомую большинству разработчиков. У вас есть \r\nклассы с методами, на основе которых могут быть созданы экземпляры объектов. Новичкам объектно-\r\nориентированного программирования на JavaScript свойственно предпринимать попытки подражания этому стилю \r\nпрограммного конструирования, хотя немногим удается понять, как это сделать  правильно. \r\nК счастью, один из мастеров программирования на JavaScript, Дуглас Крокфорд (Douglas Crockford), \r\nзадался целью разработать простой набор методов, которые можно было бы использовать в JavaScript для \r\nимитации такого  же наследования, как и при использовании классов, о чем он рассказал на своем веб-сайте \r\nhttp://javascript.crockford.com/ inheritance.html.  \r\nВ листинге 3.2 показаны три функции, которые он построил для создания полноценной формы \r\nклассического наследования в JavaScript. Каждая из функций претворяет в жизнь особый аспект наследования: \r\nнаследование отдельной функции, наследование всех компонентов отдельного родительского объекта, и \r\nнаследование индивидуальных методов от нескольких родителей.  \r\nЛистинг 3.2. Три функции, созданные Дугласом Крокфордом для имитации в JavaScript классического \r\nстиля наследования  \r\n","\r\n 43\r\n  \r\n// Простой вспомогательный метод, позволяющий привязать новую функцию к \r\n// прототипу объекта \r\nFunction.prototype.method = function(name, func) { \r\n    this.prototype[name] = func; \r\n    return this; \r\n}; \r\n  \r\n// Довольно сложная функция, позволяющая весьма изящно наследовать \r\n// функции из других объектов, и сохранять возможность вызова функции \r\n// 'родительского' объекта \r\nFunction.method('inherits', function(parent) { \r\n    // Отслеживание, на каком уровне углубления в родительские функции мы \r\n    // находимся \r\n    var depth = 0; \r\n  \r\n    // Наследование родительских методов \r\n    var proto = this.prototype = new parent(); \r\n  \r\n    // Создание новой 'привилегированной' функции под названием 'uber', \r\n    // которая при вызове выполняет любую функцию, вписанную \r\n    // в наследование  \r\n    this.method('uber', function uber(name) { \r\n       \r\n       var func; // исполняемая функция \r\n       var ret;  // возвращение значения функции \r\n       var v = parent.prototype; // родительский прототип \r\n  \r\n       // Если мы уже находимся внутри другой функции 'uber' \r\n       if (depth) { \r\n           // спуск на необходимую глубину для поиска исходного прототипа \r\n           for(var i=d; i > 0;i+= 1 ) { \r\n               v = v.constructor.prototype; \r\n           } \r\n       \r\n           // и получение функции из прототипа \r\n           func = v[name]; \r\n  \r\n           // А если это первый вызов 'uber' \r\n           } else { \r\n               // получение выполняемой функции из прототипа \r\n               func = proto[name]; \r\n  \r\n               // Если функция была частью этого прототипа \r\n               if ( func == this[name] ) { \r\n                  // переход вместо этого к родительскому прототипу \r\n","\r\n 44\r\n                  func = v[name]; \r\n               } \r\n           } \r\n  \r\n           // Отслеживание той глубины, на которой мы находимся в стеке \r\n           // наследования \r\n           depth += 1; \r\n  \r\n       // Вызов выполняемой функции со всеми аргументами, кроме первого \r\n       // (в котором хранится имя исполняемой функции) \r\n       ret = func.apply(this, Array.prototype.slice.apply(arguments, \r\n            [1])); \r\n  \r\n           // Сброс глубины стека \r\n           depth -= 1; \r\n  \r\n           // Возвращение значения, возвращаемого выполняемой функцией \r\n           return ret; \r\n       }); \r\n       return this; \r\n    }); \r\n  \r\n// Функция для наследования только двух функций из родительского \r\n// объекта, но не каждой функции, использующей new parent() \r\n    Function.method('swiss', function(parent) { \r\n       // Перебор всех наследуемых методов \r\n       for (var i = 1; i < arguments.length; i += 1) { \r\n           // Имя импортируемого метода \r\n           var name = arguments[i]; \r\n  \r\n           // Импорт метода в прототип этого объекта \r\n           this.prototype[name] = parent.prototype[name]; \r\n       } \r\n  \r\n       return this; \r\n});  \r\nПосмотрим, что именно нам дают эти три функции, и почему мы должны их использовать вместо того, \r\nчтобы попытаться создать свою собственную модель прототипного наследования. Замысел их разработки \r\nдовольно прост:  \r\nFunction.prototype.method: Служит простым способом присоединения к прототипу конструктора. Это \r\nзамкнутое выражение работает благодаря тому, что все конструкторы являются функциями, и получают таким \r\nобразом новый метод method.  \r\nFunction.prototype.inherits: Эта функция может быть использована для обеспечения простого наследования \r\nот одного родителя. Код этой функции концентрируется вокруг  возможности вызова  this.uber('methodName') в \r\nлюбом из ваших методов объекта, и предоставлении ему возможности выполнения перезаписываемого им метода \r\nродительского объекта. Это один из подходов, не встроенных в модель наследования JavaScript.  \r\n","\r\n 45\r\nFunction.prototype.swiss: Это усовершенствованная версия функции .method( ), которая может быть \r\nиспользована для захвата нескольких методов из одного родительского объекта. Если ее использовать вместе с \r\nнесколькими родительскими объектами, вы можете получить разновидность функционального, множественного \r\nнаследования.  \r\nТеперь, когда у вас есть представление о том, что нам дают эти функции,  листинг 3.3 возвращает нас к \r\nпримеру Person-User, который был рассмотрен в листинге 3.1, но теперь уже с новой, классической \r\nразновидностью наследования. Вдобавок к этому вы можете увидеть, какие дополнительные функциональные \r\nвозможности дает эта библиотека, а также несколько прояснить ситуацию.  \r\nЛистинг 3.3. Примеры использования JavaScript-функций классической разновидности наследования, \r\nразработанных Дугласом Крокфордом  \r\n  \r\n// Создание нового конструктора объекта Person \r\nfunction Person( name ) { \r\n    this.name = name; \r\n} \r\n  \r\n// Добавление нового метода к объекту Person \r\nPerson.method( 'getName', function(){ \r\n    return name; \r\n}); \r\n  \r\n// Создание нового конструктора объекта User \r\nfunction User( name, password ) { \r\n    this.name = name; \r\n    this.password = password; \r\n}, \r\n  \r\n// Наследование всех методов объекта Person \r\nUser.inherits( Person ); \r\n  \r\n// Добавление нового метода к объекту User \r\nUser.method( 'getPassword', function(){ \r\n    return this.password; \r\n}); \r\n  \r\n// перезапись метода, созданного объектом Person, \r\n// но еще один вызов этого метода с использованием функции uber \r\nUser.method( 'getName', function(){ \r\n    return \"Мое имя: \" + this.uber('getName'); \r\n});  \r\nТеперь, когда у вас начал проявляться вкус к тем возможностям, которые предоставляются надежной, \r\nулучшающей свойства  наследования  библиотекой JavaScript, нужно рассмотреть некоторые другие, довольно \r\nраспространенные и популярные методы. \r\nБиблиотека Base \r\n","\r\n 46\r\nНедавним вкладом в области создания объектов и наследования в JavaScript, стала библиотека Base, \r\nразработанная Дином Эдвардсом (Dean Edwards). В этой библиотеке предлагается ряд различных способов \r\nрасширения функциональных возможностей объектов. Дополнительно в ней предлагаются интуитивно понятные \r\nсредства объектного наследования. Первоначально Дин разрабатывал Base для использования в некоторых своих \r\nпобочных проектах, включая проект IE7, который служил в качестве полноценного набора обновлений к Internet \r\nExplorer. На веб-сайте Дина (http://dean.edwards.name/weblog/2006/03/base/) приведены весьма разнообразные \r\nпримеры, достаточно хорошо раскрывающие возможности библиотеки. В дополнение к ним можно найти ряд \r\nпримеров в каталоге исходного кода Base: http://dean.edwards.name/base/. \r\nПоскольку Base довольно объемная и сложная библиотека, она заслуживает дополнительных разъяснений \r\n(которые включены в код, предоставленный в разделе Source Code/Download на веб-сайте Apress — \r\nhttp://www.apress.com). Я настоятельно рекомендуется в дополнение к чтению этого закомментированного кода \r\nпросматривать примеры, предоставленные Дином на его веб-сайте, поскольку они могут оказаться исключительно \r\nполезными для разъяснения наиболее запутанных моментов. \r\nНо для начала я собираюсь разобраться с несколькими важными аспектами Base, которые могут оказаться \r\nочень полезными для ваших разработок. В частности, в листинге 3.4 представлены примеры создания класса, а \r\nтакже наследования от одного родителя,  и замещения родительской функции.  \r\nЛистинг 3.4. Примеры использования библиотеки Base  Дина Эдвардса для создания простого класса и \r\nорганизации наследования  \r\n  \r\n// Создание нового класса Person \r\nvar Person = Base.extend({ \r\n    // Конструктор класса Person \r\n    constructor: function( name ) { \r\n       this.name = name; \r\n    }, \r\n  \r\n    // простой метод класса Person \r\n    getName: function() { \r\n       return this.name; \r\n    } \r\n});  \r\n  \r\n// Создание нового класса User, являющегося наследником класса Person \r\nvar User = Person.extend({ \r\n    // Создание конструктора класса User \r\n    constructor: function( name, password ) { \r\n       // который, в свою очередь, вызывает метод конструктора \r\n       // родительского класса \r\n       this.base( name ); \r\n       this.password = password; \r\n    }, \r\n  \r\n    // Создание еще одного простого метода для User \r\n    getPassword: function() { \r\n       return this.password; \r\n","\r\n 47\r\n    } \r\n});  \r\nПосмотрим, как Base удается достичь трех целей, обозначенных в листинге 3.4, и создать простую форму \r\nсоздания объекта и организации наследования:  \r\nBase.extend( ...; );: Это выражение используется для создания нового базового объекта конструктора. \r\nФункция берет одно свойство — простой объект, содержащий свойства и значения, которые добавлены к объекту \r\nи использованы в качестве его прототипных методов. \r\nPerson.extend( ...; );: Это альтернативная версия синтаксиса Base.extend( ). Все конструкторы, созданные с \r\nпомощью метода .extend( ), получают свой собственный метод .extend( ), а значит,  и возможность \r\nнепосредственного наследования от них. В листинге 3.4. конструктор User создается за счет непосредственного \r\nнаследования от исходного конструктора Person.  \r\nthis.base();: И, наконец, метод this.base( ) используется для вызова родительской функции, которая была \r\nзаменена. Заметьте, что это несколько отличается от функции this.uber( ), используемой в классической \r\nбиблиотеке Крокфорда, поскольку вам не нужно предоставлять имя родительской функции (что может помочь в \r\nнаведении порядка и  разъяснении кода). Среди всех объектно-ориентированных библиотек JavaScript, Base \r\nобладает наилучшими функциональными возможностями по замене родительских методов.  \r\nЛично я считаю, что разработанная Дином библиотека Base создает наиболее читаемый, функциональный \r\nи понятный объектно-ориентированный код JavaScript. В конечном счете выбор наиболее подходящей библиотеки \r\nостается за разработчиком. Далее мы рассмотрим, как объектно-ориентированный код реализован в популярной \r\nбиблиотеке Prototype.  \r\nБиблиотека Prototype \r\nPrototype — это библиотека JavaScript, которая была разработана для работы в связке с популярной веб-\r\nсредой Ruby on Rails. Ее название не стоит путать со свойством конструктора  prototype — это всего лишь нелепое \r\nсовпадение.  \r\nЕсли не брать в расчет название, Prototype делает JavaScript по внешнему виду и поведению во многом \r\nпохожим на язык Ruby. Чтобы добиться этого эффекта, разработчики Prototype воспользовались объектно-\r\nориентированной природой JavaScript, и присоединили к ядру объектов JavaScript ряд функций и свойств. К \r\nсожалению, сама библиотека своим создателем вообще не документировалась, но, к счастью, она написана очень \r\nпонятно, и многие ее пользователи приступили к созданию собственных версий документации. Весь основной код \r\nPrototype можно совершенно свободно просмотреть на веб-сайте http://prototype.conio.net/. А в статье «Painless \r\nJavaScript Using Prototype» по адресу http://www.sitepoint.com/article/painless-javascript-prototype/ можно найти \r\nдокументацию по этой библиотеке. \r\nВ этом разделе мы собираемся рассмотреть лишь специфические функции и объекты, которые \r\nиспользуются в Prototype для создания ее объектно-ориентированной структуры и обеспечения основ \r\nнаследования. В листинге 3.5 представлен весь код, который Prototype использует для достижения этой цели.  \r\nЛистинг 3.5. Две функции, используемые Prototype для воспроизводства объектно-ориентированного кода \r\nJavaScript \r\n  \r\n// Создание глобального объекта по имени 'Class', \r\nvar Class = { \r\n","\r\n 48\r\n    // который обладает единственной функцией, создающей новый объект \r\n    // конструктора \r\n    create: function() { \r\n  \r\n       // Создание безымянного объекта конструктора \r\n       return function() { \r\n           // This вызывает свой собственный метод инициализации \r\n           this.initialize.apply(this, arguments); \r\n       } \r\n    } \r\n} \r\n  \r\n// Добавление статического метода к объекту Object, который копирует \r\n// свойства из одного объекта в другой \r\nObject.extend = function(destination, source) { \r\n    // проход через все свойства для их извлечения \r\n    for (property in source) { \r\n       // и добавления к объекту назначения \r\n       destination[property] = source[property]; \r\n    } \r\n  \r\n    // возвращение модифицированного объекта \r\n    return destination; \r\n}  \r\nPrototype действительно использует всего лишь две определенные функции для создания и управления \r\nвсей объектно-ориентированной структурой. Изучая код, вы можете обратить внимание на то, что этот подход \r\nявно слабее, чем в Base или в классическом  методе Крокфорда. В основу этих двух функций положен весьма \r\nпростой замысел:  \r\nClass.create(): Эта функция просто возвращает надстройку в виде безымянной функции, которая может \r\nбыть использована в качестве конструктора. Этот простейший конструктор всего лишь вызывает и выполняет \r\nсвойство инициализации объекта. Стало быть, должно, по крайней мере, существовать свойство initialize, \r\nсодержащее функцию вашего объекта; в противном случае код выдаст исключение. \r\nObject.extend(): Эта функция просто копирует все свойства из одного объекта в другой. При \r\nиспользовании имеющегося в конструкторах свойства prototype, можно разработать более простую форму \r\nнаследования (проще, чем исходная форма прототипного наследования, доступная в JavaScript).  \r\nТеперь, когда вы узнали, как работает код, положенный в основу Prototype, в листинге 3.6 показываются \r\nнесколько примеров его использования в самой библиотеке Prototype с целью расширения «родных» объектов \r\nJavaScript и придания им нового уровня функциональности.  \r\nЛистинг 3.6. Примеры использования в Prototype объектно-ориентированных функций  для расширения \r\nисходных возможностей по обработке строк в JavaScript \r\n  \r\n// Добавление к прототипу String дополнительных методов \r\nObject.extend(String.prototype, { \r\n    // Новая функция удаления из строки тегов HTML \r\n","\r\n 49\r\n    stripTags: function() { \r\n       return this.replace(/<\\/?[^>]+>/gi, ''); \r\n    }, \r\n  \r\n    // Превращение строки в массив символов \r\n    toArray: function() { \r\n       return this.split(''); \r\n    }, \r\n  \r\n    // Превращение текста вида \"foo-bar\" в 'горбатый' вариант — \"fooBar\"     \r\n    camelize: function() { \r\n       // Разбиение строки по дефисам \r\n        var oStringList = this.split('-'); \r\n  \r\n       // Досрочный возврат, если дефисы отсутствуют \r\n       if (oStringList.length == 1) \r\n           return oStringList[0]; \r\n  \r\n       // Дополнительная обработка начала строки \r\n       var camelizedString = this.indexOf('-') == 0 \r\n           ? oStringList[0].charAt(0).toUpperCase() + \r\n             oStringList[0].substring(1) : oStringList[0]; \r\n  \r\n       // Превращение первых букв каждой последовательной части в заглавные \r\n       for (var i = 1, len = oStringList.length; i < len; i++) { \r\n           var s = oStringList[i]; \r\n           camelizedString += s.charAt(0).toUpperCase() + s.substring(1); \r\n       }  \r\n  \r\n       // и возврат модифицированной строки \r\n       return camelizedString; \r\n    } \r\n}); \r\n// Пример использования метода stripTags(). \r\n// Можете убедиться, что он удаляет из строки весь HTML, \r\n// и оставляет нам строку, состоящую только из одного текста \r\n\"<b><i>Hello</i>, world!\".stripTags() == \"Hello, world!\" \r\n  \r\n// Пример использования метода toArray(). \r\n// Мы извлекаем из строки четвертый символ \r\n\"abcdefg\".toArray()[3] == \"d\" \r\n  \r\n// Пример использования метода camelize(). \r\n// Он переделывает старую строку в новый формат. \r\n\"background-color\".camelize() == \"backgroundColor\"  \r\n  \r\n","\r\n 50\r\nТеперь вернемся к примеру, который уже использовался в этой главе, где фигурировали объекты Person и \r\nUser, и объект User являлся наследником объекта Person. Этот код, использующий объектно-ориентированный \r\nстиль Prototype, показан в листинге 3.7.  \r\nListing 3-7. Вспомогательные функции Prototype, предназначенные для создания классов и осуществления \r\nпростого наследования  \r\n// Создание нового объекта Person с использованием пустого конструктора \r\nvar Person = Class.create(); \r\n  \r\n// Копирование ряда функций в прототип Person \r\nObject.extend( Person.prototype, { \r\n  \r\n    // Функция, немедленно вызываемая конструктором Person \r\n    initialize: function( name ) { \r\n       this.name = name; \r\n    }, \r\n  \r\n    // Простая функция для объекта Person \r\n    getName: function() { \r\n       return this.name; \r\n    } \r\n}); \r\n  \r\n// Создание нового объекта User с использованием пустого конструктора \r\nvar User = Class.create();  \r\n// Объект User наследует все функции своего родительского класса \r\nUser.prototype = Object.extend( new Person(), { \r\n  \r\n    // Переписывание старой функции initialize заново \r\n    initialize: function( name, password ) { \r\n       this.name = name; \r\n       this.password = password; \r\n    }, \r\n  \r\n    // добавление новой функции к объекту \r\n    getPassword: function() { \r\n       return this.password; \r\n    } \r\n});  \r\nХотя предлагаемые библиотекой Prototype объектно-ориентированные технические приемы не являются \r\nреволюционными, они достаточно сильны, чтобы помочь разработчику в создании простого и легко читаемого \r\nкода. В конце концов, если вам приходится создавать довольно большой объем объектно-ориентированного кода, \r\nто вы, для облегчения задачи, скорее всего, остановите свой выбор на библиотеке Base.  \r\nДалее мы собираемся рассмотреть приемы подготовки своего объектно-ориентированного кода для \r\nширокого использования с кодом других разработчиков и библиотек.  \r\nСоздание пакета \r\n","\r\n 51\r\nПосле завершения работы над вашим великолепным объектно-ориентированным кодом на JavaScript (или \r\nво время его написания, если у вас хватает на это мудрости), настает время для доведения его до определенной \r\nстепени совершенства, позволяющей ему безупречно работать с другими библиотеками JavaScript. К тому же \r\nважно понять, что ваш код должен будет использоваться другими разработчиками и пользователями, требования \r\nкоторых могут отличаться от ваших. Возможно, эта задача решается путем написания самого совершенного кода, \r\nно ее выполнению может поспособствовать и изучение того, что уже сделано другими.  \r\nВ этом разделе мы рассмотрим несколько больших библиотек, используемых ежедневно тысячами \r\nразработчиков. Каждая из этих библиотек предоставляет уникальные способы управления своей структурой, \r\nкоторые облегчают ее использование и изучение. В дополнение к этому мы рассмотрим несколько способов, \r\nкоторыми можно воспользоваться для очистки своего кода, чтобы у других разработчиков могло сложиться о нем \r\nсамое благоприятное впечатление.  \r\nОрганизация пространства имен \r\nДовольно важный и в то же время простой технический прием, который можно применить для очистки и \r\nупрощения кода, связан с понятием пространства имен. На данный момент JavaScript по умолчанию не \r\nподдерживает пространства имен (в отличие, к примеру, от Java или Python), поэтому нам приходится обходиться \r\nсоответствующей, тем не менее, похожей техникой.  \r\nВ действительности в JavaScript нет ничего, что могло бы употребляться в качестве пространства имен. \r\nТем не менее, воспользовавшись упомянутым выше положением, что в JavaScript все объекты могут иметь \r\nсвойства, которые в свою очередь могут содержать другие объекты, вы можете создать что-нибудь такое, что \r\nвыглядит и работает практически так же, как и пространство имен, используемое в других языках \r\nпрограммирования. Используя эту технологию, можно создать уникальные структуры, подобные тем, что показаны \r\nв листинге 3.8.  \r\nЛистинг 3.8. Организация пространства имен а JavaScript и его применение  \r\n  \r\n// Создание используемого по умолчанию глобального пространства имен \r\nvar YAHOO = {}; \r\n  \r\n// Установка некоторых дочерних пространств имен с помощью объектов \r\nYAHOO.util = {}; \r\n  \r\n// Создание заключительного пространства имен, которое содержит свойство с \r\n// функцией \r\nYAHOO.util.Event = { \r\n    addEventListener: function(){ ...; } \r\n}; \r\n  \r\n// Вызов функции внутри конкретно этого пространства имен \r\nYAHOO.util.Event.addEventListener( ...; ) \r\n  \r\nРассмотрим несколько примеров организации пространства имен в ряде различных популярных библиотек, \r\nи то, как они вписываются в цельную, расширяемую и дополняемую архитектуру.  \r\nDojo \r\n","\r\n 52\r\nDojo — это чрезвычайно популярная среда, удовлетворяющая всем потребностям разработчиков в \r\nсоздании полноценных веб-приложений. Это означает, что в ней содержится масса подчиненных библиотек, \r\nкоторые нуждаются в индивидуальном включении и оценке, поскольку вся библиотека слишком велика, и с ней \r\nне так-то легко справиться. Дополнительная информация о Dojo может быть найдена на веб-сайте проекта: \r\nhttp://dojotoolkit.org/.  \r\nВ Dojo имеется целая система создания пакетов, построенная вокруг организации пространства имен в \r\nJavaScript. Вы можете импортировать новые пакеты в динамическом режиме, при котором они будут \r\nавтоматически выполнены и готовы к использованию. В листинге 3.9 показан пример организации пространства \r\nимен, используемой в Dojo.  \r\nЛистинг 3.9. Создание пакетов и организация пространства имен в Dojo \r\n  \r\n<html> \r\n<head> \r\n    <title>Accordion Widget Demo</title> \r\n    <!-- Включение Dojo Framework --> \r\n    <script type=\"text/javascript\" src=\"dojo.js\"></script> \r\n    <!-- Включение различных пакетов Dojo --> \r\n    <script type=\"text/javascript\"> \r\n       // Для создания Accordion Container widget импортируются и \r\n       // используются два различных пакета \r\n       dojo.require(\"dojo.widget.AccordionContainer\"); \r\n       dojo.require(\"dojo.widget.ContentPane\"); \r\n    </script> \r\n</head> \r\n<body> \r\n<div dojoType=\"AccordionContainer\" labelNodeClass=\"label\"> \r\n    <div dojoType=\"ContentPane\" open=\"true\" label=\"Pane 1\"> \r\n       <h2>Pane 1</h2> \r\n       <p>Nunc consequat nisi vitae quam. Suspendisse sed nunc. Proin...;</p> \r\n    </div> \r\n    <div dojoType=\"ContentPane\" label=\"Pane 2\"> \r\n       <h2>Pane 2</h2> \r\n       <p>Nunc consequat nisi vitae quam. Suspendisse sed nunc. Proin...;</p> \r\n    </div> \r\n    <div dojoType=\"ContentPane\" label=\"Pane 3\"> \r\n       <h2>Pane 3</h2> \r\n       <p>Nunc consequat nisi vitae quam. Suspendisse sed nunc. Proin...;</p> \r\n    </div> \r\n</div> \r\n</body> \r\n</html>  \r\nЕсли вас интересуют вопросы поддержки больших базовых блоков программного кода на JavaScript, то \r\nочень мощная пакетная архитектура Dojo безусловно заслуживает внимания. Дополнительно замечу, что очень \r\nбольшой объем библиотеки заставит вас выискивать в ней те функциональные возможности, которые смогут \r\nоказаться полезными.  \r\n","\r\n 53\r\nYUI \r\nЕсть еще одна библиотека, обслуживающая архитектуру больших пакетов с организованным \r\nпространством имен — JavaScript Yahoo UI (http://developer.yahoo.com/yui/). Эта библиотека разработана для \r\nосуществления и обеспечения решений ряда широко распространенных выразительных средств веб-приложений \r\n(таких как перетаскивание элементов). Все эти UI-элементы разбиты на части и распространяются в соответствии \r\nс определенной иерархией. Для библиотеки  Yahoo UI разработана хорошая документация, которая заслуживает \r\nвнимания своей полнотой и детализацией. \r\nДля организации функций и свойств в Yahoo UI используется глубокая иерархия пространства имен, во \r\nмногом похожая на ту, что используется в Dojo. Но в отличие от Dojo, любое «импортирование» внешнего кода  \r\nосуществляется только вами, а не оператором импортирования. В листинге 3.10 показан пример внешнего вида и \r\nработы пространства имен в библиотеке Yahoo UI.  \r\nЛистинг 3.10. Создание пакетов и организация пространства имен в библиотеке  Yahoo UI \r\n  \r\n<html> \r\n<head> \r\n    <title>Yahoo! UI Demo</title> \r\n    <!-- Импорт основной библиотеки Yahoo UI --> \r\n    <script type=\"text/javascript\" src=\"YAHOO.js\"></script> \r\n  \r\n    <!-- Импорт пакета обработки событий --> \r\n    <script type=\"text/javascript\" src=\"event.js\"></script> \r\n  \r\n    <!-- Использование импортированной библиотеки Yahoo UI --> \r\n    <script type=\"text/javascript\"> \r\n       // Все обработчики событий и утилиты Yahoo содержатся в \r\n       // пространстве имен YAHOO, и дополнительно разбиты на более мелкие \r\n       // пространства имен (подобные 'util') \r\n       YAHOO.util.Event.addListener( 'button', 'click', function() { \r\n           alert( \"Спасибо, что щелкнули на кнопке!\" ); \r\n       }); \r\n    </script> \r\n</head> \r\n  \r\n<body> \r\n    <input type=\"button\" id=\"button\" value=\"Щелкните!\"/> \r\n</body> \r\n</html>  \r\nОбе библиотеки, и Dojo, и Yahoo UI, очень хорошо справляются с организацией и обслуживанием \r\nзначительных объемов кода в пределах одного большого пакета. Понимание того, как они это делают, сможет \r\nпринести вам неоценимую помощь, когда наступит время самим обеспечивать работу архитектуры пакета.  \r\nОчистка программного кода \r\nПеред тем как перейти к теме отладки или создания тестовых примеров (что я собираюсь сделать в \r\nследующей главе) сначала нужно рассмотреть как создается код, готовый к использованию другими \r\n","\r\n 54\r\nразработчиками. Если вы хотите, чтобы ваш код продолжил свое существование, и был востребован и \r\nмодифицирован другими разработчиками, нужно настроиться работу по избавлению кода от таких операторов, \r\nкоторые могли бы быть неправильно истолкованы или использованы. Конечно, можно пройтись по коду и \r\nочистить его вручную, но лучше все же воспользоваться инструментом, который поможет заметить ненадежные, \r\nпотенциально проблемные  участки кода. Именно здесь нам может пригодиться JSLint —  набор встроенных \r\nправил,  определяющих участки кода, способные в будущем вызвать проблемы у вас или у других разработчиков. \r\nПолноценный анализатор доступен на веб-сайте JSLint по адресу: http://www.jslint.com/. Дополнительно все \r\nправила и установки JSLint могут быть найдены по адресу: http://www.jslint.com/lint.html.  \r\nJSLint — это еще один инструмент, разработанный Дугласом Крокфордом (Douglas Crockford) в \r\nсвойственной ему манере, поэтому если вас что-то не устраивает или не вызывает доверия, то такие положения \r\nможно просто проигнорировать. Тем не менее, некоторые из этих правил целиком отвечают здравому смыслу, \r\nпоэтому я собираюсь разобраться в них поподробнее.  \r\nОбъявление переменных \r\nОдно из разумных правил, введенных в JSLint гласит о том, что все переменные, используемые в \r\nпрограмме, должны быть объявлены перед их использованием. Хотя в JavaScript явные требования по объявлению \r\nпеременных отсутствуют, но игнорирование этого правила может вызвать путаницу, касающуюся их фактических \r\n областей видимости. Например, если нужно присвоить значение необъявленной переменной внутри функции, то \r\nкак следует рассматривать ее область видимости,  внутри функции или глобально? Без просмотра кода тут не \r\nобойтись, и этот вопрос неплохо бы прояснить. Пример установленного в JSLint порядка объявления переменных \r\nпоказан в листинге 3.11.  \r\nЛистинг 3.11. Требования JSLint к объявлению переменных  \r\n  \r\n// Неправильное использование переменной \r\nfoo = 'bar'; \r\n  \r\n// Правильное использование переменной \r\nvar foo; \r\n...; \r\nfoo = 'bar'; \r\n  \r\nОператоры != и == против операторов !== и === \r\nСуществует одна типичная ошибка, допускаемая разработчиками из-за недостаточного понимания \r\nзначений false, используемых в JavaScript. В этом языке null, 0, ‘’, false и undefined все идентичны (==) друг \r\nдругу, поскольку при их вычислении возникает значение false. Это означает, что если вы используете код test == \r\nfalse, то в результате его вычисления будет получено значение true, если переменная test так же имеет значение \r\nundefined или равна нулю, что может не совпадать с тем, что вам на самом деле нужно.  \r\nИ тут на выручку приходят операторы !== и ===.  Оба эти оператора рассматривают явное значение \r\nпеременной (к примеру, null), а не только результат ее вычисления (к примеру, false). JSLint требует, чтобы при \r\nработе с false-значениями вместо оператора != или оператора == использовался оператор !== или оператор \r\n===. В листинге 3.12 показан ряд примеров, показывающих, чем отличаются эти операторы друг от друга.  \r\nЛистинг 3.12. Примеры отличий != и == от !== и ===  \r\n","\r\n 55\r\n  \r\n// Оба результата имеют значение true \r\nnull == false \r\n0 == undefined \r\n  \r\n// Вместо этого в сравнении нужно использовать !== или === \r\nnull !== false \r\nfalse === false  \r\nБлоки и скобки \r\nЭто правило я воспринимаю с трудом, тем не менее, если вы работаете в общедоступной среде \r\nпрограммирования, то есть смысл его придерживаться. Оно гласит, что от использования однострочных блоков \r\nследует отказаться. Когда есть условие (к примеру, if (dog == cat )), внутри которого только один оператор (dog \r\n= false;) то скобки, которые обычно требуются для оформления этого условия, можно опустить. То же самое \r\nсправедливо и для блоков while( ) и for( ). Хотя это сокращение, предоставляемое JavaScript, можно только \r\nприветствовать, игнорирование скобок в программном коде может вызвать ряд непонятных последствий для тех, \r\nкто не понимает, какой код находится внутри блока, а какой — за его пределами. Эта ситуация достаточно \r\nпонятно раскрывается в листинге 3.13.  \r\nЛистинг 3.13. Неправильно оформленные блоки кода, содержащие один оператор \r\n  \r\n// Это вполне допустимый, нормальный код Javascript \r\nif ( dog == cat ) \r\nif ( cat == mouse ) \r\nmouse = \"cheese\"; \r\n  \r\n// JSLint требует, чтобы все это было оформлено следующим образом: \r\nif ( dog == cat ) { \r\n    if ( cat == mouse) { \r\n       mouse = \"cheese\"; \r\n    } \r\n} \r\nТочки с запятой \r\nПольза от этого последнего положения станет особенно очевидной при рассмотрении следующего раздела \r\nо сжатии кода. Точку с запятой в конце оператора, если он единственный в строке в JavaScript, ставить не \r\nобязательно. Если ваш код не сжат, то отсутствие точки с запятой выглядит вполне нормально, но как только \r\nсимволы конца строки будут удалены с целью сокращения размера файла, сразу же возникнут проблемы. Чтобы \r\nизбежать подобной ситуации, не следует забывать, что в конце всех операторов нужно ставить точку с запятой, \r\nкак показано в листинге 3.14.  \r\nЛистинг 3.14. Операторы, требующие наличия точек с запятой \r\n  \r\n// Если вы собираетесь сжимать код Javascript, то \r\n// обязательно ставьте точки с запятой в конце всех операторов \r\n","\r\n 56\r\n  \r\nvar foo = 'bar'; \r\nvar bar = function(){ \r\n    alert('hello'); \r\n}; \r\nbar();  \r\nВ конечном счете это последнее положение подводит нас к понятию сжатия кода JavaScript. Если \r\nиспользование JSLint для создания безупречного кода приносит пользу другим разработчикам и вам самим, то \r\nсжатие наиболее полезно для ваших пользователей, поскольку оно позволяет увеличить скорость работы с вашим \r\nвеб-сайтом.  \r\nСжатие \r\nНаиболее важным аспектом распространения библиотеки JavaScript является сжатие кода, позволяющее \r\nсократить время передачи информации по сети. Сжатие должно использоваться в качестве последнего шага, \r\nперед самым выпуском вашего кода в эксплуатацию, поскольку зачастую в результате этой операции \r\nраспознаваемость кода резко ухудшается. Существует три разновидности сжатия кода JavaScript:  \r\n• Сжатие, при котором из кода просто удаляются все пустые места и комментарии, после чего в коде \r\nостается только самое необходимое.  \r\n• Сжатие, при котором удаляются все пустые места и комментарии, а также сокращаются имена всех \r\nпеременных.  \r\n• Сжатие, при котором делается все, ранее перечисленное, а также сокращается до минимума длина всех \r\nслов вашего кода, а не только имен переменных.  \r\nЯ собираюсь рассмотреть две различные библиотеки: JSMin и Packer. JSMin подпадает под первую \r\nкатегорию сжатия (удаления всего, что не имеет отношения к коду), а Packer подпадает под третью категорию \r\n(полное сжатие всех слов).  \r\nJSMin \r\nИдея, заложенная в JSMin довольно проста. При обработке блока кода JavaScript из него удаляются все \r\nничего не значащие символы, и остается только чистый функциональный код. В JSMin это достигается простым \r\nудалением всех лишних пустых символов (включая знаки табуляции и коды конца строк) и всех комментариев. \r\nИнтернет-версия программы сжатия выложена по адресу: http://www.crockford.com/javascript/jsmin.html.  \r\nЧтобы понять, что происходит с кодом при его обработке JSMin, мы возьмем блок кода (показанный в \r\nлистинге 3.15), пропустим его через минимизатор, и посмотрим результат в листинге 3.16.  \r\nЛистинг 3.15. Код определения типа пользовательского браузера  \r\n  \r\n// (c) 2001 Douglas Crockford \r\n// 2001 June 3 \r\n// Объект -is- используется для идентификации браузера. Каждая версия \r\n// браузера способна  к самоидентификации, но стандартных способов \r\n// осуществления этой операции нет, и некоторые результаты идентификации \r\n// вводят вас в заблуждение. Причина в том, что создатели \r\n// веб-браузеров — неисправимые лжецы. К примеру, браузеры Microsoft \r\n// IE заявляют, что они — Mozilla 4. А Netscape 6 заявляет, что он — \r\n","\r\n 57\r\n// version 5. \r\n  \r\nvar is = { \r\n    ie:            navigator.appName == 'Microsoft Internet Explorer', \r\n    java:      navigator.javaEnabled(), \r\n    ns:            navigator.appName == 'Netscape', \r\n    ua:            navigator.userAgent.toLowerCase(), \r\n    version:   parseFloat(navigator.appVersion.substr(21)) || \r\n               parseFloat(navigator.appVersion), \r\n    win:       navigator.platform == 'Win32' \r\n} \r\nis.mac = is.ua.indexOf('mac') >= 0; \r\nif (is.ua.indexOf('opera') >= 0) { \r\n    is.ie = is.ns = false; \r\n    is.opera = true; \r\n} \r\nif (is.ua.indexOf('gecko') >= 0) { \r\n    is.ie = is.ns = false; \r\n    is.gecko = true; \r\n}  \r\nЛистинг 3.16. Сжатая копия кода листинга 3.15  \r\n  \r\n// Сжатый код \r\nvar is={ie:navigator.appName=='Microsoft Internet Explorer',java: \r\nnavigator.javaEnabled(),ns:navigator.appName=='Netscape',ua: \r\nnavigator.userAgent.toLowerCase(),version:parseFloat( \r\nnavigator.appVersion.substr(21))||parseFloat(navigator.appVersion),win: \r\nnavigator.platform=='Win32'} is.mac=is.ua.indexOf('mac')>=0;if( \r\nis.ua.indexOf('opera')>=0){is.ie=is.ns=false;is.opera=true;} \r\nif(is.ua.indexOf('gecko')>=0){is.ie=is.ns=false;is.gecko=true;}  \r\nЗаметьте, что все пробелы и комментарии были удалены, что привело к существенному сокращению \r\nобщего размера кода.  \r\nВероятно, JSMin является самой простой утилитой сжатия кода JavaScript. Она отлично подходит в \r\nначальной стадии использования сжатия для вводимого в эксплуатацию кода. Но когда настанет необходимость в \r\nдальнейшей экономии трафика, вам потребуется перейти на использование Packer, довольно сложной и мощной \r\nбиблиотеки сжатия JavaScript.   \r\nPacker \r\nPacker является самой мощной из всех доступных систем сжатия JavaScript. В этой системе, разработанной \r\nДином Эдвардсом (Dean Edwards), используется способ полного сокращения размера кода с его последующим \r\nразвертыванием и выполнением на лету. Благодаря этой технологии, Packer создает оптимально наименьший \r\nвозможный размер кода. Его можно рассматривать как самораспаковывающийся ZIP-файл для кода JavaScript. \r\nИнтернет-версия сценария Packer доступна по адресу: http://dean.edwards.name/packer/.  \r\nСценарий Packer слишком большой и сложный, поэтому пытаться создавать что-либо подобное своими \r\nсилами я бы не советовал. К тому же сгенерированный код содержит пару сотен служебных байтов (чтобы \r\n","\r\n 58\r\nобеспечить самораспаковку), поэтому для использования со слишком коротким кодом эта система не подходит \r\n(для этого лучше подойдет JSMin). Но для больших файлов она безусловно является идеальным вариантом. \r\nЛистинг 3.17 показывает выдержку из самораспаковывающегося кода, сгенерированного сценарием Packer.  \r\nЛистинг 3.17. Часть кода, сжатая с использованием Packer \r\n  \r\neval(function(p,a,c,k,e,d){e=function(c){return c.toString(36)};if(!''.replace(/^/, \r\nString)){while(c--){d[c.toString(a)]=k[c]||c.toString(a)}k=[(function(e){return \r\nd[e]})];e=(function(){return'\\\\w+'});c=1};while(c--){if(k[c]){p=p.replace(new \r\nRegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])}}return p}('u 1={5:2.f==\\'t s \r\nr\\',h:2.j(),4:2.f==\\'k\\',3:2.l.m(),n:7(2.d.o(p))||7(2.d),q:2.g==\\'i\\'}1. \r\nb=1.3.6(\\'b\\')>=0;a(1.3.6(\\'c\\')>=0){1.5=1.4=9;1.c=e}a(1.3.6(\\'8\\')>=0){1.5= \r\n1.4=9;1.8=e}',31,31,'|is|navigator|ua|ns|ie...;.  \r\nПользу от сжатия вашего кода, особенно если для этого используется сценарий Packer, трудно \r\nпереоценить. В зависимости от того, как написан код, зачастую удается уменьшить его размер более, чем на 50%, \r\nчто с точки зрения ваших пользователей отразится в лучшую сторону по времени загрузки,  а это должно быть \r\nодной из главный целей для любого приложения JavaScript.  \r\nРаспространение \r\nФинальный шаг JavaScript-разработки является необязательным и большей частью зависит от конкретной \r\nситуации. Если вы создаете код для себя или для компании, то, скорее всего, вы его просто распространите среди \r\nдругих разработчиков или выложите его для использования на своем веб-сайте.  \r\nНо если вы разработали интересный фрагмент кода и хотите, чтобы весь остальной мир распорядился им \r\nпо своему усмотрению, то вам понадобится служба наподобие JavaScript Archive Network (JSAN). Эта служба была \r\nоснована несколькими Perl-разработчиками, которым понравилось использовать функциональные возможности и \r\nпрактические преимущества архива CPAN (Comprehensive Perl Archive Network). Подробнее о JSAN можно узнать \r\nна веб-сайте http://openjsan.org/.  \r\nТребования JSAN заключаются в том, чтобы все передаваемые в архив модули были написаны в \r\nбезупречно отформатированном объектно-ориентированном стиле, соответствующим архитектуре конкретного \r\nмодуля. Кроме того, что JSAN является центральным хранилищем кода, в нем имеются средства, пользуясь \r\nкоторыми можно импортировать требования о взаимозависимости вашего кода и внешних модулей JSAN. Они \r\nмогут значительно упростить написание взаимосвязанных приложений, и избавиться от волнений на счет того, \r\nкакие модули уже были установлены пользователем. Чтобы понять, как работает типичный модуль JSAN, \r\nрассмотрим один из простых модулей, DOM.Insert, доступный по адресу: \r\nhttp://openjsan.org/doc/r/rk/rkinyon/DOM/Insert/0.02/lib/DOM/Insert.html.  \r\nЭтот модуль принимает строку HTML и вставляет ее в конкретное место веб-страницы. Кроме того, что он \r\nпрекрасно объектно-ориентирован, он также требует для своей работы и загружает два других модуля JSAN, оба \r\nиз которых показаны в листинге 3.18.  \r\nListing 3-18. Пример модуля JSAN (DOM.Insert) \r\n  \r\n// Мы пытаемся включить некоторые другие модули, используя JSAN \r\n  \r\ntry { \r\n","\r\n 59\r\n    // загрузка двух необходимых для работы библиотек JSAN \r\n    JSAN.use( 'Class' ) \r\n    JSAN.use( 'DOM.Utils' ) \r\n  \r\n// если загрузка JSAN не состоялась, будет вызвано исключение \r\n} catch (e) { \r\n    throw \"DOM.Insert requires JSAN to be loaded\"; \r\n} \r\n  \r\n// Проверка существования пространства имен DOM \r\nif ( typeof DOM == 'undefined' ) \r\n    DOM = {}; \r\n  \r\n// Создание нового конструктора DOM.Insert, являющегося наследником объекта \r\n// 'Object' \r\nDOM.Insert = Class.create( 'DOM.Insert', Object, { \r\n    // Конструктор, принимающий два аргумента \r\n    initialize: function(element, content) { \r\n       // Элемент, в который вставляется HTML \r\n       this.element = $(element); \r\n  \r\n       // Вставляемая строка HTML \r\n       this.content = content; \r\n  \r\n       // Попытка вставки строки HTML с использование способа, \r\n       // предусмотренного в Internet Explorer \r\n       if (this.adjacency && this.element.insertAdjacentHTML) { \r\n           this.element.insertAdjacentHTML(this.adjacency, this.content); \r\n  \r\n       // при других обстоятельствах, попытка использовать способ, \r\n       // предусмотренный в W3C \r\n       } else { \r\n           this.range = this.element.ownerDocument.createRange(); \r\n           if (this.initializeRange) this.initializeRange(); \r\n       this.fragment = \r\n           this.range.createContextualFragment(this.content); \r\n           this.insertContent(); \r\n       } \r\n    } \r\n});  \r\nСтремление иметь понятно написанный объектно-ориентированный легко встраиваемый код JavaScript, \r\nдолжно стать критерием разработки как для вас самих, так и для любого другого разработчика. Именно это \r\nположение мы собираемся положить в основу изучения остальной части языка JavaScript. Поскольку JavaScript \r\nпродолжает набирать силу, важность такого стиля разработки будет только усиливаться, он будет становиться все \r\nболее полезным и распространенным.  \r\nВыводы \r\n","\r\n 60\r\nВ этой главе мы рассмотрели различные способы построения структур кода, предназначенного для \r\nширокого применения. Используя объектно-ориентированные технологии, изученные в предыдущей главе, мы \r\nсмогли применить их для создания четких структур данных, хорошо вписывающихся в среду коллективной \r\nразработки. В дополнение к этому мы рассмотрели наилучшие способы создания поддерживаемого кода, \r\nсокращения размера файла JavaScript, и создания пакета кода для его распространения. Знания о том, как \r\nсоздается отлично отформатированный, удобный в сопровождении код, уберегут вас от бесконечных часов \r\nразочарований. \r\n","\r\n 61\r\nГлава 4 Инструменты для отладки и тестирования \r\nПри разработке программ на любом языке программирования больше всего времени уходит, наверное, на \r\nтестирование и отладку кода. Когда ведется разработка программного кода профессионального уровня, гарантия \r\nтого, что вы создаете полностью протестированный, поддающийся проверке и свободный от ошибок  код, \r\nстановится особенно актуальной. Есть одна особенность, определяющая существенное отличие JavaScript от \r\nдругих языков программирования: у него нет владельца или поддержки со стороны какой-либо компании или \r\nорганизации (в отличие от C#, PHP, Perl, Python или Java). Эта особенность может вызвать затруднения в \r\nполучении соответствующей базы для тестирования и отладки вашего кода. \r\nЧтобы сберечь нервы и сократить объем работы, затрачиваемый на отлавливание ошибок в коде \r\nJavaScript, может пригодиться любое из существующих мощных средств разработки. Подобные инструменты \r\n(правда, различного качества) есть у каждого современного браузера. Их применение превращает разработку на \r\nJavaScript в более стройный и многообещающий процесс.  \r\nВ этой главе будут рассмотрены различные инструменты, пригодные для отладки кода JavaScript, а также \r\nвопрос создания многократно используемых, надежных  тестовых комплектов, пригодных для проверок не только \r\nсуществующих, но и будущих разработок.  \r\nОтладка \r\nТестирование и отладка всегда идут рука об руку. Устраивая коду всесторонние испытания, вы наверняка \r\nстолкнетесь с невыловленными ошибками, требующими особого внимания. И тут наступает процесс отладки. \r\nОсвоив лучшие из доступных инструментальных средств, и научившись искать и устранять ошибки в коде, вы \r\nсможете гарантировать его качество и ускорить свою работу \r\nКонсоль ошибок \r\nСамый доступный инструмент, имеющийся в том или ином виде во всех современных браузерах — это \r\nконсоль ошибок. Каждый браузер может предложить консоль определенного качества, со своей степенью \r\nдоступности интерфейса и ценностью сообщений об ошибках. В конечном итоге вы сами придете к решению, \r\nкакой из браузеров больше подходит для начала процесса отладки, чья консоль ошибок (или другие отладочные \r\nрасширения) окажутся наиболее подходящими для разработчиков.  \r\nInternet Explorer \r\nПопулярность браузера не предполагает, что он, соответственно этому качеству, имеет лучший \r\nинструментарий для отладки. К сожалению, консоль ошибок Internet Explorer оставляет желать лучшего. Кроме \r\nвсего прочего, эта консоль по умолчанию отключена, что еще больше запутывает охоту за ошибками, если только \r\nвы не используете Internet Explorer в качестве своего заданного по умолчанию браузера (вообще-то очень \r\nсомнительно, чтобы любой, уважающий себя JavaScript-разработчик использовал бы его в этом качестве).  \r\nКроме вышеупомянутого неудобства использования, у консоли ошибок Internet Explorer есть и более \r\nсущественные проблемы: \r\n• Он выводит сообщение только об одной ошибке; чтобы найти сообщения о других ошибках, нужно \r\nперейти на них, воспользовавшись системой меню.  \r\n• Сообщения об ошибках изложены непонятно, и их логический смысл едва уловим. Точные описания \r\nвозникших проблем появляются в них крайне редко.  \r\n• Строка, содержащей ошибку, всегда указывается со смещением на единицу, т.е. настоящая строка с \r\nошибкой имеет номер на единицу меньше, чем указанная. Если учесть еще и невнятность текста \r\nсообщения об ошибке, то вы должны обладать качеством настоящего охотника за ошибками.  \r\n","\r\n 62\r\nПример сообщения об ошибке, появляющегося в консоли ошибок Internet Explorer, показан на рис. 4.1.  \r\n \r\nРис. 4.1. Консоль ошибок JavaScript в Internet Explorer \r\nКак уже упоминалось в начале этого раздела, лучше для начала процесса отладки кода JavaScript \r\nвоспользоваться другим браузером (а не Internet Explorer). Но если вы все же устранили все ошибки, пользуясь \r\nэтим браузером, значит, у вас было достаточно времени, чтобы разобраться со всеми странностями Internet \r\nExplorer.  \r\nFirefox \r\nЗа последние два года пользовательский интерфейс веб-браузера Firefox был существенно улучшен, \r\nзначительно упростив для веб-разработчиков создание более качественных веб-сайтов. Консоль ошибок \r\nJavaScript претерпела ряд переработок, превратившись в очень полезный инструмент. В консоли ошибок Firefox \r\nзаслуживают внимания следующие особенности:  \r\n• Консоль позволяет вводить произвольные команды JavaScript. Это особенно удобно для определения, \r\nкакое значение имеет та или иная переменная после загрузки страницы. \r\n• Консоль позволяет проводить сортировку сообщений по их типу, к примеру, ошибки, предупреждения или \r\nпростые сообщения.  \r\n• Самая последняя версия консоли предоставляет наряду с ошибками JavaScript  дополнительные \r\nпредупреждения, касающиеся ошибок или неувязок с таблицами стилей. На неудачно спроектированных \r\nвеб-сайтах эта особенность может вызвать целый поток ошибок, но  в целом она очень полезна для \r\nсамостоятельного поиска нетипичных ошибок формата.  \r\n• Недостаток консоли в том, что она не фильтрует ошибки, чтобы выделить из них те, которые относятся к \r\nпросматриваемой в данный момент странице, т.е. вы получаете вперемешку ошибки с разных страниц. \r\n(Расширение Firebug, которое я буду рассматривать в следующем разделе, поможет решить эту проблему.)  \r\nКопия экрана консоли ошибок Firefox показана на рис. 4.2. Обратите внимание на  кнопки, которые можно \r\nиспользовать, чтобы переключаться между различными типами сообщений. \r\n","\r\n 63\r\n \r\nРис. 4.2. Консоль ошибок JavaScript в Firefox \r\nКонсоль ошибок Firefox достаточно хороша, но не совершенна. Поэтому для более успешной отладки своих \r\nприложений разработчики стремятся воспользоваться различными расширениями Firefox. Некоторые из этих \r\nрасширении будут рассмотрены далее в этом разделе. \r\nSafari \r\nБраузер Safari один из самых новых на рынке, и один из самых быстроразвивающихся. В процессе этого \r\nразвития поддержка JavaScript (как в разработке, так и в исполнении кода) была временами довольно \r\nнеустойчивой. Из-за этого доступ к консоли JavaScript внутри браузера несколько затруднен. Консоль даже не \r\nвключена в свойства, которые можно просто активировать. Она полностью скрыта в секретном меню отладки, \r\nнедоступном для обычного пользователя.  \r\nЧтобы активировать меню отладки (а вместе с ним и консоль JavaScript) нужно в командной строке \r\nзапустить команду, показанную в листинге 4.1 (при неработающем Safari).  \r\nЛистинг 4.1. Команда, предписывающая Safari показать меню отладки  \r\ndefaults write com.apple.Safari IncludeDebugMenu 1 \r\nПри следующем запуске Safari у вас появится новый пункт меню отладки, в который будет включена \r\nконсоль JavaScript.  \r\nСкрытность расположения дает понять, что консоль на данный момент не в лучшей форме. О ней можно \r\nсказать лишь следующее:  \r\n• Сообщения об ошибках часто носят невнятный характер, и по качеству находятся практически на том же \r\nуровне, что и сообщения об ошибках в Internet Explorer.  \r\n• Номера ошибочных строк присутствуют, но часто сбрасываются в ноль, заставляя начинать все сначала.  \r\n","\r\n 64\r\n• Фильтрация сообщений об ошибках по страницам отсутствует, но у каждого сообщения есть сценарий, \r\nвыдавший эту ошибку, ссылка на который дается сразу за ее описанием.  \r\nКопия экрана консоли ошибок, запущенной в Safari 2.0, показан на рис. 4.3.  \r\n \r\nРис. 4.3. Консоль ошибок JavaScript в Safari \r\nБраузер Safari еще очень далек от того, чтобы стать платформой для веб-разработок. Тем не менее \r\nкоманда разработки WebKit (создающая для Safari движок формирования изображения) неплохо продвинулась в \r\nсвоей работе, улучшив скоростные параметры браузера. Поэтому в ближайшие месяцы и годы стоит ожидать \r\nпоявления для этого браузера новых успешных разработок.  \r\nOpera \r\nПоследняя консоль ошибок, которую мы собираемся рассмотреть, принадлежит браузеру Opera. К нашему \r\nвсеобщему удовольствию, разработчики Opera тратят много времени и усилий, чтобы превратить этот браузер в \r\nисключительно функциональный и полезный продукт. Вдобавок ко всем свойствам, доступным в консоли ошибок \r\nFirefox, в нем имеется следующее:  \r\n• Хорошее описание ошибок, позволяющее разобраться в сути проблемы.  \r\n• Встроенные фрагменты кода, показывающие, в каком месте допущена ошибка.  \r\n• Возможность отфильтровать ошибки по типам (например, JavaScript, CSS и т.д.).  \r\nК сожалению, консоль не имеет возможности выполнения команд JavaScript, а жаль, поскольку эта \r\nфункция могла бы очень пригодиться. Но все-таки в итоге мы получаем превосходную консоль ошибок. На рис. \r\n4.4 показана копия экрана консоли в Opera 9.0.  \r\n","\r\n 65\r\n \r\nРис. 4.4. Консоль ошибок JavaScript в Opera \r\nOpera давно относится к веб-разработке со всей серьезностью.  \r\nПозиция команды, состоящей из большого количества активных, энергичных разработчиков и \r\nсоставителей технических условий, всегда заключалась в стремлении учесть интересы веб-разработчиков.  \r\nДалее я вам покажу ряд связанных с JavaScript расширений браузеров, обладающих довольно мощными \r\nвозможностями, значительно повышающими производительность разработки.  \r\nИнспекторы DOM \r\nИнспектирование DOM — одна из самых полезных, но недостаточно используемых операций, доступных \r\nвеб-разработчику. Ее можно рассматривать как расширенную версию просмотра исходного кода веб-страницы, \r\nпозволяющую вам увидеть текущее состояние страницы, после того, как ваш код уже изменил ее содержимое.  \r\nРазные DOM-инспекторы на каждом браузере работают по-разному, некоторые предоставляют \r\nдополнительные функциональные возможности, позволяющие вам глубже понять, с чем вы работаете. В этом \r\nразделе я собираюсь рассмотреть три инспектора, и те особенности, которые отличают их друг от друга.  \r\nИнспектор DOM, имеющийся в Firefox \r\nFirefox DOM-инспектор является расширением браузера, который поставляется в предупакованном виде с \r\nкаждой установкой Firefox (но в установщике он по умолчанию отключен). Это расширение позволяет \r\nперемещаться по уже построенному и управляемому HTML-документу. Копия экрана этого расширения показана \r\nна рис. 4.5.  \r\n","\r\n 66\r\n \r\nРис. 4.5. Встроенный в Firefox DOM-инспектор \r\nПри переходе по документу можно не только видеть структуру измененных HTML-элементов, но и каждое \r\nстилевое свойство элемента, наряду с его физическими, объектными свойствами. Это поможет вам точно узнать, \r\nкак именно выглядит веб-страница после ее модификации. В результате вы получаете крайне нужный инструмент.  \r\nDOM-инспектор, имеющийся в Safari \r\nБраузер Safari имеет новый DOM-инспектор, включаемый в его последние сборки. По некоторым \r\nпоказателям он превосходит DOM-инспектор, имеющийся в Firefox, вы можете щелкнуть правой кнопкой мыши на \r\nлюбом элементе страницы и немедленно перейти на него в инспекторе. Копия экрана весьма изящно построенного \r\nDOM-инспектора Safari показана на рис. 4.6.  \r\n","\r\n 67\r\n \r\nРис. 4.6. DOM-инспектор, встроенный в Safari  \r\nХотя это расширение включено в последние сборки Safari, но сделать его доступным еще более сложно, \r\nчем вышеупомянутую консоль JavaScript. Поразительно,  как это команда Safari предприняла столько усилий для \r\nсоздания и добавления этих компонентов, а затем скрыла их от разработчиков, желающих их использовать. И так, \r\nдля активации DOM-инспектора вы должны запустить команду, показанную в листинге 4.2.  \r\nЛистинг 4.2. Enabling the Safari DOM Inspector  \r\ndefaults write com.apple.Safari WebKitDeveloperExtras -bool true  \r\nSafari DOM-инспектор имеет довольно большой потенциал для роста и совершенствования, что само по \r\nсебе хорошо, учитывая талант, проявляемый командой его разработчиков. Но в данный момент для начала работы \r\nв качестве базового инструмента лучше использовать Firefox, пока Safari не будет полностью доработан и \r\nвыпущен в надлежащем виде. \r\nНаглядное представление источника \r\nИ, наконец, я хочу представить самый понятный из всех доступных веб-разработчикам DOM-инспектор. \r\nРасширение Firefox, названное View Rendered Source[1] (отображение структурной диаграммы), предоставляет \r\nдополнительный элемент меню, расположенный рядом с обычным элементом View Source (Просмотр исходного \r\nкода страницы), который дает вам выход на полный образ нового HTML-документа, представленный в интуитивно \r\n","\r\n 68\r\nпонятном и доступном виде. Более подробные сведения об этом расширении можно найти на посвященном ему \r\nвеб-сайте: http://jennifermadden.com/scripts/ViewRenderedSource.html.  \r\nВдобавок к предоставлению образа исходного кода, который выглядит очень естественно, этот инструмент \r\nдает для каждого уровня документа раскраску, соответствующую его положению в общей иерархии, улучшая \r\nваше представление о том, в каком именно месте кода вы находитесь (см. рис. 4.7). \r\n \r\nРис. 4.7. Расширение View Rendered Source, разработанное для Firefox \r\nРасширение View Rendered Source должно стать стандартом для любого набора инструментов веб-\r\nразработчика; его практичность намного превосходит все, что может дать основной пункт меню View Source \r\n(Просмотр исходного кода страницы), и позволяет плавно перейти к более сложному расширению Firefox — DOM-\r\nинспектору.  \r\nFirebug \r\nFirebug — одно из самых важных из появившихся недавно расширений, предназначенных для разработки \r\nна JavaScript. Это расширение, созданное Джо Хьюиттом (Joe Hewitt), служит в качестве полного пакета для \r\nJavaScript-разработчика. В его состав входит консоль ошибок, отладчик и DOM-инспектор. Более подробная \r\nинформация об этом расширении может быть найдена на посвященном ему веб-сайте: \r\nhttp://www.joehewitt.com/software/firebug/.  \r\n","\r\n 69\r\nГлавное преимущество такого обилия интегрированных в единое целое инструментов состоит в том, что вы \r\nполучаете более конкретное представление о причине возникновения проблемы. К примеру, по щелчку на \r\nсообщении об ошибке вы получаете файл JavaScript и строку,  в которой произошла ошибка. Здесь вы можете \r\nустановить контрольные точки останова программы, которые могут использоваться, для пошагового выполнения \r\nсценария, и получения лучшего представления, о том, где возникает ошибка. Копия экрана этого расширения \r\nпоказана на рис. 4.8. \r\n \r\nРис. 4.8. Отладочное расширение Firebug \r\nПока из современных инструментов еще не появилось ничего лучшего, чем Firebug. Я настоятельно \r\nрекомендую выбрать Firefox в сочетании с расширением Firebug в качестве базовой платформы для \r\nпрограммирования на JavaScript.  \r\nVenkman \r\nПоследним элементом, завершающим составление нашего пазла расширений для разработки на JavaScript, \r\nбудет расширение Venkman. Созданное как часть браузера Mozilla, Venkman является условным названием для \r\nпроекта отладочного инструмента JavaScript, запущенного разработчиками Mozilla. Более подробная информация \r\nоб этом проекте и обновленном расширении для Firefox может быть найдена на следующих веб-сайтах:  \r\n• Проекта Mozilla Venkman: http://www.mozilla.org/projects/venkman/ \r\n• Venkman для Firefox: https://addons.mozilla.org/firefox/216/  \r\n• Руководства по Venkman: http://www.mozilla.org/projects/venkman/venkman-walkthrough.html \r\nВажность использования подобного расширения по сравнению с расширением Firebug состоят в том, что \r\nблагодаря его глубокой интеграции в сам движок JavaScript, появляется возможность предоставить \r\nдополнительные средства управления тем, что именно делает ваш код. Копия экрана расширения Venkman для \r\nFirefox показана на рис. 4.9.  \r\n","\r\n 70\r\n \r\nРис. 4.9. Имеющее давнюю историю расширение Venkman JavaScript debugger, перенесенное на Firefox \r\nИспользуя все дополнительные средства управления, представленные этим расширением, вы можете точно \r\nузнать, какая переменная доступна в конкретной области видимости, а также получить достоверную информацию \r\nо состоянии свойств или переменных, и дополнительно к этому получить возможность пошагового выполнения \r\nкода и анализа хода его выполнения. \r\nТестирование \r\nЛично я рассматриваю тестирование кода и создание тестовых примеров как  «проверку на будущее». \r\nСоздавая близкие к реальности тестовые примеры для основного кода или библиотек, вы сможете сэкономить \r\nмассу времени на отладке, которое обычно тратится на поиск какой-нибудь загадочной ошибки, или, что еще \r\nхуже, на невольное внесение в свой код новых ошибок.  \r\nРасполагая внушительным набором тестовых примеров, что является устоявшейся практикой большинства \r\nсовременных систем программирования, вы сможете оказать помощь не только себе самому, но всем остальным, \r\nкто использует вашу программную основу, добавляя к ней новые возможности и устраняя ошибки.  \r\nВ этом разделе я представлю вам три различные библиотеки, которые могут быть использованы для \r\nпостроения наборов тестовых примеров JavaScript, каждый из которых может быть выполнен кроссбраузерным \r\nавтоматизированным способом.  \r\nJSUnit \r\nБиблиотека JSUnit долгое время была чем-то вроде золотого стандарта для блочного тестирования \r\nJavaScript. Большая часть ее функциональных возможностей основана на популярном пакете JUnit для Java, что \r\nозначает ее легкое освоение при условии, что вы знаете, как JUnit работает с Java. На посвященном этой \r\n","\r\n 71\r\nбиблиотеке веб-сайте http://www.jsunit.net/, имеется масса информации и документации \r\n(http://www.jsunit.net/documentation/).  \r\nКак и большинство других комплексов для блочного тестирования (или по крайней мере те из них, что \r\nрассматриваются в этом разделе), этот комплекс содержит три основных компонента:  \r\nПрогонщик теста: Эта часть комплекса предоставляет красочное графическое отображение, \r\nпоказывающее насколько далеко продвинулся тест по сравнению с полным прогоном. Она дает возможность \r\nзагружать тестовые наборы и выполнять их содержимое, регистрируя все предоставляемые ими выходные \r\nданные.  \r\nТестовый набор: Это коллекция тестовых примеров (иногда разбитых на несколько веб-страниц).  \r\nТестовые примеры: Это отдельные команды, которые вычисляются в простые выражения типа true/false, \r\nтем самым предоставляя вам поддающиеся оценке результаты, позволяющие определить правильность работы \r\nвашего кода. По отдельности тестовые примеры могут и не быть полезными, но при их совместном использовании \r\nв прогонщике теста, вы можете извлечь выгоду от их взаимодействия. \r\nВсе это вместе взятое создает полноценный автоматизированный тестовый комплекс, который может быть \r\nиспользован для запуска и добавления дальнейших тестов. Пример простого тестового комплекса показан в \r\nлистинге 4.3, а набор тестовых примеров показан в листинге 4.4.  \r\nЛистинг 4.3. Тестовый комплекс, построенный с использованием JSUnit \r\n<html> \r\n<head> \r\n    <title>JsUnit Test Suite</title> \r\n    <script src=\"../app/jsUnitCore.js\"></script> \r\n    <script> \r\n       function suite() { \r\n           var newsuite = new top.jsUnitTestSuite(); \r\n           newsuite.addTestPage(\"jsUnitTests.html\"); \r\n           return newsuite; \r\n       } \r\n    </script> \r\n</head> \r\n<body></body> \r\n</html>  \r\nЛистинг 4.4. Различные тестовые примеры, которые могут быть использованы в  типичной тестовой \r\nстранице JSUnit \r\n  \r\n<html> \r\n<head> \r\n<title>JsUnit Assertion Tests</title> \r\n<script src=\"../app/jsUnitCore.js\"></script> \r\n<script> \r\n// тестирование выражения на истинность (true) \r\nfunction testAssertTrue() { \r\n    assertTrue(\"true should be true\", true); \r\n","\r\n 72\r\n    assertTrue(true); \r\n} \r\n  \r\n// Тестирование выражения на ложность (false) \r\nfunction testAssertFalse() { \r\n    assertFalse(\"false should be false\", false); \r\n    assertFalse(false); \r\n} \r\n  \r\n// Тестирование двух аргументов на равенство друг другу \r\nfunction testAssertEquals() { \r\n    assertEquals(\"1 should equal 1\", 1, 1); \r\n    assertEquals(1, 1); \r\n} \r\n  \r\n// Тестирование двух аргументов на неравенство друг другу \r\nfunction testAssertNotEquals() { \r\n    assertNotEquals(\"1 should not equal 2\", 1, 2); \r\n    assertNotEquals(1, 2); \r\n} \r\n// Тестирование аргумента на равенство нулевому значению (null) \r\nfunction testAssertNull() { \r\n    assertNull(\"null should be null\", null); \r\n    assertNull(null); \r\n} \r\n  \r\n// на неравенство нулевому значению (null) \r\nfunction testAssertNotNull() { \r\n    assertNotNull(\"1 should not be null\", 1); \r\n    assertNotNull(1); \r\n} \r\n  \r\n// и еще многое-многое другое ...; \r\n</script> \r\n</head> \r\n<body></body> \r\n</html> \r\n  \r\nПо JSUnit есть довольно неплохая документация, а поскольку эта библиотека существует уже достаточно \r\nдолгое время, то вы, скорее всего, сможете найти хорошие примеры ее использования.  \r\nJ3Unit \r\nБиблиотека J3Unit — новичок в мире блочного тестирования JavaScript. Она превосходит JSUnit в том, что \r\nможет быть непосредственно интегрирована с комплексом тестирования на стороне сервера, к примеру, с JUnit \r\nили Jetty. Эта библиотека может быть очень полезна для Java-разработчиков, потому что они могут быстро \r\nпрогнать все свои тестовые примеры для кода как на клиентской, так и на серверной стороне. Но, поскольку не \r\nвсе работают с Java, J3Unit также предоставляет статический режим, который может быть исполнен на вашем \r\n","\r\n 73\r\nбраузере, так же как и любые другие библиотеки блочного тестирования. Более подробные сведения о J3Unit \r\nможно найти на веб-сайте, посвященном этой библиотеке: http://j3unit.sourceforge.net/.  \r\nПоскольку связка тестовых примеров на стороне клиента с кодом на стороне сервера является довольно \r\nредким режимом работы этой библиотеки, давайте посмотрим, как в J3Unit работают статические блочные тесты \r\nна стороне клиента. К нашему всеобщему удовольствию, они ведут себя практически также, как и другие \r\nтестовые комплекты, позволяя легко переключиться на работу с этой библиотекой, что становится понятным из \r\nпросмотра кода листинга 4.5.  \r\nЛистинг 4.5. Простой тест, выполняемый с помощью J3Unit \r\n  \r\n<html> \r\n<head> \r\n<title>Sample Test</title> \r\n<script src=\"js/unittest.js\" type=\"text/javascript\"></script> \r\n<script src=\"js/suiterunner.js\" type=\"text/javascript\"></script> \r\n</head> \r\n<body> \r\n<p id=\"title\">Sample Test</p> \r\n<script type=\"text/javascript\"> \r\nnew Test.Unit.Runner({ \r\n    // Тестирование невидимого и видимого режимов отображения элемента \r\n    testToggle: function() {with(this) { \r\n       var title = document.getElementById(\"title\"); \r\n       title.style.display = 'none'; \r\n       assertNotVisible(title, \"title should be invisible\"); \r\n       element.style.display = 'block'; \r\n       assertVisible(title, \"title should be visible\"); \r\n    }}, \r\n  \r\n    // Тестирование добавления одного элемента к другому \r\n    testAppend: function() {with(this) { \r\n       var title = document.getElementById(\"title\"); \r\n       var p = document.createElement(\"p\"); \r\n       title.appendChild( p ); \r\n       assertNotNull( title.lastChild ); \r\n       assertEqual( title.lastChild, p ); \r\n    }} \r\n}); \r\n</script> \r\n</body> \r\n</html>  \r\nХотя J3Unit относительно новая библиотека, она подает множество надежд для развития среды блочного \r\nтестирования. Если вас заинтересовал ее объектно-ориентированный стиль, я советую к ней присмотреться.  \r\nTest.Simple \r\n","\r\n 74\r\nПоследним примером блочного тестирования JavaScript служит еще один новичок. Библиотека Test.Simple \r\nбыла представлена одновременно с созданием JSAN в качестве способа определения общих стандартов \r\nтестирования всех представленных там модулей JavaScript. Поскольку Test.Simple получила широкое \r\nраспространение, у нее имеется обширная документация и множество примеров использования, что в \r\nсовокупности является весьма важным аспектом использования среды тестирования. Более подробные сведения о \r\nTest.Simple (и сопутствующей ей библиотеке Test.More) могут быть найдены в следующих источниках: \r\n• Test.Simple: http://openjsan.org/doc/t/th/theory/Test/Simple/  \r\n• Документация по Test.Simple: http://openjsan.org/doc/t/th/theory/Test/Simple/0.21/lib/Test/Simple.html \r\n• Документация по Test.More: http://openjsan.org/doc/t/th/theory/Test/Simple/0.21/lib/Test/More.html \r\nБиблиотека Test.Simple предоставляет обширный арсенал методов тестирования наряду с полноценным \r\nпрогонщиком тестов, обеспечивающим их автоматизированное выполнение. Пример типового теста Test.Simple \r\nпоказан в листинге 4.6.  \r\nЛистинг 4.6. Использование Test.Simple и Test.More для выполнения тестов \r\n// Загрузка модуля  Test More (для самотестирования!) \r\nnew JSAN('../lib').use('Test.More'); \r\n  \r\n// Планирование проведения шести тестов (чтобы определить все недочеты) \r\nplan({tests: 6}); \r\n  \r\n// Тестирование трех простых примеров \r\nok( 2 == 2, 'two is two is two is two' ); \r\nis( \"foo\", \"foo\", 'foo is foo' ); \r\nisnt( \"foo\", \"bar\", 'foo isnt bar'); \r\n  \r\n// Тестирование с использованием регулярных выражений \r\nlike(\"fooble\", /^foo/, 'foo is like fooble'); \r\nlike(\"FooBle\", /foo/i, 'foo is like FooBle'); \r\nlike(\"/usr/local/\", '^\\/usr\\/local', 'regexes with slashes in like' ); \r\nМне лично нравится легкость использования библиотек Test.Simple и Test.More, поскольку они не \r\nдоставляют больших хлопот и помогают поддерживать простоту вашего кода. В конечном счете вам решать, какой \r\nиз тестовых комплексов лучше подойдет, поскольку подбор такого комплекса для кода — очень важный вопрос, \r\nкоторый нельзя обойти стороной. \r\nВывод \r\nВозможно, весь представленный в этой главе материал не стал особым откровением для искушенных \r\nопытом программистов, но объединение всех рассмотренных понятий применительно к JavaScript, в конечном \r\nитоге будет способствовать  простоте и удобству использования этого языка, и его росту в качестве \r\nпрофессионального языка программирования. Я настоятельно рекомендую, чтобы вы ввели в практику своих \r\nразработок процесс отладки и тестирования. Я уверен, что только он позволит вам создавать более качественный \r\nи свободный от ошибок код JavaScript. \r\n \r\n \r\n \r\n","\r\n 75\r\n[1] Теперь это расширение называется View Source Chart (прим. переводчика) \r\n","\r\n 76\r\nГлава 5 Объектная модель документа \r\nИз всех достижений, произошедших за последнее десятилетие в веб-разработке, написание сценариев с \r\nиспользованием объектной модели документа — DOM (Document Object Model) стало, пожалуй, наиболее важной \r\nтехнологией, которой может воспользоваться веб-разработчик для улучшения впечатлений пользователей от \r\nсвоей работы. \r\nИспользование DOM в написании сценариев для добавления к странице ненавязчивого кода JavaScript (что \r\nозначает его невмешательство в работу браузеров, не поддерживающих JavaScript, или с отключенной \r\nпользователем поддержкой) дает возможность предоставления весь спектр современных усовершенствований, \r\nготовых порадовать ваших пользователей, не досаждая тем из них, кто ими не пользуется. Дополнительный \r\nэффект, возникший благодаря использованию DOM-сценариев проявился в том, что весь ваш код получил четкое \r\nразделение на объекты, которыми стало легче управлять.  \r\nК нашему всеобщему удовлетворению, все современные браузеры поддерживают DOM, а также \r\nдополнительно поддерживают встроенное DOM-представление текущего HTML-документа. Ко всем объекта \r\nимеется свободный доступ из кода JavaScript, что во многом способствует работе современных веб-разработчиков. \r\nУмение пользоваться этой технологией и знание самых эффективных приемов ее использования может дать \r\nосновной толчок к созданию вашего следующего веб-приложения.  \r\nВ этой главе мы рассмотрим ряд тем, связанных с DOM. Предполагая, что некоторые читатели не знакомы \r\nс этой моделью, я начну с ее основ, и проведу вас по всем самым важным понятиям. А для тех, кто уже знаком с \r\nмоделью DOM, я обещаю показать несколько очень эффективных технологических приемов, которым, как я \r\nуверен, вы несомненно обрадуетесь, и начнете их использовать на собственных веб-страницах.  \r\nВведение в объектную модель документа \r\nМодель DOM является стандартным способом представления XML-документов (введенным организацией \r\nW3C). Она, конечно, не является самой быстродействующей, простой и легкой в использовании, но зато она самая \r\nраспространенная, и ее реализация существует во многих языках программирования, используемых для веб-\r\nразработки (среди которых Java, Perl, PHP, Ruby, Python и JavaScript). DOM создавалась с целью предоставить \r\nразработчикам интуитивно понятный способ перехода по иерархии XML-документа. Даже если вы не вполне \r\nзнакомы с XML, для вас будет очень радостной вестью, что все HTML-документы (которые с точки зрения \r\nбраузеров являются документами XML) имеют готовое к использованию DOM-представление.  \r\nПереходы по DOM \r\nСпособом представления в DOM структуры XML, является дерево, по которому можно осуществлять \r\nпереходы. Вся используемая терминология позаимствована у генеалогического дерева (родители, дети, родные \r\nсестры и т.д.). В отличие от обычного семейного дерева, все XML-документы начинаются с одного корневого узла \r\n(который называется элементом document), в котором содержатся указатели на его детей. Каждый дочерний узел \r\nимеет в свою очередь обратный указатель на своего родителя, на своих собратьев по уровню и на свои \r\nсобственные дочерние элементы.  \r\nДля ссылки на различные объекты дерева XML, в DOM используется специальная терминология. Каждый \r\nобъект дерева DOM является узлом. Каждый узел может иметь различный тип, например, элемент, текст или \r\nдокумент. Чтобы продолжить нашу учебу, нам нужно знать, как выглядит документ, отвечающий модели DOM, и \r\nкак по нему осуществлять переходы после того, как он будет выстроен. Давайте исследуем работу подобного \r\nDOM-построения, рассмотрев простой фрагмент HTML-кода:  \r\n<p><strong>Hello</strong> how are you doing?</p>  \r\n","\r\n 77\r\nКаждая часть этого фрагмента разбивается на DOM-узлы, имеющие указатели от каждого узла на его \r\nпрямых родственников (родителей, детей, сестер). Если вам понадобилось бы составить полную схему \r\nсуществующих родственных отношений, то она бы выглядела, как показано на рис. 5.1. Каждая часть фрагмента \r\n(прямоугольники со скругленными углами представляют элементы, а правильные прямоугольники — текстовые \r\nузлы) отображена вместе со всеми доступными ссылками.  \r\n \r\nРис. 5.1. Родственные связи между узлами \r\nКаждый отдельно взятый DOM-узел содержит семейство указателей, которые могут использоваться для \r\nссылок на родственные ему узлы. Воспользуемся этими указателями для освоения перемещений по DOM. На \r\nрис. 5.2. показаны все доступные указатели. Каждое из этих свойств, доступное на каждом узле DOM, является \r\nуказателем на другой DOM-элемент (или содержит значение null, если элемент не существует).  \r\n","\r\n 78\r\n \r\nРис. 5.2. Перемещение по дереву DOM с использованием указателей  \r\nИспользуя только различные указатели, можно перемещаться к любому элементу или текстовому блоку на \r\nстранице. Лучше всего понять, как это будет работать на практике, рассмотрев обычную HTML-страницу, \r\nпоказанную в листинге 5.1.  \r\nЛистинг 5.1. Простая веб-страница HTML, являющаяся двойником простого XML-документа  \r\n<html> \r\n<head> \r\n    <title>Введение в DOM</title> \r\n</head> \r\n<body> \r\n    <h1>Введение в DOM</h1> \r\n    <p class=\"test\">Есть ряд причин, по которым DOM – явление удивительное, \r\n                  и вот некоторые из них:</p> \r\n    <ul> \r\n       <li id=\"everywhere\">Ее можно найти повсюду.</li> \r\n       <li class=\"test\">Ею легко пользоваться.</li> \r\n <li class=\"test\">Она помогает найти все, что нужно, причем \r\n               сделать это довольно быстро.</li> \r\n    </ul> \r\n</body> \r\n</html>  \r\nВ примере документа корневым элементом является элемент <html>. Получить в JavaScript доступ к \r\nкорневому элементу довольно просто:  \r\ndocument.documentElement  \r\n","\r\n 79\r\nКорневой узел имеет все указатели, используемые для перемещений, точно также, как и любой другой \r\nDOM-узел. Используя эти указатели вы имеете возможность приступить к просмотру всего документа, \r\nперемещаясь на любой нужный элемент. К примеру, чтобы добраться до элемента <h1>, можно воспользоваться \r\nследующим кодом:  \r\n// Этот код не работает! \r\ndocument.documentElement.firstChild.nextSibling.firstChild  \r\nНо мы тут же натыкаемся на свое первое препятствие: указатели DOM могут указывать как на текстовые \r\nузлы, так и на элементы. А предыдущий оператор на самом деле вместо того, чтобы указывать на элемент <h1>, \r\nуказывает на элемент <title>. Почему так происходит? А потому что есть одна из самых неприятных и наиболее \r\nспорных сторон XML: пустого пространства. Если присмотреться, то можно заметить, что между элементами \r\n<html> и <head> на самом деле находится символ конца строки, который рассматривается как пустое \r\nпространство, а значит, что фактически первым следует текстовый узел, а не <head>-элемент. Из этого \r\nобстоятельства следует извлечь три урока:  \r\n• Создание красивой и понятной HTML-разметки фактически может привести к путанице при попытке \r\nпросмотреть DOM с использованием только одних указателей. \r\n• Использование для перемещения по документу только одних DOM-указателей может стать слишком \r\nгромоздким и непрактичным. \r\n• Зачастую непосредственный доступ к текстовым узлам не нужен, он требуется только к тем элементам, \r\nкоторые их окружают. \r\nВ связи с этим возникает вопрос: А нет ли более практичного способа для поиска элементов в документе? \r\nКонечно же есть! Вооружившись парой полезных функций, вы с легкостью сможете улучшить существующие \r\nметоды и значительно упростить перемещения по DOM. \r\nКак справиться в DOM с пустым пространством \r\nВернемся к примеру HTML-документа. Ранее мы уже пытались переместиться к элементу <h1> и \r\nстолкнулись с трудностями, обусловленными наличием внешних текстовых узлов. Ладно бы это касалось только \r\nодиного-единственного элемента, но что получится, если вам захочется добраться до элемента, который следует \r\nза <h1>? Вы опять наткнетесь на досадную ошибку пустого пространства, вынуждающую применить \r\n.nextSibling.nextSibling, чтобы перескочить символы конца строки между элементами <h1> и <p>. Но не все еще \r\nпотеряно. Существует методика, показанная в листинге 5.2, которая действует в качестве обхода этой ошибки \r\nпустого пространства. Эта специфическая методика удаляет из DOM-документа все текстовые узлы, содержащие \r\nтолько пустые пространства, облегчая тем самым проход по дереву модели. Ее применение не окажет заметного \r\nвлияния на отображение вашего HTML, но значительно упростит для вас самостоятельные перемещения по \r\nдокументу. Следует заметить, что результаты работы этой функции не являются необратимыми, поэтому при \r\nкаждой загрузке HTML-документа ее придется запускать заново.  \r\nЛистинг 5.2. Обход ошибки пустого пространства в XML-документах  \r\nfunction cleanWhitespace( element ) { \r\n    // Если element не предоставлен, работать со всем HTML-документом \r\n    element = element || document; \r\n    // В качестве отправной точки использовать первый дочерний узел \r\n    var cur = element.firstChild; \r\n  \r\n    // Действовать, пока не закончатся дочерние узлы \r\n    while ( cur != null ) { \r\n","\r\n 80\r\n  \r\n  // Если узел текстовый, и не содержит ничего, кроме пустого \r\n  // пространства \r\n      if ( cur.nodeType == 3 && ! /\\S/.test(cur.nodeValue) ) { \r\n       // Удалить текстовый узел \r\n       element.removeChild( cur ); \r\n  \r\n      // А если это элемент \r\n      } else if ( cur.nodeType == 1 ) { \r\n       // осуществить рекурсивный вызов вниз по документу \r\n       cleanWhitespace( cur ); \r\n      } \r\n  \r\n      cur = cur.nextSibling; // перемещение через дочерние узлы \r\n    } \r\n}  \r\nСкажем, вы хотите воспользоваться этой функцией в примере документа для перемещения к элементу \r\nкоторый следует за первым элементом <h1>. Код, выполняющий эту задачу, может иметь следующий вид:  \r\ncleanWhitespace(); \r\n  \r\n// Обнаружение элемента H1 \r\ndocument.documentElement \r\n    .firstChild       // Обнаружение элемента Head \r\n    .nextSibling   // Обнаружение элемента <body> \r\n    .firstChild       // Получение элемента H1 \r\n    .nextSibling   // Получение смежного абзаца  \r\nУ этого метода есть свои преимущества и недостатки. Самое большое преимущество состоит в том, что \r\nполучаете какой-то здравый смысл в попытках перемещения по DOM-документу. Но эта методика работает очень \r\nмедленно, поскольку вам нужно пройти по каждом у отдельно взятому DOM-элементу и текстовому узлу, \r\nвыискивая текстовые узлы, содержащие только пустые пространства. Если в документе большой объем \r\nсодержимого, эта методика может существенно замедлить загрузку вашего веб-сайта. К тому же при каждой \r\nвставке в документ нового кода HTML, необходимо провести пересканирование этой части DOM, чтобы \r\nвоспрепятствовать добавлению к документу новых текстовых узлов, состоящих из пустых пространств.  \r\nВ этой функции применен один важный подход — использование типов узлов. Тип узла может быть \r\nопределен путем проверки свойства nodeType на наличие определенного значения. Есть несколько возможных \r\nзначений, но три из них встречаются чаще других: \r\n• Элемент (nodeType = 1): Этот тип соответствует большинству элементов XML-файла. Например, элементы \r\n<li>,<a>, <p> и <body> имеют значение свойства nodeType равное 1. \r\n• Текст (nodeType = 3): Этот тип соответствует всем текстовым участкам внутри документа. При \r\nперемещении по DOM-структуре с помощью методов previousSibling и nextSibling вы будете часто \r\nсталкиваться  с участками текста внутри, между элементами. \r\n• Документ (nodeType = 9): Этот тип соответствует корневому элементу документа. К примеру, в HTML-\r\nдокументе — это элемент <html>. \r\n","\r\n 81\r\nВ дополнение к этому для ссылок на различные типы узлов DOM вы можете использовать константы (но \r\nтолько при работе с браузерами, не относящимися к семейству IE). К примеру, чтобы не запоминать значение \r\nчисел 1, 3 или 9, вы можете просто воспользоваться константами document.ELEMENT_NODE, document.TEXT_NODE \r\nили document.DOCUMENT_NODE. Поскольку постоянная очистка DOM от пустых пространств может стать слишком \r\nобременительным занятием, нам нужно исследовать другие способы перемещения по DOM-структуре.  \r\nПростое перемещение по DOM-структуре \r\nИспользуя принцип простого DOM-перемещения (наличие указателей для всех направлений перемещения) \r\nвы можете разрабатывать функции, которые больше вам подойдут при перемещении по HTML DOM-документу. \r\nЭтот принцип основан на том факте, что большинству веб-разработчиков требуются лишь перемещения по DOM-\r\nэлементам, и очень редко по их собратьям — текстовым узлам. Вам помогут несколько полезных функций, \r\nкоторые можно применить вместо стандартных previousSibling, nextSibling, firstChild, lastChild и parentNode. В \r\nлистинге 5.3 показана функция, которая возвращает элемент, которые предшествует текущему элементу, или null, \r\nесли предыдущий элемент не найден, работающая наподобие свойства элемента previousSibling.  \r\nЛистинг  5.3. Функция, предназначенная для обнаружения предыдущего сестринского элемента по отношению к \r\nпереданному ей элементу \r\nfunction prev( elem ) { \r\n    do { \r\n       elem = elem.previousSibling; \r\n    } while ( elem && elem.nodeType != 1 ); \r\n    return elem; \r\n}  \r\nВ листинге 5.4 показана функция, возвращающая элемент, следующий за текущим элементом, или null, \r\nесли следующий элемент не найден, работающая наподобие свойства элемента nextSibling.  \r\nЛистинг 5.4.    Функция, предназначенная для обнаружения следующего сестринского элемента по \r\nотношению к переданному ей элементу \r\nfunction next( elem ) { \r\n    do { \r\n       elem = elem.nextSibling; \r\n    } while ( elem && elem.nodeType != 1 ); \r\n    return elem; \r\n}  \r\nВ листинге 5.5 показана функция, возвращающая первый дочерний элемент, работающая наподобие \r\nсвойства элемента firstChild.  \r\nЛистинг 5.5. Функция для обнаружения первого дочернего элемента по отношению к переданному ей \r\nэлементу \r\n  \r\nfunction first( elem ) { \r\n    elem = elem.firstChild; \r\n    return elem && elem.nodeType != 1 ? \r\n       next ( elem ) : elem; \r\n}  \r\n","\r\n 82\r\nВ листинге 5.6 показана функция, возвращающая последний дочерний элемент, работающая наподобие \r\nсвойства элемента lastChild.  \r\nЛистинг 5.6.  Функция для обнаружения последнего дочернего элемента по отношению к переданному ей \r\nэлементу  \r\nfunction last( elem ) { \r\n    elem = elem.lastChild; \r\n    return elem && elem.nodeType != 1 ? \r\n       prev ( elem ) : elem; \r\n}  \r\nВ листинге 5.7 показана функция, возвращающая родительский элемент, работающая наподобие свойства \r\nэлемента parentNode. Дополнительно вы можете указать ей количество родительских элементов, на которое сразу \r\nнужно подняться — например, parent(elem,2) будет эквивалентно выражению parent(parent(elem)).  \r\nЛистинг 5.7.  Функция для обнаружения родителя указанного элемента  \r\nfunction parent( elem, num ) { \r\n    num = num || 1; \r\n    for ( var i = 0; i < num; i++ ) \r\n       if ( elem != null ) elem = elem.parentNode; \r\n    return elem; \r\n}  \r\nИспользуя эти новые функции, вы можете быстро просматривать DOM-документ, не испытывая волнений \r\nнасчет текста, который находится между элементами. Например, чтобы обнаружить элемент, следующий за \r\nэлементом <h1>, подобно тому, что мы делали раньше, теперь нужно сделать следующее:  \r\n// Обнаружение элемента, следующего за элементом <h1> \r\nnext( first( document.body ) ) \r\nИзучая этот код, нужно обратить внимание на две особенности. Первая  касается новой ссылки: \r\ndocument.body. Все современные браузеры предоставляют ссылку на элемент  <body> внутри свойства body HTML \r\nDOM-документа. Этим обстоятельством можно воспользоваться для того, чтобы сделать код компактнее и \r\nпонятнее. Вторая, как вы могли заметить, заключается в том, что способ написания функции противоречит норме \r\nинтуитивного восприятия. Обычно, представляя себе перемещение, вы можете сказать: «Начиная с элемента \r\n<body>, получить первый элемент, а затем получить следующий элемент», но способ, которым это отображено \r\nфизически, кажется развернутым в обратном направлении. Чтобы обойти эту несуразицу, я теперь рассмотрю \r\nнесколько способов, чтобы сделать ваш код, предназначенный для перемещений, более понятным.  \r\nПривязка к каждому HTML-элементу \r\nВ Firefox и Opera имеются мощные и доступные прототипы объектов, названные   HTMLElement, которые \r\nпозволяют привязывать функции и данные к каждому отдельному HTML DOM-элементу. Функции, описанные в \r\nпредыдущем разделе несколько сложны и непонятны, и могут быть заменены другими, улучшенными функциями. \r\nОдним из лучших способов для этого является привязка ваших функций непосредственно к прототипу \r\nHTMLElement, что приведет к их непосредственной привязке к каждому отдельному HTML DOM-элементу. Чтобы \r\nэто заработало, вам нужно внести в функции, созданные в предыдущем разделе, следующие три изменения:  \r\n1. Нужно добавить в начале функции одну строку, чтобы ссылка на элемент была сделана, как  на данный \r\nобъект — this, а не получена из перечня аргументов. \r\n","\r\n 83\r\n2. Нужно убрать аргумент элемента, надобность в котором уже миновала. \r\n3. Нужно привязать функцию к прототипу HTMLElement, чтобы у вас появилась возможность использовать ее \r\nс каждым HTML-элементом, имеющимся в DOM. \r\nК примеру, функция next будет выглядеть, как показано в листинге 5.8.  \r\nЛистинг 5.8. Динамическая привязка новой функции DOM-перемещения ко всем HTML DOM-элементам  \r\nHTMLElement.prototype.next = function() { \r\n    var elem = this; \r\n    do { \r\n       elem = elem.nextSibling; \r\n    } while ( elem && elem.nodeType != 1 ); \r\n    return elem; \r\n};  \r\nТеперь вы можете воспользоваться функцией next (и всеми другими функциями, после их \r\nпредварительной переделки) следующим образом:  \r\n// Простой пример — получение первого <p>-элемента \r\ndocument.body.first().next()  \r\nБлагодаря этому код становится намного проще и понятнее. Теперь, получив возможность создавать код, \r\nкоторый следует естественному ходу размышлений, вы можете сделать свой JavaScript в целом намного понятнее. \r\nЕсли такой стиль написания вас заинтересовал, я настоятельно рекомендую взять на заметку библиотеку jQuery \r\nJavaScript (http://jquery.com), в которой делается большая ставка на использование этой технологии. \r\nПРИМЕЧАНИЕ \r\nПоскольку HTMLElement существует только в трех современных браузерах (Firefox, Safari и Opera) для его \r\nработы в Internet Explorer нужно предварительно предпринять специальные меры. Речь идет о общедоступной и \r\nочень полезной библиотеке, созданной Джейсоном Карлом Дэвисом (Jason Karl Davis) (http://browserland.org), \r\nкоторая предоставляет доступ к HTMLElement (а также ряд других свойств) в двух, не поддерживающих этот \r\nпрототип объектов браузерах. Дополнительные сведения об этой библиотеке можно найти здесь: \r\nhttp://www.browserland.org/scripts/htmlelement/.  \r\nСтандартные методы DOM \r\nВсе современные реализации DOM содержат несколько методов, улучшающих жизнь разработчиков. Их \r\nсовместное использование с некоторыми собственными функциями делает перемещение по DOM намного \r\nприятнее. Для начала рассмотрим два довольно мощных метода, включенных в JavaScript DOM:  \r\ngetElementById(“everywhere”): Этот метод, который может быть выполнен исключительно в отношении \r\nобъекта документа, обнаруживает все элементы, ID которых равен everywhere. Это очень мощная функция, \r\nпредоставляющая самый быстрый способ немедленного доступа к элементу.  \r\ngetElementsByTagName(“li”): Этот метод, который может быть выполнен в отношении любого элемента, \r\nобнаруживает все нисходящие элементы, у которых в качестве имени тега  фигурирует li, и возвращает их в \r\nNodeList (который практически идентичен массиву).  \r\nВНИМАНИЕ \r\n","\r\n 84\r\nВы должны понимать, что getElementById работает с HTML-документами: он просматривает все элементы и \r\nобнаруживает один из них, имеющий атрибут под названием id, имеющий определенное значение. Но если вы \r\nзагружаете удаленный XML-документ и используете getElementById (или используете реализацию DOM в любом \r\nдругом языке, кроме JavaScript), то в нем по умолчанию не используется атрибут id. Это сделано намеренно; XML-\r\nдокумент должен определить явным образом, что из себя представляет атрибут id, используя обычно XML-\r\nопределение или схему.  \r\nВНИМАНИЕ \r\nМетод getElementsByTagName возвращает NodeList. Эта структура по своему виду и поведению во многом \r\nпохожа на обычный массив JavaScript, с одной важной оговоркой: в нем отсутствуют обычные для массива \r\nJavaScript методы .push(), .pop(), .shift() и т.д. Об этом нужно помнить при работе с getElementsByTagName, чтобы \r\nизбежать неприятностей.  \r\nЭти методы доступны во всех современных браузерах и могут быть очень полезны для обнаружения \r\nопределенных элементов. Возвращаясь к предыдущему примеру, в котором мы пытались обнаружить элемент \r\n<h1>, теперь мы можем сделать следующее:  \r\ndocument.getElementsByTagName(\"h1\")[0]  \r\nЭтот код будет гарантированно работать, и всегда возвращать первый <h1>-элемент, встречающийся в \r\nдокументе. Еще раз вернемся к документу и представим, что нам нужно получить все <li>-элементы и добавить к \r\nним обрамление:  \r\nvar li = document.getElementsByTagName(\"li\"); \r\nfor ( var j = 0; j < li.length; j++ ) { \r\n    li[j].style.border = \"1px solid #000\"; \r\n} \r\nВ заключение, представим, что нам нужно сделать полужирным текст в первом <li>-элементе, который, \r\nкак оказалось, имеет связанный с ним и известный нам ID:  \r\ndocument.getElementById(\"everywhere\").style.fontWeight = 'bold';  \r\nЗдесь вы, возможно, обратили внимание, что процесс получения отдельного элемента с определенным ID \r\nтребует большого количества сопроводительного текста, что, впрочем, справедливо и для извлечении элемента по \r\nимени тега. Чтобы обойти это обстоятельство и упростить процесс извлечения, можно создать упаковочную \r\nфункцию: \r\nfunction id(name) { \r\n    return document.getElementById(name); \r\n}  \r\nВ листинге 5.9. показана простая функция, предназначенная для обнаружения элементов внутри HTML \r\nDOM-документа по имени тега. Эта функция принимает от одного до двух аргументов. Если предоставляется один \r\nаргумент, и это имя тега, то поиск будет вестись во всем HTML-документе. Иначе вы должны предоставить в \r\nпервом необязательном аргументе DOM-элемент, который будет использован в качестве контекста.  \r\nЛистинг 5.9. Функция для обнаружения элементов по имени тега внутри HTML DOM-документа  \r\nfunction tag(name, elem) { \r\n    // Если контекстный элемент не предоставлен, вести поиск по всему \r\n    // документу \r\n","\r\n 85\r\n    return (elem || document).getElementsByTagName(name); \r\n}  \r\nДавайте еще раз вернемся к проблеме обнаружения элемента, который следует за первым элементом \r\n<h1>. К нашему удовлетворению, код для осуществления этой операции может стать еще короче:  \r\n// Обнаружение элемента, находящегося сразу же за первым элементом <h1> \r\nnext( tag(\"h1\")[0] ); \r\nЭти функции предоставляют вам мощность, необходимую для быстрого извлечения нужных для работы \r\nэлементов внутри DOM-документа. Перед тем, как изучить способы применения этой мощности для модификации \r\nDOM, нужно накоротке взглянуть на проблемы загрузки DOM при первоначальном запуске вашего сценария.  \r\nОжидание загрузки HTML DOM \r\nПри работе с HTML DOM-документами существует одно затруднение, связанное с тем, что код JavaScript \r\nможет быть исполнен еще до того, как DOM полностью загрузится, что является потенциальной угрозой \r\nвозникновения в коде ряда проблем. Последовательность операций в браузере выглядит следующим образом:  \r\n• Синтаксический анализ HTML.  \r\n• Загрузка внешних сценариев и таблиц стиля.  \r\n• Выполнение сценариев по мере их разбора в документе.  \r\n• Полное построение HTML DOM.  \r\n• Загрузка изображений и внешнего контента.  \r\n• Завершение загрузки страницы.  \r\nСценарии, находящиеся в заголовке, и загружаемые из внешнего файла выполняются до фактического \r\nпостроения HTML DOM. Как отмечено ранее, это является существенной проблемой, поскольку все сценарии в \r\nэтих двух местах не будут иметь доступа к DOM. Но, к счастью существует ряд способов обхода этой проблемы.  \r\nОжидание загрузки страницы \r\nБезусловно, самой распространенной методикой является простое ожидание загрузки всей страницы перед \r\nвыполнением любых DOM-операций. Эта методика может быть использована за счет простой привязки функции, \r\nкоторая должна быть выполнена после загрузки страницы, к событию load объекта window. События будут \r\nподробно рассмотрены в главе 6. В листинге 5.10 показан пример выполнения связанного с DOM кода, после того, \r\nкак завершится загрузка страницы.  \r\nЛистинг 5.10. Функция addEvent, предназначенная для привязки обратного вызова к свойству \r\nwindow.onload \r\n// Ожидание загрузки страницы \r\n// (Используется addEvent, рассмотренная в следующей главе) \r\naddEvent(window, \"load\", function() { \r\n    // Выполнение HTML DOM-операций \r\n    next( id(\"everywhere\") ).style.background = 'blue'; \r\n});  \r\nМожет быть эта операция и проще всех, но она всегда будет и медленнее всех. Из очередности \r\nзагрузочных операций можно заметить, что завершение загрузки страницы — это самый последний выполняемый \r\nшаг. Это значит, что если у вас на странице существенное количество изображений, видеофрагментов и т.д., \r\nпользователи должны какое-то время ждать, пока, наконец, не будет выполнен код JavaScript.  \r\n","\r\n 86\r\nОжидание загрузки основной части DOM \r\nВторая методика носит слишком изощренный характер, и ее применение совершенно не рекомендуется. \r\nЕсли помните, в предыдущем разделе я сказал, что встроенные сценарии после того, как DOM будет выстроена. \r\nЭто верно лишь наполовину. Фактически сценарии выполняются по мере их обнаружения, когда DOM еще \r\nнаходится в процессе построения. Это значит, если сценарий встроен в страницу где-то посредине, то он будет \r\nиметь непосредственный доступ к первой половине DOM. Но если сценарий будет встроен в качестве последнего \r\nэлемента на странице, то вы получите доступ ко всем предыдущим элементам, имеющимся в DOM, давая вам \r\nхитрый способ имитировать DOM-загрузку. Реализация этого метода обычно выглядит так, как показано в \r\nлистинге 5.11.  \r\nЛистинг 5.11. Определение загрузки DOM путем вставки тега <script> (содержащего вызов функции) в \r\nконце HTML DOM \r\n<html> \r\n<head> \r\n    <title>Тестирование загрузки DOM</title> \r\n    <script type=\"text/javascript\"> \r\n       function init() { \r\n           alert( \"DOM загружен!\" ); \r\n           tag(\"h1\")[0].style.border = \"4px solid black\"; \r\n       } \r\n    </script> \r\n</head> \r\n<body> \r\n    <h1>Тестирование загрузки DOM</h1> \r\n    <!-- Основная часть HTML находится здесь --> \r\n    <script type=\"text/javascript\">init();</script> \r\n</body> \r\n</html>  \r\nВ этом примере сценарий встроен в DOM последним элементом; это будет последним элементом, который \r\nбудет подвергнут анализу и выполнению. Единственное, что здесь будет выполнено — это функция init, которая \r\nдолжна содержать любой связанный с DOM код, который нужно выполнить. Самая большая проблема, связанная с \r\nэтим решением заключается во вносимом им беспорядке: в HTML вносится дополнение только ради того, чтобы \r\nопределить, загружен ли DOM. Такая методика обычно считается внесением беспорядка, поскольку вы добавляете \r\nна веб-страницу дополнительный, ненужный код только для того, чтобы проверить состояние ее загрузки.  \r\nВычисление окончания загрузки DOM \r\nИ последняя методика, которая может быть использована для отслеживания загрузки DOM, является, \r\nнаверное, самой сложной (с точки зрения реализации), но также и наиболее эффективной. Вы получаете простоту \r\nпривязки к событию загрузки окна в сочетании со скоростью технологии встроенного сценария. \r\nЭта методика работает за счет контроля готовности необходимых вам свойств HTML DOM-документа с \r\nмаксимально возможной физической скоростью, без блокирования браузера. Есть несколько вещей, которые \r\nнужно проконтролировать, чтобы понять, что с HTML-документом уже можно работать:  \r\n1. document: Нужно посмотреть, существует ли уже DOM-документ. Если проверка проводится слишком рано, \r\nто скорее всего, будет получен неопределенный результат. \r\n","\r\n 87\r\n2. document.getElementsByTagName и document.getElementById: Нужно проверить, есть ли у документа часто \r\nиспользуемые функции getElementsByTagName и getElementById; эти функции будут существовать по их \r\nготовности к применению. \r\n3. document.body: Чтобы полностью удостовериться в готовности, нужно проверить, был ли полностью \r\nзагружен элемент <body>. Теоретически это должна отловить предыдущая проверка, но я обнаружил \r\nпримеры, в которой эта проверка не приводила к достаточно надежным результатам. \r\nИспользуя эти проверки вы получаете возможность получения достаточно четкой картины, показывающей, \r\nкогда модель DOM будет готова к использованию (Это вполне подходящий вариант, на который может быть \r\nзатрачено всего несколько миллисекунд). Этот метод практически безупречен. Используя только ранее \r\nперечисленные проверки, сценарий будет относительно хорошо работать на всех современных браузерах. Но \r\nнедавно, в связи с последними усовершенствованиями системы кэширования, осуществленными в Firefox, событие \r\nзагрузки окна может состояться еще до того, как ваш сценарий будет в состоянии определить, готов ли DOM к \r\nработе. Чтобы воспользоваться этим преимуществом, я также привязываю проверку к событию загрузки окна, в \r\nнадежде получить некоторое дополнительное ускорение. \r\nВ заключение функция domReady соберет ссылки на все функции, которые нужно запускать, когда DOM \r\nготова к работе. Как только можно будет считать, что DOM готова, перебираются все ссылки, и функции \r\nвыполняются одна за другой. В листинге 5.12 показана функция, которая может быть использована для слежения \r\nза тем, когда DOM будет полностью загружена.  \r\nЛистинг 5.12. Функция, предназначенная для отслеживания готовности DOM \r\nfunction domReady( f ) { \r\n    // Если DOM уже загружен, немедленно выполнить функцию \r\n    if ( domReady.done ) return f(); \r\n  \r\n    // Если мы уже дополнили функцию \r\n    if ( domReady.timer ) { \r\n       // внести ее в список исполняемых \r\n       domReady.ready.push( f ); \r\n    } else { \r\n       // Привязывание события завершения загрузки страницы, \r\n       // на тот случай если ее загрузка закончится первой. \r\n       // Здесь используется addEvent. \r\n       addEvent( window, \"load\", isDOMReady ); \r\n  \r\n       // Инициализация массива исполняемых функций \r\n       domReady.ready = [ f ]; \r\n  \r\n       // Проверка DOM на готовность, проводимая как можно быстрее \r\n       domReady.timer = setInterval( isDOMReady, 13 ); \r\n    } \r\n}  \r\n  \r\n// Проверка на готовность DOM к перемещению по ее структуре \r\nfunction isDOMReady() { \r\n    // Если мы уже определили готовность страницы — проигнорировать \r\n    // дальнейшее выполнение \r\n","\r\n 88\r\n    if ( domReady.done ) return false; \r\n  \r\n    // Проверка доступности некоторых функций и элементов \r\n    if ( document && document.getElementsByTagName && \r\n       document.getElementById && document.body ) { \r\n  \r\n       // Если они готовы, можно прекратить проверку \r\n       clearInterval( domReady.timer ); \r\n       domReady.timer = null; \r\n  \r\n       // Выполнение всех ожидавших функций \r\n       for ( var i = 0; i < domReady.ready.length; i++ ) \r\n           domReady.ready[i](); \r\n  \r\n       // Сохранение того, что только что было сделано \r\n       domReady.ready = null; \r\n       domReady.done = true; \r\n    } \r\n}  \r\nТеперь мы посмотрим, как это могло бы выглядеть в HTML-документе. Функция domReady должна быть \r\nиспользована, также, как используется функция addEvent (рассматриваемая в  главе 6), связывая запуск вашей \r\nконкретной функции с готовностью документа к перемещению по его элементам и обращению с ними. Для этого \r\nпримера я поместил функцию domReady во внешний файл JavaScript, названный domready.js. В листинге 5.13 \r\nпоказано, как можно воспользоваться новой функцией domReady для отслеживания загрузки DOM.  \r\nЛистинг 5.13. Использование функции domReady для определения готовности DOM к перемещениям по ее \r\nструктуре и внесению изменений  \r\n<html> \r\n<head> \r\n    <title>Тестирование загрузки DOM</title> \r\n    <script type=\"text/javascript\" src=\"domready.js\"></script> \r\n    <script type=\"text/javascript\"> \r\n      function tag(name, elem) { \r\n           // Если контекстный элемент не предоставлен, вести поиск по всему \r\n       // документу \r\n        return (elem || document).getElementsByTagName(name); \r\n      } \r\n  \r\n    domReady(function() { \r\n       alert( \"DOM загружен!\" ); \r\n       tag(\"h1\")[0].style.border = \"4px solid black\"; \r\n    }); \r\n    </script> \r\n</head> \r\n<body> \r\n    <h1>Тестирование загрузки DOM</h1> \r\n    <!-- Основная часть HTML находится здесь --> \r\n","\r\n 89\r\n</body> \r\n</html>  \r\nТеперь, когда вы узнали о нескольких способах перемещения по типичному DOM XML-документу, и как \r\nобойти сложности с загрузкой HTML DOM-документа, должен быть поставлен вопрос: нет ли каких-нибудь более \r\nподходящих способов обнаружения элементов в HTML-документе? К нашему удовольствию, на этот вопрос можно \r\nответить твердым «да». \r\nОбнаружение элементов в документе HTML \r\nЖелаемый порядок обнаружения элементов в HTML-документе часто сильно отличается от порядка, \r\nсвязанного с XML-документом. Это звучит несколько нелепо, учитывая, что современный HTML фактически \r\nявляется подмножеством XML; однако HTML-документ содержит ряд  существенных отличий, которыми можно \r\nвоспользоваться.  \r\nДля JavaScript/HTML-разработчика есть два наиболее известных преимущества: использование классов и \r\nзнание CSS-селекторов. С расчетом на их применение можно создать ряд мощных функций, упрощающих и \r\nпроясняющих перемещение по DOM.  \r\nОбнаружение элементов по имени класса \r\nОбнаружение элементов по имени их классов — довольно распространенная технология, \r\nпопуляризированная Симоном Уиллисоном (Simon Willison) (http://simon.incutio.com) в 2003 году и впервые \r\nпоказанная Эндрю Хэйуордом (Andrew Hayward) (http://www.mooncalf.me.uk). Эта технология довольно проста и \r\nпонятна: поиск ведется по всем элементам (или подмножеству элементов) в целях обнаружения тех из них, \r\nкоторые обладают указанным классом. Возможная реализация показана в листинге 5.14.  \r\nЛистинг 5.14. Функция, осуществляющая поиск всех элементов, имеющих определенное имя класса  \r\n  \r\nfunction hasClass(name,type) { \r\n    var r = []; \r\n    // Обнаружение имени класса (работает и при наличии \r\n    // нескольких имен класса) \r\n    var re = new RegExp(\"(^|\\\\s)\" + name + \"(\\\\s|$)\"); \r\n  \r\n    // Ограничение поиска элементами определенного типа \r\n// или поиск по всем элементам \r\nvar e = document.getElementsByTagName(type || \"*\"); \r\n    for ( var j = 0; j < e.length; j++ ) \r\n       // Если элемент имеет нужный класс, добавление его в \r\n       // возвращаемый массив \r\n       if ( re.test(e[j]) ) r.push( e[j] ); \r\n  \r\n    // Возвращение списка соответствующих элементов \r\n    return r; \r\n}  \r\nТеперь эту функцию можно использовать для быстрого обнаружения любого элемента или любого \r\nэлемента определенного типа (например, <li> или <p>), имеющего указанное имя класса. При указании названия \r\n","\r\n 90\r\nтегов, по которым ведется поиск, работа всегда будет вестись быстрее, чем при поиске по всем элементам (*), \r\nпоскольку элементов, которые нужно просмотреть в поиске нужных, будет меньше. Возьмем, к примеру, наш \r\nHTML-документ. Если нужно обнаружить все элементы, имеющие класс test, можно воспользоваться следующим \r\nкодом:  \r\nhasClass(\"test\"\")  \r\nЕсли нужно обнаружить только <li>-элементы, имеющие класс test, можно воспользоваться следующим \r\nкодом:  \r\nhasClass(\"test\",\"li\")  \r\nИ наконец, если нужно обнаружить первый <li>, имеющий класс test, можно воспользоваться следующим \r\nкодом:  \r\nhasClass(\"test\",\"li\")[0]  \r\nЭта функция и сама по себе обладает достаточной мощностью. Но если ее использовать в сочетании с \r\nметодами getElementById и getElementsByTagName, то получится мощный набор инструментов, который можно \r\nиспользовать для проведения  с DOM и более сложной работы.  \r\nОбнаружение элементов по селектору CSS \r\nБудучи веб-разработчиком, вы уже знаете способ выбора HTML-элементов: CSS-селекторы. CSS-\r\nселектор — это выражение, используемое для применения CSS-стилей к набору элементов. С каждой редакцией \r\nстандарта CSS (1, 2 и 3) к спецификации селекторов добавляются все новые и новые особенности, позволяющие \r\nразработчикам упростить обнаружение нужных элементов. К сожалению, разработчики браузеров совершенно не \r\nспешат с предоставлением полной реализации селекторов CSS 2 и 3, а значит, вы можете и не знать о некоторых \r\nинтересных возможностях, которые ими уже предоставлены. Если вы интересуетесь всеми новинками CSS, я \r\nрекомендую изучить W3C страницы, относящиеся к этой теме:  \r\n• Селекторы CSS 1: http://www.w3.org/TR/REC-CSS1#basic-concepts/ \r\n• Селекторы CSS 2: http://www.w3.org/TR/REC-CSS2/selector.html \r\n• Селекторы CSS 3: http://www.w3.org/TR/2005/WD-css3-selectors-20051215/ \r\nВ общем, свойства, доступные в каждой спецификации, схожи в том, что каждая последующая редакция \r\nсодержит также все свойства предыдущих. Но с каждой редакцией прибавляется и количество новых свойств. К \r\nпримеру, CSS 2 содержит атрибуты и дочерние селекторы, а CSS 3 предоставляет дополнительную языковую \r\nподдержку, выбор по типу атрибута и отрицание. Например, все эти выражения представляют из себя вполне \r\nдопустимые CSS-селекторы:  \r\n#main <div> p: Это выражение обнаруживает элемент с ID равным main, всех его потомков, являющихся \r\n<div>-элементами, а затем всех потомков, являющихся <p>-элементами. Оно является вполне допустимым \r\nселектором CSS 1. \r\ndiv.items > p: Это выражение обнаруживает все <div>-элементы, имеющие класс items, а затем \r\nобнаруживает все дочерние <p>-элементы. Оно является вполне допустимым селектором CSS 2. \r\ndiv:not(.items): Это выражение обнаруживает все <div>-элементы, у которых нет класса items. Оно \r\nявляется вполне допустимым селектором CSS 3. \r\nВозможно, у вас вызвало удивление, почему я рассматриваю CSS-селекторы, если фактически их нельзя \r\nиспользовать для обнаружения элементов (только для применения CSS-стилей). Но и в этой области некоторые \r\n","\r\n 91\r\nпредприимчивые разработчики сумели преодолеть стереотипы и создать реализации CSS-селекторов, способные к \r\nполноценной обработке в стиле всех редакций, от CSS 1 до CSS 3. Использование этих библиотек позволит легко \r\nи быстро выбрать любой элемент, и выполнить над ним какие-нибудь операции. \r\ncssQuery \r\nПервая общедоступная библиотека с полной поддержкой CSS 1–3 получившая  название cssQuery, была \r\nсоздана Дином Эдвардсом (Dean Edwards) (dean.edwards.name). Заложенный в нее замысел был довольно прост: \r\nвы предоставляете ей CSS-селектор, и cssQuery обнаруживает все соответствующие элементы. Кроме того, \r\ncssQuery разбита на несколько подбиблиотек, по одной для каждого уровня CSS-селекторов, и у вас есть \r\nвозможность при желании отключить поддержку CSS 3, если в ней нет необходимости. Эта выдающаяся и \r\nвсеобъемлющая библиотека работает на всех современных браузерах (Дин является сторонником \r\nкроссбраузерной поддержки). Для использования этой библиотеки вам нужно предоставить ей селектор, и \r\nдополнительно, контекстный элемент, в котором ведется поиск. Рассмотрим ряд примеров:  \r\n// Обнаружение всех <p>, дочерних по отношению к <div>-элементам \r\ncssQuery(\"div > p\"); \r\n  \r\n// Обнаружение всех <div>, <p> и <form>-элементов \r\ncssQuery(\"div,p,form\"); \r\n  \r\n// Обнаружение всех <p> и <div>-элементов, а затем обнаружение всех \r\n// <a>-элементов, которые находятся внутри них \r\nvar p = cssQuery(\"p,div\"); \r\ncssQuery(\"a\",p); \r\nВ результате выполнения функции cssQuery возвращается массив соответствующих элементов. Теперь вы \r\nможете проводить над ними какие-нибудь операции, как и в случает выполнения метода getElementsByTagName. \r\nНапример, чтобы добавить обрамление вокруг всех ссылок на Google, можно сделать следующее:  \r\n// Добавление обрамления вокруг всех ссылок на Google \r\nvar g = cssQuery(\"a[href^='google.com']\"); \r\nfor ( var i = 0; i < g.length; i++ ) { \r\n    g[i].style.border = \"1px dashed red\"; \r\n}  \r\nДополнительные сведения о cssQuery можно найти на веб-сайте Дина Эдвардса (Dean Edwards), там же \r\nможно загрузить и весь исходный код: http://dean.edwards.name/my/cssQuery/.  \r\nСОВЕТ \r\nДин Эдвардс — настоящий волшебник JavaScript; созданный им код просто поразителен. Я настоятельно \r\nрекомендую внимательно изучить его библиотеку cssQuery, или по крайней мере посмотреть, как на JavaScript \r\nпишется отлично расширяемый код.  \r\njQuery \r\nЭтот новичок в мире библиотек JavaScript, предоставляет некоторые совершенно новые способы \r\nнаписания кода. Сначала я приписывал ее к «простой» CSS-селекторной библиотеке, во многом похожей на \r\ncssQuery, пока Дин Эдвардс не выпустил свою выдающуюся библиотеку cssQuery, заставив этот код развиваться в \r\nнесколько  в ином направлении. Библиотека обеспечивает полную поддержку CSS 1–3 наряду с некоторыми \r\nосновными функциональными возможностями XPath. Но на первое вместо выходят дополнительные возможности \r\n","\r\n 92\r\nпо содействию перемещению по DOM и работе с ее объектами. Как и cssQuery, jQuery обладает полной \r\nподдержкой всех современных браузеров. Рассмотрим ряд примеров выборки элементов с использованием \r\nобычного для jQuery сочетания CSS и XPath:  \r\n// Обнаружение всех <div>-элементов, у которых имеется класс 'links', и \r\n// <p>-элементов внутри них \r\n$(\"div.links[p]\") \r\n  \r\n// Обнаружение всех потомков всех <p> и <div>-элементов \r\n$(\"p,div\").find(\"*\") \r\n  \r\n// Обнаружение каждой второй ссылки, указывающей на Google \r\n$(\"a[@href^='google.com']:even\")  \r\nДля использования результатов, полученных от jQuery, есть два варианта. Во-первых, можно \r\nвоспользоваться выражением $(“выражение”).get( ), чтобы получить массив соответствующих элементов — точно \r\nтакой же результат дает применение cssQuery. Во-вторых, можно воспользоваться специальными,  встроенными в \r\njQuery функциями для работы с CSS и с DOM. Итак, если вернуться к примеру с cssQuery по добавлению \r\nобрамления ко все ссылкам на Google, то можно сделать следующее:  \r\n// Добавление обрамления вокруг всех ссылок на Google \r\n$(\"a[@href^=google.com]\").css(\"border\",\"1px dashed red\");  \r\nВы можете найти документацию, множество демонстраций и примеров, а также получить возможность \r\nвыборочной загрузки на веб-сайте проекта jQuery: http://jquery.com/.  \r\nПРИМЕЧАНИЕ \r\nНужно отметить, что ни cssQuery, ни jQuery фактически не требуют для перемещений использования \r\nименно HTML-документа; они могут быть использованы с любым XML-документом. Для изучения разновидности \r\nперемещений, присущих только XML, прочитайте следующий раздел, посвященный XPath.  \r\nXPath \r\nВыражения XPath — невероятно мощный способ перемещений по XML-документам. С учетом многолетней \r\nистории существования, предполагается, что везде, где есть реализация DOM, где-то сразу за ней находится и \r\nXPath. Выражения XPath, даже при всем их многословии, намного мощнее всего, что может быть написано с \r\nиспользованием CSS-селектора. В таблице 5.1 показано построчное сравнение различных CSS-селекторов и \r\nXPath-выражений. \r\nТаблица 5.1. Сравнение селекторов CSS 3 и выражений XPath \r\nЦель CSS 3 XPath \r\nВсе элементы * //* \r\nВсе <p>-элементы P //p \r\nВсе дочерние элементы p > * //p/* \r\nЭлемент по его ID #foo //*[@id=‘foo’] \r\nЭлемент по его классу .foo //*[contains(@class,’foo’)] \r\nЭлемент с атрибутом *[title] //*[@title] \r\nПервый дочерний элемент всех <p>-p > *:first-        //p/*[0] \r\n","\r\n 93\r\nэлементов child \r\nВсе <p>-элементы , имеющие дочерние A Not possible //p[a] \r\nСледующий элемент p + * //p/following-\r\nsibling::*[0] \r\nЕсли вас заинтересовали предыдущие выражения, я рекомендую просмотреть две XPath-спецификации \r\n(хотя обычно в современных браузерах полностью поддерживается только XPath 1.0), чтобы получить \r\nпредставление о том, как работают эти выражения:  \r\n•  XPath 1.0: http://www.w3.org/TR/xpath/  \r\n•  XPath 2.0: http://www.w3.org/TR/xpath20/  \r\nЕсли вы хотите по-настоящему углубиться в эту тему, я рекомендую приобрести книгу издательства \r\nO’Reilly «XML in a Nutshell», написанную Эллиоттом Харольдом (Elliotte Harold) и Скоттом Минзом (Scott Means) \r\n(2004 г.), или книгу издательства Apress «Beginning XSLT 2.0: From Novice to Professional», написанную Джени \r\nТеннисон (Jeni Tennison) (2005 г.). В дополнение к этому есть несколько замечательных руководств, которые \r\nпомогут освоить использование XPath:  \r\n• W3Schools XPath Tutorial: http://w3schools.com/xpath/ \r\n• ZVON XPath Tutorial: http://zvon.org/xxl/XPathTutorial/General/examples.html \r\nВ настояшее время XPath не пользуется полной поддержкой в браузерах; для IE и Mozilla имеются полные \r\n(хотя и отличающиеся) реализации XPath, а версии для Safari и Opera находятся в стадии разработки. Чтобы \r\nобойти это обстоятельство существуют две XPath-реализации, написанные полностью на JavaScript. Вообще-то \r\nони довольно медлительны (по сравнению с реализациями на основе браузеров), но будут слаженно работать на \r\nвсех современных браузерах:  \r\n• XML for Script: http://xmljs.sf.net/  \r\n• Google AJAXSLT: http://goog-ajaxslt.sf.net/  \r\nВ дополнение к этому, проект под названием Sarissa (http://sarissa.sf.net/) нацелен на создание общей \r\nнадстройки над каждой браузерной реализацией. Это может дать возможность однократного создания кода, \r\nсвязанного с доступом к XML, сохраняя при этом скоростные преимущества от использования поддерживаемого \r\nбраузером XML-парсинга. Самая большая проблема, связанная с применением этой технологии — сохраняющаяся \r\nдо сих пор слабая поддержка XPath в браузерах Opera и Safari, устраненная в предыдущих реализациях XPath. \r\nВообще-то технология использования встроенного в браузер XPath рассматривается как \r\nэкспериментальная  по сравнению с имеющими широкую поддержку решениями на основе JavaScript. Тем не \r\nменее, объем использования и популярность XPath только возрастают, и эту технологию определенно нужно \r\nрассматривать в качестве претендента на трон CSS-селектора.  \r\nТеперь, когда вы располагаете знаниями и инструментарием, необходимым для обнаружения любого DOM-\r\nэлемента, или даже набора DOM-элементов, настало время рассмотреть, куда всю эту мощь можно применить. \r\nВозможно все, от работы с атрибутами и до добавления и удаления DOM-элементов.  \r\nПолучение содержимого элемента \r\nСодержимое всех DOM-элементов может быть одним из трех вариантов: текста, дополнительных элементов \r\nили сочетания текста и элементов. Вообще-то, наиболее часто встречаются первый и второй варианты. В этом \r\nразделе мы собираемся рассмотреть распространенные способы извлечения содержимого элементов.  \r\n","\r\n 94\r\nПолучение текста, находящегося внутри элемента \r\nВозможно, для тех, кто плохо знаком с DOM, задача получения текста, находящегося внутри элемента \r\nявляется довольно запутанной. Тем не менее, это такая же задача, связанная с работой с HTML DOM- и XML DOM-\r\nдокументами, поэтому если вы узнаете о том, как это, расставит все по своим местам. В примере DOM-структуры, \r\nпоказанной на рис. 5.3, имеется корневой <p>-элемент, который содержит элемент <strong> и блок текста. \r\nЭлемент <strong> сам по себе тоже содержит блок текста.  \r\n \r\nРис. 5.3. Пример DOM-структуры, содержащей как элементы, так и текст  \r\nПосмотрим, как можно получить текст из каждого из этих элементов. Легче начать с элемента <strong>, \r\nпоскольку в нем, кроме текстового узла ничего не содержится.  \r\nСледует заметить, что существует свойство под названием innerText, которое захватывает текст внутри \r\nэлемента на тех браузерах, которые не работают на движке Mozilla. Для нашей задачи это очень удобно. К \r\nсожалению, поскольку это свойство не работает на существенной части парка браузеров, и не работает в XML \r\nDOM-документах, нужно рассмотреть жизнеспособные альтернативы.  \r\nВесь фокус получения текстового содержимого элемента состоит в том, что нужно помнить, что, как ни \r\nстранно, текст не содержится непосредственно внутри элемента, он содержится в дочернем текстовом узле. То \r\nесть предполагается, что переменная strongElem содержит ссылку на элемент <strong>. В листинге 5.15 показано, \r\nкак извлечь текст из элемента, используя DOM.  \r\nЛистинг 5.15.Получение текстового содержимого элемента <strong> \r\n","\r\n 95\r\n// На браузерах, не связанных с движком Mozilla: \r\nstrongElem.innerText \r\n  \r\n// На всех платформах: \r\nstrongElem.firstChild.nodeValue  \r\nТеперь, когда мы узнали, как получить текстовое содержимое из отдельного элемента, нужно посмотреть, \r\nкак получить объединенное текстовое содержимое элемента <p>. В процессе решения этой задачи вы можете \r\nтакже разработать универсальную функцию для получения текстового содержимого любого элемента, независимо \r\nот того, что в нем фактически содержится, что и показано в листинге 5.16. Вызов вида text(элемент) вернет \r\nстроку, в которой содержится объединенное текстовое содержимое элемента и всех содержащихся в нем  \r\nдочерних элементов.  \r\nЛистинг 5.16. Универсальная функция для извлечения текстового содержимого из элемента  \r\nfunction text(e) { \r\n    var t = \"\"; \r\n  \r\n    // Если элемент был передан, получение его дочерних элементов \r\n    // иначе, предположение о том, что передан массив \r\n    e = e.childNodes || e; \r\n  \r\n    // Просмотр всех дочерних узлов \r\n    for ( var j = 0; j < e.length; j++ ) { \r\n       // Если это не элемент, присоединить его текстовое значение \r\n       // Иначе, провести рекурсивный перебор всех дочерних составляющих \r\n       // элемента \r\n       t += e[j].nodeType != 1 ? \r\n           e[j].nodeValue : text(e[j].childNodes); \r\n    } \r\n    // Возвращение соответствующего текста \r\n    return t; \r\n}  \r\n  \r\nИмея функцию, которая может быть использована для получения текстового содержимого любого \r\nэлемента, вы можете извлечь текстовое содержимое элемента <p>, использованного в предыдущем примере. Код \r\nдля выполнения этой задачи выглядит следующим образом:  \r\n// Получение текстового содержимого элемента <p> \r\ntext( pElem ); \r\nОсобенно приятно узнать, что эта функция гарантированно работает как с HTML, так и с XML DOM-\r\nдокументами, то есть теперь у вас есть совместимый способ  извлечения текстового содержимого любого \r\nэлемента.  \r\nПолучение HTML, находящегося внутри элемента \r\nВ отличие от получения текста, находящегося внутри элемента, получения находящегося внутри него \r\nHTML — одна из самых простых из выполняемых DOM-задач. К счастью, благодаря свойству, разработанному \r\n","\r\n 96\r\nкомандой Internet Explorer, все современные браузеры теперь включают дополнительное свойство для каждого \r\nHTML DOM-элемента: innerHTML. Благодаря этому свойству вы можете получить весь HTML и текст, находящиеся \r\nвнутри элемента. К тому же, свойство innerHTML работает очень быстро — зачастую намного быстрее, чем \r\nпроведение рекурсивного поиска для обнаружения всего текстового содержимого элемента. Однако не все так \r\nрадужно. Как именно реализовать свойство innerHTML, зависит от браузера, и, поскольку, единых стандартов для \r\nэтого не существует, браузер может вернуть любой, соответствующий его понятиям контекст. Рассмотрим, к \r\nпримеру, некоторые из тех, довольно странных ошибок, которые должны быть вами учтены при использовании \r\nсвойства innerHTML:  \r\n• Браузеры, основанные на движке Mozilla, не возвращают при использовании свойства innerHTML \r\nэлементов <style>.  \r\n• Internet Explorer возвращает свои элементы с использованием только заглавных букв, что при поиске \r\nкакой-то последовательности может сорвать ваши планы.  \r\n• Свойство innerHTML постоянно доступно только как свойство элементов HTML DOM-документов; попытка \r\nиспользовать его в XML DOM-документах приводит к извлечению нулевых значений.  \r\nИспользование свойства innerHTML не вызывает затруднений; обращение к свойству дает вам строку, в \r\nкоторое находится HTML- содержимое элемента. Если элемент не содержит каких-либо подэлементов, а содержит \r\nтолько текстовое наполнение, возвращаемая строка будет содержать только текст. Чтобы посмотреть, как это \r\nработает, мы изучим два элемента, показанные на рис. 5.3:  \r\n// Получение внутреннего HTML — innerHTML — элемента <strong> \r\n// должно вернуть \"Hello\" \r\nstrongElem.innerHTML \r\n  \r\n// Получение внутреннего HTML — innerHTML — элемента <p> \r\n// должно вернуть \"<strong>Hello</strong> how are you doing?\" \r\npElem.innerHTML \r\nЕсли вы уверены в том, что элемент не содержит ничего, кроме текста, этот метод может служить как \r\nсамый простой заменитель трудностям получения текста, содержащегося в элементе. С другой стороны, наличие \r\nвозможности извлечения HTML-контента из элементов означает, что теперь вы можете создавать необычные \r\nдинамические приложения, в которых применяется правка по месту. Более подробно разговор на эту тему будет \r\nвестись в главе 10.  \r\nРабота с атрибутами элементов \r\nЗа извлечением содержимого элементов следующей наиболее часто совершаемой операцией является \r\nполучение и установка значения атрибутов элементов. Как привило, список имеющихся у элемента атрибутов \r\nпредварительно загружается с информацией, собранной из XML-представления самого элемента и сохраненной \r\nдля последующего доступа в ассоциативном массиве, как в следующем примере фрагмента HTML, находящегося \r\nвнутри веб-страницы:  \r\n<form name=\"myForm\" action=\"/test.cgi\" method=\"POST\"> \r\n    ... \r\n</form>  \r\nПосле загрузки в DOM  и в переменную formElem, HTML элемент form будет иметь ассоциативный массив, \r\nиз которого можно получить атрибуты в виде пар имя-значение. Результат этой работы выглядит следующим \r\nобразом:  \r\n","\r\n 97\r\nformElem.attributes = { \r\n    name: \"myForm\", \r\n    action: \"/test.cgi\", \r\n    method: \"POST\" \r\n};  \r\nОпределение существования атрибутов элемента с использованием массива атрибутов должно быть \r\nабсолютно тривиальной задачей, но есть одна проблема: по какой-то причине Safari это не поддерживаетs. Но и \r\nэто еще не все, потенциально полезная функция hasAttribute не поддерживается в Internet Explorer. Так как же \r\nвсе-таки определить наличие атрибутов? Один из возможных способов показан в листинге 5.17, и заключается в \r\nиспользовании функции getAttribute (речь о которой пойдет в следующем разделе) с проверкой, не вернула ли \r\nона нулевое значение.  \r\nЛистинг 5.17. Определение наличия у элемента конкретного атрибута  \r\nfunction hasAttribute( elem, name ) { \r\n    return elem.getAttribute(name) != null; \r\n}  \r\nТеперь, имея в арсенале эту функцию, и зная, как используются атрибуты, вы готовы приступить к \r\nизвлечению и установке значений атрибутов.  \r\nПолучение и установка значений атрибута \r\nДля извлечения принадлежащих атрибутам данных из элемента существуют два различных метода, \r\nприменение которых зависит от типа используемого вами DOM-документа. Если вы хотите обезопасить себя от \r\nнеожиданностей и всегда использовать универсальные, совместимые с XML DOM методы, то это — getAttribute и \r\nsetAttribute. Они могут быть использованы следующим образом:  \r\n// Получение атрибута \r\nid(\"everywhere\").getAttribute(\"id\") \r\n  \r\n// Установка значения атрибута \r\ntag(\"input\")[0].setAttribute(\"value\",\"Your Name\");  \r\n  \r\nВ дополнение к этой стандартной паре getAttribute-setAttribute, HTML DOM-документы обладают \r\nспециальным набором свойств, которые работают с атрибутами в качестве быстрых извлекателей-установщиков. \r\nОни доступны во всех современных реализациях DOM (но гарантированно работают лишь в HTML DOM-\r\nдокументах), поэтому их использование может дать вам большие преимущества в написании компактного кода. В \r\nследующем коде показывается, как можно использовать свойства DOM доступа к DOM-атрибутам и установки их \r\nзначений:  \r\n// Быстрое получение атрибута \r\ntag(\"input\")[0].value \r\n  \r\n// Быстрая установка значения атрибута \r\ntag(\"div\")[0].id = \"main\"; \r\nПри работе с атрибутами существует несколько странных случаев, о которых вы должны знать. Один из \r\nних чаще всего возникает при доступе к атрибуту имени класса. Чтобы работать с именами классов одинаково на \r\n","\r\n 98\r\nвсех браузерах, нужно использовать для обращения к ним свойство className, используя выражение \r\nelem.className, и не использовать более соответствующее по названию выражение getAttribute(“class”). Такая же \r\nпроблема возникает и с атрибутом for, который был переименован в htmlFor. К тому же существуют проблемы и \r\nдвумя CSS-атрибутами: cssFloat и cssText. Это своеобразное соглашение об именах возникло из-за того, что такие \r\nслова, как class, for, float и text являются в JavaScript зарезервированными словами.  \r\nЧтобы обойти все эти странные случаи и упростить весь процесс работы с получением и установкой \r\nнужных атрибутов, нужно воспользоваться функцией, которая возьмет для вас все эти заботы на себя. В \r\nлистинге 5.18 показывается функция для получения и установки значений атрибутов элементов. Вызов этой \r\nфункции с двумя параметрами, к примеру, attr(element, id), приведет к возврату значения указанного атрибута. \r\nЕсли вызвать функцию с тремя параметрами, к примеру, attr(element, class, test), то будет установлено значение \r\nатрибута и возвращено его новое значение.  \r\nЛистинг 5.18. Получение и установка значений атрибутов элементов  \r\nfunction attr(elem, name, value) { \r\n    // Гарантирование допустимости предоставленного имени \r\n    if ( !name || name.constructor != String ) return ''; \r\n  \r\n    // Определение, не относится ли это имя к тем самым «роковым» \r\n    // именам \r\n    name = { 'for': 'htmlFor', 'class': 'className' }[name] || name; \r\n  \r\n    // Если пользователь устанавливает значение, то также \r\n    if ( typeof value != 'undefined' ) { \r\n       // сначала установить быстрый способ \r\n       elem[name] = value; \r\n  \r\n       // По возможности воспользоваться setAttribute \r\n       if ( elem.setAttribute ) \r\n           elem.setAttribute(name,value); \r\n    } \r\n  \r\n    // Вернуть значение атрибута \r\n    return elem[name] || elem.getAttribute(name) || ''; \r\n}  \r\nНаличие стандартного способа для доступа к атрибутам и их изменения, независимо от их реализации, \r\nявляется довольно мощным инструментом. В листинге 5.19 показано несколько примеров использования функции \r\nattr в некоторых часто встречающихся ситуациях для упрощения работы с атрибутами.  \r\nЛистинг 5.19. Использование функции attr для установки и извлечения значений атрибутов из DOM-\r\nэлементов  \r\n// Установка атрибута class для первого <h1>-элемента \r\nattr( tag(\"h1\")[0], \"class\", \"header\" ); \r\n  \r\n// Установка значения для каждого элемента <input> \r\nvar input = tag(\"input\"); \r\n","\r\n 99\r\nfor ( var i = 0; i < input.length; i++ ) { \r\n    attr( input[i], \"value\", \"\" ); \r\n} \r\n  \r\n// Добавление обрамления к элементу <input>, у которого атрибут name \r\n// имеет значение 'invalid' \r\nvar input = tag(\"input\"); \r\nfor ( var i = 0; i < input.length; i++ ) { \r\n    if ( attr( input[i], \"name\" ) == 'invalid' ) { \r\n       input[i].style.border = \"2px solid red\"; \r\n    } \r\n}  \r\nДо сих пор я рассматривал обычно используемые в DOM атрибуты (например, ID, class, name и т.д.), \r\nзначение которых можно получать и устанавливать. Но технология установки и получения  нетрадиционных \r\nатрибутов была бы тоже очень полезна. К примеру, вы можете добавить новый атрибут (который будет виден \r\nтолько при доступе к DOM-версии элемента) а затем, чуть позже, снова его извлечь, и все это без модификации \r\nфизических свойств документа. Предположим, к примеру, что вам нужен список элементов с их определениями, в \r\nкотором по щелчку на элементе ему давалось бы развернутое определение. Код HTML для этой конструкции \r\nимел бы вид, показанный в листинге 5.20.  \r\nЛистинг 5.20. HTML-документ со списком определений, скрытых от просмотра  \r\n<html> \r\n<head> \r\n    <title>Раскрываемый список определений</title> \r\n    <style>dd { display: none; }</style> \r\n</head> \r\n<body> \r\n    <h1>Раскрываемый список определений</h1> \r\n    <dl> \r\n       <dt>Коты</dt> \r\n       <dd>Пушистые, дружелюбные создания.</dd> \r\n       <dt>Собака</dt> \r\n       <dd>Любят заигрывать и крутиться вокруг человека.</dd> \r\n       <dt>Мыши</dt> \r\n       <dd>Коты любят их есть.</dd> \r\n    </dl> \r\n</body> \r\n</html>  \r\nПодробности, касающиеся событий, будут рассмотрены в главе 6, а пока я попытаюсь сохранить простоту \r\nнашего кода обработки событий. Далее следует небольшой сценарий, позволяющий щелкать на определяемых \r\nтерминах и показывать (или скрывать) их определения. Этот сценарий должен быть включен в заголовок вашей \r\nстраницы или в этот заголовок должен быть включен внешний файл с этим сценарием. В листинге 5.21 показан \r\nкод, необходимый для построения раскрываемого списка определений.  \r\nЛистинг 5.21. Сценарий, позволяющий осуществлять динамическое включение и выключение определений  \r\n  \r\n","\r\n 100\r\n// Ожидание готовности DOM к работе \r\ndomReady(function(){ \r\n  \r\n    // Поиск всех определяемых терминов \r\n    var dt = tag(\"dt\"); \r\n    for ( var i = 0; i < dt.length; i++ ) { \r\n  \r\n       // Отслеживание щелчка пользователя на термине \r\n       addEvent( dt[i], \"click\", function() { \r\n  \r\n           // Проверка, раскрыто определение или нет \r\n           var open = attr( this, \"open\" ); \r\n  \r\n           // Переключение отображения определения \r\n           next( this ).style.display = open ? 'none' : 'block'; \r\n  \r\n           // Запоминание того, что определение раскрыто \r\n           attr( this, \"open\", open ? '' : 'yes' ); \r\n       }); \r\n    } \r\n});  \r\nТеперь, когда вы знаете, как перемещаться по DOM, и как исследовать и изменять атрибуты, нужно \r\nизучить, как создавать новые DOM-элементы, вставлять их куда угодно, и удалять те элементы, которые уже не \r\nнужны.  \r\nМодификация DOM \r\nЗная, как модифицировать DOM, вы можете делать все, от создания налету собственных XML-документов \r\nдля построения динамических форм, которые приспосабливаются к пользовательскому вводу; вы обретаете \r\nпрактически безграничные возможности. Модификация DOM постигается в три этапа: сначала нужно изучить, как \r\nсоздавать новый элемент, потом нужно изучить, как его вставлять в DOM, а затем нужно изучить как его оттуда \r\nизвлечь.  \r\nСоздание узлов с использованием DOM \r\nОсновной метод, стоящий за модификацией DOM, состоит в использовании функции createElement, \r\nкоторая дает возможность создания нового элемента на лету. Но этот новый элемент при создании не вставляется \r\nнемедленно в DOM (что часто ставит в тупик тех, кто только начинает работать с DOM). Сначала я сосредоточу \r\nвнимание на создании DOM-элемента.  \r\nМетод createElement принимает один параметр, название тега элемента, и возвращает виртуальное DOM-\r\nпредставление этого элемента — без каких-либо включенных в него атрибутов или стилевых установок. Если вы \r\nразрабатываете приложение, использующее сгенерированные с помощью XSLT XHTML-страницы (или XHTML-\r\nстраницы, снабженные точным типом контента), то вам нужно помнить, что вы фактически используете XML-\r\nдокумент, и что ваши элементы нуждаются в наличии связанного сними соответствующего пространства имен \r\nXML. Чтобы беспроблемно обойти это обстоятельство, у вас должна быть простая функция, которая сможет \r\nспокойно протестировать, имеет ли используемый вами HTML DOM-документ возможность создания новых \r\nэлементов с пространством имен (свойство, присущее XHTML DOM-документам). Если дело обстоит именно таким \r\nобразом, вы можете создать новый DOM-элемент с соответствующим пространством имен XHTML, как это показано \r\nв листинге 5.22.  \r\n","\r\n 101\r\nЛистинг 5.22. Универсальная функция для создания нового DOM-элемента  \r\nfunction create( elem ) { \r\n    return document.createElementNS ? \r\n       document.createElementNS( 'http://www.w3.org/1999/xhtml', elem ) : \r\n       document.createElement( elem ); \r\n}  \r\nИспользуя предыдущую функцию, вы можете, к примеру, создать простой <div>-элемент и присоединить к \r\nнему дополнительную информацию:  \r\nvar div = create(\"div\"); \r\ndiv.className = \"items\"; \r\ndiv.id = \"all\";  \r\nВ дополнение нужно заметить, что существует DOM-метод, предназначенный  для создания новых \r\nтекстовых узлов, который называется createTextNode. Он принимает единственный аргумент, текст, который \r\nдолжен появиться внутри узла, и возвращает созданный текстовый узел.  \r\nТеперь, используя только что созданные DOM-элементы и текстовые узлы, вы можете вставить их в DOM-\r\nдокументы, именно туда, где они нужны.  \r\nВставка в DOM \r\nВставка в DOM —  дело весьма непростое, и временами вставит в тупик даже опытных пользователей DOM. \r\nДля его осуществления в арсенале разработчиков есть две функции.  \r\nПервая из них, insertBefore, позволяет вставлять элемент перед следующим дочерним элементом. При ее \r\nиспользовании это выглядит примерно следующим образом:  \r\nродительскийУзелПредыдущегоУзла.insertBefore( вставляемыйУзел, \r\n                                                   предыдущийУзел );  \r\nМнемоническое правило, которое я использую, чтобы запомнить порядок следования аргументов \r\nвыражается фразой: «Вставляем первый элемент перед вторым». Совсем скоро я покажу вам более простой \r\nспособ, как это запомнить.  \r\nТеперь, имея в своем распоряжении функцию для вставки узлов (речь идет как об элементах, так и о \r\nтекстовых узлах) перед другими узлами, вы можете задаться вопросом: «А как же вставить узел в качестве \r\nпоследнего дочернего узла?». Для этого существует другая функция под названием appendChild, позволяющая \r\nвыполнить эту задачу. Функция appendChild вызывается для элемента,  добавляемого к определенному узлу в \r\nсамый конец списка его дочерних узлов. Использование этой функции выглядит следующим образом:  \r\nродительскийЭлемент.appendChild( вставляемыйУзел );  \r\nЧтобы избавиться от необходимости вспоминать конкретный порядок аргументов в функциях insertBefore и \r\nappendChild, можно воспользоваться двумя вспомогательными функциями, которые были созданы мной для \r\nрешения этой проблемы. Использование новых функций показано в листингах 5.23 и 5.24, в них порядок вызова \r\nаргументов дается относительно того узла (элемента), в который производится вставка, после чего указывается \r\nвставляемый  элемент (узел). Дополнительно функция before позволяет предоставить необязательный \r\nродительский элемент, что потенциально приводит к сокращению кода. И наконец, обе эти функции позволяют \r\nпередавать им сроку для вставки (дополнения), которая будет автоматически превращена для вас в текстовый \r\n","\r\n 102\r\nузел. Рекомендуется, чтобы родительский элемент передавался в виде ссылки (на тот случай, если он имеет \r\nзначение null).  \r\nЛистинг 5.23. Функция для вставки элемента перед другим элементом  \r\nfunction before( parent, before, elem ) { \r\n    // Выяснение, предоставлен ли родительский (parent) узел \r\n    if ( elem == null ) { \r\n       elem = before; \r\n       before = parent; \r\n       parent = before.parentNode; \r\n    } \r\n    parent.insertBefore( checkElem( elem ), before ); \r\n}  \r\nЛистинг 5.24. Функция добавления элемента в качестве дочернего к другому элементу  \r\nfunction append( parent, elem ) { \r\n    parent.appendChild( checkElem( elem ) ); \r\n}  \r\nВспомогательная функция, показанная в листинге 5.25 облегчает вам вставку как элемента, так и текста \r\n(который автоматически превращается в нормальный текстовый узел).  \r\nЛистинг 5.25. Вспомогательная функция для функций before и append \r\n  \r\nfunction checkElem( elem ) { \r\n    // Если предоставлена только строка, превращение ее в текстовый узел \r\n    return elem && elem.constructor == String ? \r\n       document.createTextNode( elem ) : elem; \r\n}  \r\nТеперь, используя функции before и append, и создавая новые DOM-элементы, вы можете пополнять DOM \r\nинформацией, доступной для пользовательского просмотра (см. листинг 5.26).  \r\nЛистинг 5.26. Использование функций append и before \r\n  \r\n// Создание нового <li>-элемента \r\nvar li = create(\"li\"); \r\nattr( li, \"class\", \"new\" ); \r\n  \r\n// Создание текстового содержимого и добавление его к <li> \r\nappend( li, \"Спасибо за то, что вы посетили наш сайт!\" ); \r\n  \r\n// Добавление <li> в верхнюю строку первого упорядоченного списка \r\nbefore( first( tag(\"ol\")[0] ), li ); \r\n  \r\n// Запуск этого оператора превратит пустой элемент <ol> \r\n","\r\n 103\r\n<ol></ol> \r\n  \r\n// в следующий: \r\n<ol> \r\n    <li class='new'>Спасибо за то, что вы посетили наш сайт!</li> \r\n</ol>  \r\nКак только вы вставите эту информацию в DOM (используя либо insertBefore, либо appendChild) она будет \r\nтот час же выведена на экран на обозрение пользователя. Поэтому вы можете воспользоваться этим \r\nобстоятельством для предоставления мгновенного отклика на его действия. Это особенно полезно для \r\nинтерактивных приложений, в которых требуется пользовательский ввод.  \r\nТеперь, посмотрев как создавать и вставлять узлы с применением исключительно DOM-методов, будет \r\nособенно полезно посмотреть на альтернативные методы вставки в DOM какого-нибудь содержимого.  \r\nВставка в DOM кода HTML \r\nТехнология непосредственной вставки HTML в документ имеет даже большую популярность, чем создание \r\nи вставка в DOM  обычных DOM-элементов. Проще всего для этого воспользоваться упоминавшимся ранее \r\nметодом innerHTML. Вдобавок к тому, что он является способом извлечения HTML, находящегося внутри элемента, \r\nон также предоставляет способ установки HTML внутри элемента. В качестве примера простоты его использования \r\nдавайте представим, что у нас есть пустой элемент <ol>, к которому нужно добавить несколько элементов <li>. \r\nКод, выполняющий это действие, может выглядеть следующим образом:  \r\n// Добавление нескольких LI к OL-элементу \r\ntag(\"ol\")[0].innerHTML = \"<li>Коты.</li><li>Собаки.</li><li>Мыши.</li>\";  \r\nПравда же, это намного проще, чем упорно создавать несколько DOM-элементов и связанные с ними \r\nтекстовые узлы? Вас может также обрадовать известие (соответствующее информации на http://www. \r\nquirksmode.org) что этот способ еще и быстрее работает, чем использование методов DOM. Но, не все так \r\nбезоблачно — еще существует ряд коварных проблем, возникающих при использовании метода вставки \r\ninnerHTML:  \r\n• Как уже ранее упоминалось, метод innerHTML отсутствует XML DOM-документах, значит, в этих документах \r\nвам придется и дальше пользоваться традиционными  DOM-методами создания узлов и элементов.  \r\n• XHTML-документы, созданные с использованием XSLT, который находится на стороне клиента, не имеют \r\nметода innerHTML, поскольку они тоже относятся к XML-документам. \r\n• Метод innerHTML полностью удаляет любые узлы, которые уже существуют внутри элемента, значит, \r\nспособ последовательного добавления или вставки впереди существующего содержимого, существующий в \r\nDOM-методах, в нем отсутствует.  \r\nПоследний пункт особенно огорчает, поскольку вставка впереди или добавление к концу дочернего списка \r\nдругого элемента — весьма полезное свойство. И все-таки, применив магию DOM, вы можете приспособить наши \r\nметоды append и before для работы с обычными HTML-строками в дополнение к работе с обычными DOM-\r\nэлементами. Перемены осуществляются в два этапа. Сначала создается новая функция checkElem, показанная в \r\nлистинге 5.27, которая способна обрабатывать HTML-строки, DOM-элементы и массивы DOM-элементов.  \r\nЛистинг 5.27. Преобразование массива, представляющего смесь из DOM-узлов и HTML-строк в настоящий \r\nмассив DOM-узлов  \r\nfunction checkElem(a) { \r\n    var r = []; \r\n","\r\n 104\r\n    // Превращение аргумента в массив, если он еще им не является \r\n    if ( a.constructor != Array ) a = [ a ]; \r\n  \r\n    for ( var i = 0; i < a.length; i++ ) { \r\n       // Если это строка \r\n       if ( a[i].constructor == String ) { \r\n           // Создание временного элемента для помещения в него HTML \r\n           var div = document.createElement(\"div\"); \r\n  \r\n           // Вставка HTML, для превращения его в DOM-структуру \r\n           div.innerHTML = a[i]; \r\n  \r\n           // Обратное извлечение DOM-структуры из временного DIV-элемента \r\n           for ( var j = 0; j < div.childNodes.length; j++ ) \r\n               r[r.length] = div.childNodes[j]; \r\n       } else if ( a[i].length ) { // Если это массив \r\n           // Предположение, что это массив DOM-узлов \r\n           for ( var j = 0; j < a[i].length; j++ ) \r\n               r[r.length] = a[i][j]; \r\n       } else { // Иначе, предположение, что это DOM-узел \r\n           r[r.length] = a[i]; \r\n       } \r\n    } \r\n    return r; \r\n}  \r\nЗатем, как показано в листинге 5.28, нужно приспособить две функции вставки к работе с этой \r\nмодификацией checkElem.  \r\nЛистинг 5.28. Усовершенствованные функции для вставки и добавления в DOM  \r\nfunction before( parent, before, elem ) { \r\n    // Выяснение, предоставлен ли родительский (parent) узел \r\n    if ( elem == null ) { \r\n       elem = before; \r\n       before = parent; \r\n       parent = before.parentNode; \r\n    } \r\n  \r\n    // Получение нового массива элементов \r\n    var elems = checkElem( elem ); \r\n  \r\n    // Обратный перебор элементов массива, \r\n    // поскольку мы добавляем элементы к началу \r\n    for ( var i = elems.length - 1; i >= 0; i-- ) { \r\n       parent.insertBefore( elems[i], before ); \r\n    } \r\n} \r\n  \r\n","\r\n 105\r\nfunction append( parent, elem ) { \r\n    // Получение массива элементов \r\n    var elems = checkElem( elem ); \r\n  \r\n    // Добавление всех элементов к родительскому элементу \r\n    for ( var i = 0; i <= elems.length; i++ ) { \r\n       parent.appendChild( elems[i] ); \r\n    } \r\n} \r\n  \r\nТеперь, с использованием этих новых функций, добавление <li> в упорядоченный список становится \r\nневероятно простой задачей:  \r\nappend( tag(\"ol\")[0], \"<li>Мышеловка.</li>\" ); \r\n  \r\n// Выполнение этой простой строки может добавить дополнительный HTML в этот <ol>-список \r\n<ol> \r\n    <li>Коты.</li> \r\n    <li>Собаки.</li> \r\n    <li>Мыши.</li> \r\n</ol> \r\n  \r\n// превращая его в следующий список: \r\n<ol> \r\n    <li>Коты.</li> \r\n    <li>Собаки.</li> \r\n    <li>Мыши.</li> \r\n    <li>Мышеловки.</li> \r\n</ol> \r\n  \r\n// А выполнение простого оператора, использующего функцию before \r\nbefore( last( tag(\"ol\")[0] ), \"<li>Зебры.</li>\" ); \r\n  \r\n// Превратит <ol> в: \r\n<ol> \r\n    <li>Коты.</li> \r\n    <li>Собаки.</li> \r\n    <li>Зебры.</li> \r\n    <li>Мыши.</li> \r\n</ol>  \r\nБлагодаря применению этой технологии ваш код становиться намного компактнее и пригоднее к \r\nразработке. А если вам захочется развернуться в обратную сторону, и удалить узлы из DOM? Как всегда, для \r\nэтого найдется другой метод.  \r\nУдаление узлов из DOM \r\nУдаление узлов из DOM случается едва ли не чаще, чем их создание и вставка. К примеру, при создании \r\nдинамической формы, запрашивающей ввод неограниченного количества элементов, становится важным \r\n","\r\n 106\r\nразрешить пользователям удалять ту часть страницы, с которой они больше не желают работать. Возможность \r\nудаления узла заложена в одну функцию: removeChild. Она используется точно так же, как и функция \r\nappendChild, но имеет обратный эффект. Ее использование выглядит примерно так:  \r\nРодительскийУзел.removeChild( УдаляемыйУзел );  \r\nС расчетом на нее, вы можете создать две отдельные функции для быстрого удаления узлов. Одна из них \r\nпоказана в листинге 5.29.  \r\nЛистинг 5.29. Функция для удаления узла из DOM  \r\n// Удаление из DOM отдельного узла \r\nfunction remove( elem ) { \r\n    if ( elem ) elem.parentNode.removeChild( elem ); \r\n}  \r\nВ листинге 5.30 показана функция для удаления из элемента всех дочерних узлов, в которой используется \r\nтолько одна ссылка на DOM-элемент.  \r\nЛистинг 5.30. Функция для удаление из элемента всех дочерних узлов \r\n// Удаление из DOM всех дочерних узлов элемента \r\nfunction empty( elem ) { \r\n    while ( elem.firstChild ) \r\n       remove( elem.firstChild ); \r\n}  \r\nПредставим, к примеру, что вам нужно удалить тот элемент <li>, который вы добавили в предыдущем \r\nразделе, предполагая, что вы дали пользователю возможность как следует рассмотреть этот <li>, и он может быть \r\nудален без всяких последствий. Следующий пример показывает, что для получения желаемого результата вы \r\nможете воспользоваться кодом JavaScript:  \r\n// Удаление последнего <li> из <ol> \r\nremove( last( tag(\"ol\")[0] ) ) \r\n \r\n// Приведенный выше код превратит этот фрагмент: \r\n \r\n<ol> \r\n    <li>Учите Javascript.</li> \r\n    <li>???</li> \r\n    <li>Получите прибыль!</li> \r\n</ol> \r\n  \r\n// в этот: \r\n<ol> \r\n    <li>Учите Javascript.</li> \r\n    <li>???</li> \r\n</ol> \r\n  \r\n// Если бы мы запустили вместо функции remove() функцию empty() \r\nempty( last( tag(\"ol\")[0] ) ) \r\n","\r\n 107\r\n  \r\n// То остался бы просто пустой список <ol>: \r\n<ol></ol>  \r\nИзучив возможность удаления узла из DOM, вы завершили освоение урока о том, как работает объектная \r\nмодель документа, и как из этого можно извлечь для себя наибольшую выгоду.  \r\nВывод \r\nВ этой главе я рассмотрел многие вопросы, относящиеся к объектной модели документа. К сожалению, \r\nнекоторые темы, к примеру, ожидание загрузки DOM,  оказались сложнее других, и их рассмотрение будет \r\nпродолжено в обозримом будущем. Тем не менее, использование всего здесь изученного, позволит вам создавать \r\nпрактически любые динамические компоненты веб-приложений.  \r\nЕсли вы желаете изучить некоторые примеры DOM-сценариев в действии, просмотрите приложение А, в \r\nкоторое именно для этого включено множество дополнительного кода. Дополнительно, еще больше примеров \r\nсоздания DOM-сценариев можно найти в Интернете, на веб-сайте книги по адресу: http://jspro.org, или в разделе \r\nисходного кода и загрузки — Source Code/Download на веб-сайте издательства Apress: http://www.apress.com. \r\nДалее я собираюсь привлечь ваше внимание к следующим компонентам ненавязчивого создания DOM-сценарием: \r\nк событиям. \r\n","\r\n 108\r\nГлава 6События \r\nНаиболее важной стороной создания ненавязчивых DOM-сценариев является использование динамически \r\nсвязанных событий. Конечная цель написания полезного кода JavaScript состоит в получении веб-страницы, \r\nработающей для пользователей, независимо от того, какой браузер они используют, или на какой платформе \r\nработают. Для достижения этой цели вы устанавливаете заданный набор свойств, которыми хотите \r\nвоспользоваться, и исключаете все браузеры, которые их не поддерживают. Для браузеров, не поддерживающих \r\nэти свойства, вы предлагаете работоспособные, но менее интерактивные версии веб-сайта. Преимущества от \r\nтакой организации взаимодействия JavaScript и HTML включают более совершенный код, более понятные веб-\r\nстраницы, и лучшее взаимодействие с пользователем. Всего этого можно достичь за счет использования событий \r\nDOM для улучшения взаимодействия, происходящего в веб-приложениях. \r\nС годами понятие событий в JavaScript получало развитие, приближаясь к тому надежному, но \r\nполупригодному состоянию, в котором оно сейчас и находится. К счастью, благодаря существованию общих черт, \r\nвы можете разрабатывать замечательные инструменты, помогающие создавать мощные, безупречно написанные \r\nвеб-приложения. \r\nВ начале этой главы я собираюсь представить вам работу событий в JavaScript и сравнить ее с моделями \r\nсобытий, существующими в других языках программирования. Затем я собираюсь рассмотреть информацию, \r\nпредоставляемую моделью событий, и лучшие способы ее контролирования. После того как будет рассмотрена \r\nпривязка событий к DOM-элементам и различные виды доступных событий, в заключение я покажу, как \r\nинтегрировать некоторые эффективные и ненавязчивые технологии написания сценариев в любую веб-страницу. \r\nВведение в события JavaScript \r\nЕсли вы заглянете в основу любого кода JavaScript, то увидите, что события являются именно тем \r\nсвязующим элементом, который все и скрепляет. В хорошо спроектированном JavaScript-приложении, вы \r\nстремитесь иметь источник данных и его визуальное представление (в HTML DOM). Чтобы синхронизировать эти \r\nдве стороны приложения, вам необходимо отслеживать все действия пользователя и, следовательно, его попытки \r\nобновить информацию на вашем веб-сайте. Сочетание использования событий DOM и JavaScript является \r\nосновным союзом, определяющим облик современных веб-приложений. \r\nАсинхронные события против потоков \r\nВ JavaScript используется весьма уникальная система событий. Она работает абсолютно асинхронно, \r\nвообще не используя потоков. Это означает, что весь код вашего приложения будет зависеть от каких-либо \r\nдействий, например, от щелчка пользователя или загрузки страницы — что будет приводить к выполнению \r\nопределенного кода. \r\nОсновное отличие программ, спроектированных для работы с потоками от программ, спроектированных \r\nдля работы с асинхронными событиями состоит в том, как происходит ожидание происходящего. В программах, \r\nрассчитанных на потоки, вы постоянно ведете проверку, пока не будут выполнены заданные вами условия. Тогда \r\nкак в асинхронных программах вы просто регистрируете в качестве обработчика события функцию обратного \r\nвызова, а затем, когда наступит событие, обработчик даст вам знать, выполняя вашу функцию обратного вызова. \r\nТеперь посмотрим, как пишется программа JavaScript, если используются потоки, и как она пишется, если \r\nиспользуются асинхронные обратные вызовы. \r\nПотоки JavaScript \r\nНа сегодняшний день в JavaScript потоки не существуют. Самое близкое, что может быть использовано в \r\nэтом качестве — функция обратного вызова setTimeout( ), но даже при этом модель будет далека от идеала. Если \r\n","\r\n 109\r\nJavaScript был бы традиционным, работающим с потоками языком программирования, то что-либо подобное коду, \r\nприведенному в листинге 6.1 могло бы сработать. В данной имитации кода ведется ожидание, пока страница не \r\nбудет полностью загружена. Если бы JavaScript был потоковым языком программирования, то вам бы пришлось \r\nделать что-либо подобное. Хорошо, что до этого дело не доходит. \r\nЛистинг 6.1. Ложный код JavaScript для имитации потока \r\n// ПРИМЕЧАНИЕ: Этот код не работает! \r\n// Ожидание, пока страница не загрузится, путем осуществления постоянных \r\n// проверок \r\nwhile ( ! window.loaded() ) { } \r\n  \r\n// Страница загружена, можно приступать к работе \r\ndocument.getElementById(\"body\").style.border = \"1px solid #000\"; \r\nЕсли заметили, в этом коде используется цикл, в котором осуществляется постоянная проверка, какое \r\nзначение возвращает window.loaded( ), истинное или нет. Невзирая на факт отсутствия у объекта windows метода \r\nloaded( ), давайте посмотрим, почему это не работает в JavaScript. Это происходит из-за того, что все циклы в \r\nJavaScript являются блокирующими (то есть пока они не закончат работу, ничего другого произойти не может). \r\nЕли бы JavaScript был в состоянии обрабатывать потоки, то вы увидели бы что-либо, подобное изображенному на \r\nрис. 6.1. На этом рисунке имеющийся в вашем коде цикл while постоянно проверяет, не загрузилось ли окно. Но в \r\nJavaScript это не работает из-за того, что все циклы в нем — блокирующие (поэтому никакие другие операции не \r\nмогут быть выполнены, пока цикл работает). \r\n \r\nРис. 6.1. Вот что бы получилось, если бы JavaScript умел обрабатывать потоки \r\nНа самом деле, поскольку наш цикл while продолжает работать и блокировать нормальный ход \r\nвыполнения приложения, то он никогда не получит истинное значение. В результате пользовательский браузер \r\nостановится и зависнет, что может привести к аварийному завершению работы. Из этого можно извлечь \r\nследующий урок: если кто-нибудь будет утверждать, что использует цикл while для ожидания (в JavaScript) \r\nокончания работающего процесса, то он либо лжет, либо сильно заблуждается. \r\nАсинхронные обратные вызовы \r\nПрограммной альтернативой использованию потоков для постоянной проверки обновлений является \r\nиспользование асинхронных обратных вызовов, что, собственно, и делается в JavaScript. Используя простую \r\nтерминологию, вы сообщаете DOM-элементу, что при каждом возникновении события определенного вида, вы \r\n","\r\n 110\r\nхотите, чтобы для его обработки была вызвана функция. Это означает, что вы можете предоставить ссылку на \r\nкод, который желательно в нужный момент выполнить, а браузер берет на себя всю заботу о деталях. В \r\nлистинге 6.2. показан пример кода, в котором используется обработчик событий и обратный вызов. В нем вы \r\nувидите действующий код, необходимый для привязки функции к обработчику события (window.onload) в \r\nJavaScript. Обработчик window.onload( ) будет вызван при каждом событии окончания загрузки страницы. Он \r\nтакже подойдет и для других общих событий, к примеру, для щелчка, перемещения мыши и щелчка на кнопке \r\nтипа submit. \r\nЛистинг 6.2. Асинхронный обратный вызов в JavaScript \r\n// Регистрация функции для вызова при каждой загрузке страницы \r\nwindow.onload = loaded; \r\n  \r\n// Функция, вызываемая при каждой загрузке страницы. \r\nfunction loaded() { \r\n    // Страница уже загружена, можно приступать к работе \r\n    document.getElementById(\"body\").style.border = \"1px solid #000\"; \r\n} \r\nЕсли сравнить код в листинге 6.2 с кодом, показанным в листинге 6.1, будут видны явные различия. \r\nНемедленно выполняется только тот код, который привязан к обработчику события (функции loaded), к его \r\nперехватчику (свойству onload). Как только страница будет полностью загружена, браузер вызывает функцию, \r\nсвязанную с window.onload, и выполняет ее. Примерный ход работы кода JavaScript показан на рис. 6.2. На \r\nрисунке изображено представление об использовании функции обратного вызова для ожидания в JavaScript \r\nзагрузки страницы. Поскольку ожидание здесь в принципе невозможно, вы регистрируете обратный вызов \r\n(loaded), который состоится при полной загрузке страницы, за обработчиком (window.onload). \r\nЕсть одно, не слишком очевидное обстоятельство, касающееся нашего простого перехватчика и \r\nобработчика, которое связано тем, что порядок событий может изменяться, и обработка может отличаться в \r\nзависимости от вида события и расположения элемента в структуре DOM. В следующем разделе мы рассмотрим \r\nдве различные фазы событий, и причины, которые вызывают эту разницу. \r\n \r\nРис. 6.2. Представление об использовании обратных вызовов для ожидания загрузки страницы \r\nФазы события \r\n","\r\n 111\r\nВ JavaScript события происходят в двух фазах, которые называются захватом (capturing) и всплытием, \r\nподобно пузырькам (bubbling). Это означает следующее: если событие происходит в отношении элемента (к \r\nпримеру, пользователь щелкает на ссылке, вызывая тем самым событие щелчка), элементы, позволяющие его \r\nобработать, и порядок, в котором происходит обработка, варьируются. Порядок выполнения можно увидеть в \r\nпримере на рис. 6.3. На этом рисунке показано, какие обработчики события задействуются и в каком порядке при \r\nкаждом щелчке пользователя на первом <a>-элементе страницы. \r\n \r\nРис. 6.3. Две фазы обработки события \r\nЕсли посмотреть на простой пример щелчка на ссылке (на рис. 6.3), можно увидеть порядок выполнения \r\nобработки события. Под тем предлогом, что пользователь щелкнул на элементе <a>, сначала срабатывает \r\nобработчик щелчка, принадлежащий элементу document, затем обработчик, принадлежащий элементу <body>, \r\nзатем обработчик, принадлежащий элементу <div>, и так далее, вплоть до элемента <a>; это называется фазой \r\nзахвата. Как только это все завершится, процесс идет вспять, вверх по дереву, и срабатывают по порядку \r\nобработчики событий <li>, <ul>, <div>, <body> и document. \r\nСуществуют вполне конкретные причины, по которым обработка события построена именно таким \r\nобразом, и почему все это превосходно работает. Рассмотрим простой пример. Предположим, вам нужно изменять \r\nцвет фона каждого <li>-элемента при каждом прохождении над ним указателя мыши, и возвращать исходный \r\nцвет, когда указатель мыши уходит за пределы элемента — обычные запросы для многих систем меню. Именно \r\nэту задачу и выполняет код, показанный в листинге 6.3. \r\nЛистинг 6.3. Сценарий обозначаемых перемещений с эффектами зависания \r\n// Обнаружение всех элементов <li> для подключения к ним обработчиков \r\n// событий \r\nvar li = document.getElementsByTagName(\"li\"); \r\nfor ( var i = 0; i < li.length; i++ ) { \r\n  \r\n    // Подключение к элементу <li> обработчика события mouseover, \r\n","\r\n 112\r\n    // который изменяет цвет фона <li> на синий. \r\n    li[i].onmouseover = function() { \r\n       this.style.backgroundColor = 'blue'; \r\n    }; \r\n  \r\n    // Подключение к элементу <li> обработчика события, \r\n    // который изменяет цвет фона <li> на исходный белый \r\n    li[i].onmouseout = function() { \r\n       this.style.backgroundColor = 'white'; \r\n    }; \r\n}  \r\nКод ведет себя точно в соответствии с вашим представлением: при проходе указателя вашей мыши над \r\nэлементом <li>, его фоновый              цвет изменяется; при выходе указателя за пределы элемента, цвет \r\nвозвращается к исходному. Но при этом вы не понимаете, что при каждом прохождении указателя над <li>, вы на \r\nсамом деле периодически переключаетесь между двумя различными элементами. Поскольку элемент <li> также \r\nсодержит элемент <a>, вы перемещаете указатель мыши и над ним, а не только над <li>. Взглянем на на точный \r\nход возникновения событий: \r\n• <li> mouseover: Указатель мыши находится над элементом <li>. \r\n• <li> mouseout: Вы перемещаете его с <li> на <a>, который находится внутри. \r\n• <a> mouseover: Теперь указатель мыши находится над элементом <a>. \r\n• <li> mouseover: Событие mouseover, принадлежащее <a>, «всплывает» вверх к событию mouseover, \r\nпринадлежащему элементу <li>. \r\nЕсли вы по направлению возникновения событий заметили, что фаза захвата полностью проигнорирована, \r\nне переживайте, я о ней не забылt. Способ привязки перехватчиков событий заключается в использовании старых \r\n«традиционных» средств привязки событий за счет установки свойства элемента onevent, которое поддерживает \r\nтолько всплытие, а не захват события. Этот способ привязки событий наряду с другими рассмотрен в следующем \r\nразделе. \r\nВдобавок к странному порядку возникновения событий вы могли заметить два неожиданных действия: \r\nвозникновение mouseout при выходе из <li> и всплытие mouseover от <a> к <li>. Рассмотрим это более \r\nподробно. \r\nПервое событие mouseout возникает из-за того, что с точки зрения браузера вы покинули пределы \r\nродительского элемента <li> и переместились на другой элемент. Это происходит из-за того, что элемент, \r\nнаходящийся поверх других элементов (как элемент <a> по отношению к родительскому элементу <li>) \r\nмоментально получает фокус указателя мыши. \r\nПринадлежащее элементу <a> событие mouseover всплывает к родительскому элементу <li>, бросая тем \r\nсамым спасательный круг нашему фрагменту кода. Поскольку вы не привязали к элементу <a> никакого \r\nперехватчика, событие просто перемещается вверх по дереву DOM в поиске другого элемента, имеющего \r\nперехватчик. И первым попавшимся элементом в этом процессе всплытия оказывается <li>, который \r\nперехватывает входящие события mouseover (что, собственно, и требовалось). \r\n","\r\n 113\r\nНо тут возникает другой вопрос, что произойдет, если у элемента <a> будет собственный обработчик \r\nсобытия mouseover? Существует ли какой-нибудь способ, который сможет остановить всплытие события? Эта \r\nважная и полезная тема будет рассмотрена в следующем разделе. \r\nОбщие свойства событий \r\nОдной из сильных сторон событий JavaScript является наличие относительно совместимых свойств, \r\nкоторые дают в процессе разработки больше возможностей и средств управления. Самым простым и давним \r\nпонятием является объект события, предоставляющий собой набор метаданных и контекстно-зависимых функций, \r\nпозволяющих вам работать, к примеру, с событиями мыши и клавиатуры. Кроме этого существуют функции, \r\nкоторые можно использовать для изменения нормального хода захвата-всплытия события. Изучение этих свойств \r\nв полном объеме может значительно упростить вашу жизнь. \r\nОбъект события \r\nСтандартным свойством обработчиков событий является способ обращений к объекту события, в котором \r\nсодержится контекстно-зависимая информация о текущем событии. Для определенных событий этот объект \r\nслужит очень ценным ресурсом. К примеру, при обработке нажатий клавиш можно получить доступ к свойству \r\nобъекта keyCode и получить код нажатой клавиши. Более подробная информация, относящаяся к специфике \r\nобъекта события, изложена в приложении Б. \r\nУ объекта события есть одна сложность: его реализация в Internet Explorer отличается от спецификации, \r\nпредложенной W3C. В Internet Explorer имеется один глобальный объект события (который может быть \r\nгарантированно найден в глобальной переменной свойства window.event), тогда как в других браузерах имеется \r\nпереданный им отдельный параметр, в котором содержится объект события. Пример гарантированного \r\nиспользования объекта события показан в листинге 6.4. Это пример изменения типичного поведения элемента \r\n<textarea>. Обычно пользователи могут находясь в textarea нажать клавишу Enter, и вызвать появление \r\nдополнительного символа конца строки. А вместо этого нужно простое расширение текстового окна? Именно эту \r\nзадачу и выполняет следующая функция. \r\nЛистинг 6.4. Подмена выполняемой функции путем использования событий DOM \r\n// Обнаружение на странице первого элемента <textarea>, и привязка к нему \r\n// перехватчика нажатия клавиатуры \r\ndocument.getElementsByTagName(\"textarea\")[0].onkeypress = function(e){ \r\n    // Если объект события отсутствует, использование глобальной \r\n    // переменной (только для IE) \r\n    e = e || window.event; \r\n  \r\n    // Если нажата клавиша Enter, вернуть false (то есть ничего не делать) \r\n    return e.keyCode != 13; \r\n};  \r\nВ объекте события содержится множество свойств и методов, их имена и поведение варьируются от \r\nбраузера к браузеру. Сейчас я не хочу вдаваться в подробности, но настоятельно рекомендую прочесть \r\nприложение Б, в котором приведен большой список всех свойств объекта события, рассказано, как их \r\nиспользовать и приведены примеры использования. \r\nКлючевое слово this \r\nКлючевое слово this (как уже было рассмотрено в главе 2) служит способом обращения к текущему \r\nобъекту внутри функции. При использовании ключевого слова this современные браузеры дают всем \r\n","\r\n 114\r\nобработчикам событий некоторый контекст. Но только часть этого контекста (и только в некоторых методах) \r\nработает должным образом и относится к текущему элементу; этот вопрос мы рассмотрим поглубже буквально \r\nчерез минуту. К примеру, в листинге 6.5, я могу воспользоваться этим обстоятельством только для того, чтобы \r\nсоздать одну универсальную функцию обработки щелчков, но не смогу использовать это ключевое слово, чтобы \r\nопределить, какой элемент в данный момент обрабатывается. В листинге показан пример использования только \r\nодной функции для обработки события щелчка, но так как ключевое слово this в ней используется для ссылки на \r\nэлемент, все будет работать должным образом. \r\nЛистинг 6.5. Изменение цвета фона и переднего плана всех элементов <li> по щелчку \r\n// Обнаружение всех элементов <li> и привязка к каждому из них \r\n// обработчика щелчка \r\nvar li = document.getElementsByTagName(\"li\"); \r\nfor ( var i = 0; i < li.length; i++ ) { \r\n    li[i].onclick = handleClick; \r\n} \r\n  \r\n// Обработчик щелчка при вызове изменяет цвет фона \r\n// и цвет переднего плана определенного элемента \r\nfunction handleClick() { \r\n    this.style.backgroundColor = \"blue\"; \r\n    this.style.color = \"white\"; \r\n}  \r\nФактически ключевое слово this предоставляет лишь некоторое удобство, однако, я полагаю, что вы \r\nсогласитесь с тем, что при правильном использовании оно может существенно упростить код JavaScript. Весь код, \r\nкоторый связан в этой книге с событиями, я старался написать, используя это ключевое слово. \r\nПрекращение всплытия событий \r\nТеперь, когда вы уже знаете как работают захват и всплытие событий, давайте исследуем вопросы \r\nуправления этими процессами. В одном из предыдущих примеров был поднят важный вопрос: если вам нужно \r\nбудет, чтобы событие произошло только для заданного элемента и не касалось его родительских элементов, то \r\nспособов остановки процесса у нас пока нет. Остановка всплытия события ситуацию, изображенную на рис. 6.4, в \r\nкоторой показан результат захвата события первым элементом <a> и прекращения последующего всплытия. \r\n","\r\n 115\r\n \r\nРис. 6.4. Результат захвата события первым элементом <a> \r\nОстановка всплытия (или захвата) события может стать исключительно полезной в сложных приложениях. \r\nК сожалению, Internet Explorer предлагает иной способ остановки всплытия события, чем все остальные браузеры. \r\nУниверсальная функция прекращения всплытия события показана в листинге 6.6. Она принимает единственный \r\nаргумент: объект события, переданный в обработчик события. Функция отрабатывает два разных способа \r\nпрекращения всплытия события: стандартный W3C-способ, и нестандартный способ, принадлежащий Internet \r\nExplorer. \r\nЛистинг 6.6. Универсальная функция для остановки всплытия события \r\nfunction stopBubble(e) { \r\n    // Если предоставлен объект события, значит это не IE-браузер \r\n    if ( e && e.stopPropagation ) \r\n       // и он поддерживает W3C-метод stopPropagation() \r\n       e.stopPropagation(); \r\n    else \r\n       // В противном случае нужно воспользоваться способом \r\n       // прекращения всплытия события, существующим в Internet Explorer \r\n    window.event.cancelBubble = true; \r\n}  \r\nТеперь вы , наверное, хотите спросить, когда я хочу остановить всплытие события? По правде говоря, в \r\nбольшинстве случаев вам не придется об этом волноваться. Потребности в этом возникнут, когда вы начнете \r\nразрабатывать динамические приложения (особенно те, которые работают с клавиатурой или мышью. В \r\nлистинге 6.7 показан небольшой фрагмент, который добавляет красное обрамление вокруг текущего элемента, на \r\nкоторым вы проносите указатель мыши. Это достигается добавлением обработчиков событий mouseover и \r\nmouseout к каждому DOM-элементу. Если вы не остановите всплытие события, то при каждом проходе указателя \r\nмыши над элементом красное обрамление будет получать как сам элемент, так и все его родительские элементы, \r\nчто не соответствует вашему желанию. \r\n","\r\n 116\r\nЛистинг 6.7. Использование stopBubble() для создания интерактивного набора элементов \r\n// Обнаружение и проход по всем элементам, имеющимся в DOM \r\nvar all = document.getElementsByTagName(\"*\"); \r\nfor ( var i = 0; i < all.length; i++ ) { \r\n  \r\n    // Отслеживание прохода указателя мыши над элементом \r\n    // и добавление к элементу красного обрамления \r\n    all[i].onmouseover = function(e) { \r\n       this.style.border = \"1px solid red\"; \r\n       stopBubble( e ); \r\n    }; \r\n  \r\n    // Отслеживание выхода указателя мыши за пределы элемента \r\n    // и удаление ранее добавленного обрамления \r\n    all[i].onmouseout = function(e) { \r\n       this.style.border = \"0px\"; \r\n       stopBubble( e ); \r\n    }; \r\n}  \r\nТеперь, имея возможность остановить всплытие события, вы получаете полное управление над тем, какой \r\nименно элемент занимается отслеживанием и обработкой события. Это основной инструмент исследования \r\nразработки динамических веб-приложений. Теперь остается только отключить исходные действия браузера, что \r\nпозволит вам подменять все, что он делает и реализовать вместо этого новые функциональные возможности. \r\nПодмена исходных действий браузера \r\nДля большинства имеющихся событий у браузера есть некоторые исходные действия, которые всегда им \r\nсовершаются. К примеру, щелчок на элементе <a> перенесет вас на связанную с ним веб-страницу; это исходное \r\nдействие браузера. На рис. 6.5 показано, что оно всегда будет совершаться после обеих фаз захвата и всплытия. \r\nВ этом примере показаны результаты пользовательского щелчка на имеющимся на веб-странице элементе <a>. \r\nСобытие, как уже ранее говорилось, начинается с путешествия по DOM в обеих фазах: захвата и всплытия. Но \r\nтолько как элемент будет пройден, браузер попытается выполнить свое исходное действие для этого события и \r\nэлемента. В данном случае, посетить страницу, обозначенную как /. \r\n","\r\n 117\r\n \r\nРис. 6.5. Полный жизненный цикл события \r\nИсходные действия могут быть сведены в понятие всего, что делается браузером без вашего на то \r\nконкретного указания. Рассмотрим примеры разного рода совершаемых исходных действий, и событий, по поводу \r\nкоторых это происходит: \r\n• Щелчок на элементе <a> перенаправит вас на URL, предоставленный в его атрибуте href. \r\n• Нажатие на клавиатуре сочетания Ctrl+S, приведет к попытке браузера сохранить физическое \r\nпредставление веб-сайта. \r\n• Отправка HTML <form> приведет к передаче данных запроса на определенный URL и перенаправлению \r\nбраузера по указанному адресу. \r\n• Перемещение указателя мыши над элементом изображения — <img>, имеющим атрибут alt или title (в \r\nзависимости от браузера) приведет к появления подсказчика, предоставляющего описание изображения. \r\nВсе ранее перечисленные действия будут выполняться браузером даже если вы остановите всплытие \r\nсобытия, или у вас вообще не будет привязано к элементу никакого обработчика события. Это может привести в \r\nваших сценариях к значительным проблемам. Что делать, если вам нужно задать передаваемой форме иное \r\nповедение? Или если нужно, чтобы элемент <a> вел себя не так, как предписано его предназначением? Ведь \r\nвоспрепятствовать всплытию события для того, чтобы предотвратить исходные действия будет не достаточно, вам \r\nпонадобится некий особенный код, который будет непосредственно управлять этим процессом. Как и в случае с \r\nотменой всплытия, есть два способа остановки исходных действий: особый IE-способ, и способ, предусмотренный \r\nW3C. Оба эти способа показаны в листинге 6.8. Приведенная в нем функция принимает один аргумент: объект \r\nсобытия, передаваемый в обработчик события. Эта функция может быть использована в самом конце обработчика \r\nсобытия, таким вот образом: return stopDefault( e ); —поскольку ваш обработчик тоже должен возвратить false \r\n(который теперь вернет для вас функция stopDefault). \r\nЛистинг 6.8. Универсальная функция для предотвращения исходных действий браузера \r\nfunction stopDefault( e ) { \r\n    // Предотвращение исходных действий браузера (W3C) \r\n    if ( e && e.preventDefault ) \r\n","\r\n 118\r\n       e.preventDefault(); \r\n       // Ссылка на остановку действия браузера в IE \r\n    else \r\n       window.event.returnValue = false; \r\n  \r\n    return false; \r\n}  \r\nТеперь, используя функцию stopDefault, вы можете остановить любое исходное действие, предоставляемое \r\nбраузером. Как показано в листинге 6.9, это позволит вам задать в сценарии вполне определенную реакцию на \r\nдействия пользователя. Код делает так, чтобы все имеющиеся на странице ссылки загружались в отдельном \r\nэлементе <iframe>, а не в открываемой целиком новой странице. Это позволит вам удержать пользователя на \r\nстранице, и дать ему возможность более интерактивного взаимодействия. \r\nПРИМЕЧАНИЕ \r\nПредотвращение исходный действий во всех необходимых случаях работает на 95%. Все усложняется при \r\nперемещении от браузера к браузеру, из-за того, что предотвращение исходного действия зависит от самого \r\nбраузера (они не всегда все делают правильно), особенно при работе с предотвращением действий, вызванных \r\nнажатием клавиш в текстовых полях, и с предотвращением действий внутри элементов <iframe>; во всех \r\nостальных случаях все должно проходить более-менее гладко. \r\nЛистинг 6.9. Использование stopDefault() для подмены функциональных действий браузера \r\n// Предположим, на странице уже есть элемент Iframe, \r\n// и его ID имеет значение 'iframe' \r\nvar iframe = document.getElementById(\"iframe\"); \r\n  \r\n// Обнаружение на странице всех элементов <a> \r\nvar a = document.getElementsByTagName(\"a\"); \r\nfor ( var i = 0; i < a.length; i++ ) { \r\n  \r\n    // Привязка к <a> обработчика щелчка \r\n    a[i].onclick = function(e) { \r\n      // Установка места нахождения IFrame \r\n      iframe.src = this.href; \r\n      // Предотвращение любых посещений из браузера веб-сайтов, на которые \r\n      // указывают элементы <a> (что является исходным действием) \r\n      return stopDefault( e ); \r\n    }; \r\n}  \r\nПодмена исходных действий — неразрывное сочетание DOM и событий, которые объединяются в форме \r\nненавязчивого создания DOM-сценариев. Чуть позже, в разделе «Создание ненавязчивых DOM-сценариев», я \r\nпоговорю об этом с функциональной точки зрения. Тем не менее, не все так гладко; основные разногласия \r\nвозникают, когда приходит время заняться привязкой ваших обработчиков событий к DOM-элементам. Фактически \r\nсуществуют три различных способа привязки событий, одни хуже, другие лучше, и все они будут рассмотрены в \r\nследующем разделе. \r\nПривязка перехватчиков событий \r\n","\r\n 119\r\nПривязка обработчиков событий к элементам была в JavaScript постоянно развивающимся предметом \r\nпоиска. \r\nВсе началось с браузеров, вынуждающих пользователей делать код обработчика событий встроенным в их \r\nHTML-документы. К счастью, эта методика со временем в значительной степени утратила популярность (что нам \r\nна руку, поскольку она идет вразрез с принципами абстракции данных при создании ненавязчивых DOM-\r\nсценариев). \r\nКогда Netscape и Internet Explorer активно конкурировали, в каждом из них модели регистрации событий \r\nразвивались по отдельности, но очень похожими путями. В конечном итоге модель Netscape была изменена, чтобы \r\nстать стандартом W3C, а модель Internet Explorer осталась той же самой. \r\nНа сегодняшний день осталось три безотказных способа регистрации событий. Хотя традиционный метод \r\nявляется ответвлением старого, встраиваемого способа привязки обработчиков событий, но он надежен и слажен \r\nв работе. Другие методы относятся к IE и W3C способам регистрации событий. В завершение я продемонстрирую \r\nнадежный набор способов, которые могут применяться разработчиками без оглядки на используемый браузер. \r\nТрадиционная привязка \r\nДо сих пор в этой главе я использовал именно традиционный способ привязки событий. Это самый простой \r\nи наиболее совместимый способ привязки обработчиков событий. Чтобы им воспользоваться, вы прикрепляете \r\nфункцию в качестве свойства DOM-элемента, за которым нужно наблюдать. В листинге 6.10 показан ряд примеров \r\nприкрепления событий с использованием традиционного метода. \r\nЛистинг 6.10. Прикрепление событий с использованием традиционного метода их привязки \r\n// Обнаружение первого элемента <form> и прикрепление к нему обработчика \r\n// события 'submit' \r\ndocument.getElementsByTagName(\"form\")[0].onsubmit = function(e){ \r\n    // Остановка всех попыток передачи данных формы \r\n    return stopDefault( e ); \r\n}; \r\n  \r\n// Прикрепление обработчика события нажатия клавиши к элементу <body> \r\n// текущего документа \r\ndocument.body.onkeypress = myKeyPressHandler; \r\n  \r\n// Прикрепление к странице обработчика события загрузки \r\nwindow.onload = function(){ ...; };  \r\nЭта технология имеет ряд преимуществ и недостатков, о которых вы должны знать при ее использовании. \r\nПреимущества традиционной привязки \r\nТрадиционный метод имеет следующие преимущества: \r\n• Самое большое преимущество использования традиционного метода заключается в его невероятной \r\nпростоте и непротиворечивости, которые в значительной степени гарантируют его однообразную работу \r\nнезависимо от используемого браузера. \r\n• При обработке события ключевое слово this ссылается на текущий элемент, что может оказаться очень \r\nполезным обстоятельством (как показано в листинге 6.5). \r\n","\r\n 120\r\nНедостатки традиционного способа привязки \r\nУ традиционного метода имеются следующие недостатки: \r\n• Традиционный метод работает только со всплытием событий, но не с захватом и всплытием. \r\n• Одновременно к элементу может быть привязан только один обработчик событий. При работе с \r\nпопулярным свойством window.onload существует потенциальная возможность получения довольно \r\nстранных результатов (отдельные фрагменты кода, используемые для реализации такого же способа \r\nпривязки событий, полностью переписывают предыдущую обработку). Пример проявления этой проблемы \r\nпоказан в листинге 6.11, где обработчик событий переписывает старый обработчик. \r\n• Параметр объект события доступен только в браузерах, не имеющих отношения к Internet Explorer. \r\nЛистинг 6.11. Обработчики события, переписывающие друг друга \r\n// Привязка исходного обработчика события \r\nwindow.onload = myFirstHandler; \r\n  \r\n// Где-нибудь в другой библиотеке, которую вы включили, \r\n// первый обработчик переписывается, и по окончании загрузки страницы \r\n// вызывается только второй обработчик — 'mySecondHandler' \r\nwindow.onload = mySecondHandler;  \r\nЗная о возможности безоговорочной подмены обработчика другими обработчиками событий, вы, скорее \r\nвсего, выберете традиционные средства привязки только для простых ситуаций, в которых вы сможете быть \r\nуверены в коде, работающем вместе с вашим кодом. Тем не менее, обойти эту запутанную ситуацию можно только \r\nодним способом — воспользоваться предлагаемыми браузерами современными методами привязки событий. \r\nDOM-привязка: W3C \r\nЕдинственный, по-настоящему стандартный способ привязки обработчиков событий к DOM-элементам \r\nразработан W3C. Памятуя об этом разработчики каждого современного браузера, за исключением Internet \r\nExplorer, включают в него поддержку этого способа привязки события. \r\nКод для привязки новой функции обработки довольно прост. Он существует в виде функции для каждого \r\nDOM-элемента (которая носит название addEventListener), принимающей три параметра: название события \r\n(например, click), функцию, которая будет обрабатывать событие, и логический флаг для разрешения или отмены \r\nзахвата события. В листинге 6.12 приводится пример использования функции addEventListener. \r\nЛистинг 6.12. Пример кодового фрагмента, в котором используется способ привязки обработчиков \r\nсобытий, принятый W3C \r\n// Обнаружение первого элемента <form> и привязка к нему обработчика события \r\n// 'submit' \r\ndocument.getElementsByTagName(\"form\")[0]. \r\n    addEventListener('submit',function(e){ \r\n    // Остановка всех попыток отправки данных формы \r\n    return stopDefault( e ); \r\n}, false); \r\n  \r\n// Привязка обработчика события нажатия на клавишу к элементу <body> \r\n// текущего документа \r\n","\r\n 121\r\ndocument.body.addEventListener('keypress', myKeyPressHandler, false); \r\n  \r\n// Привязка к странице обработчика события ее загрузки \r\nwindow.addEventListener('load', function(){ ...; }, false);  \r\nПреимущества W3C-привязки \r\nСпособ привязки, предложенный W3C, имеет следующие преимущества: \r\n• Этот метод поддерживает обе фазы обработки события: и захват и всплытие. Фаза события переключается \r\nза счет установки последнего параметра функции addEventListener в false (для всплытия) или true (для \r\nзахвата). \r\n• Внутри функции обработки события ключевое слово this ссылается на текущий элемент. \r\n• Объект события всегда доступен в первом параметре функции обработки. \r\n• К элементу можно привязать сколько угодно событий, без переписывания ранее привязанных \r\nобработчиков. \r\nНедостаток W3C-привязки \r\nУ способа привязки, предложенного W3C, имеются следующий недостаток: \r\n• Он не работает в Internet Explorer; вместо него в этом браузере нужно применять функцию attachEvent. \r\nЕсли бы Internet Explorer использовал способ привязки обработчиков событий, предложенный W3C, эта \r\nглава могла бы быть значительно короче, поскольку не пришлось бы рассматривать альтернативные способы \r\nпривязки событий. Но на данный момент метод привязки событий, предложенный W3C, является наиболее \r\nполноценным и простым в использовании. \r\nDOM-привязка: IE \r\nСпособ, используемый для привязки событий в Internet Explorer во многом кажется похожим на способ, \r\nпредложенный W3C. Но если вникнуть в подробности, выясняется, что в некоторых деталях есть весьма \r\nсущественные различия. В листинге 6.13 показано несколько примеров привязки обработчиков событий в Internet \r\nExplorer. \r\nЛистинг 6.13. Примеры привязки обработчиков событий к элементам способом, существующем в Internet \r\nExplorer \r\n// Обнаружение первого элемента <form> и привязка к нему обработчика события \r\n// 'submit' \r\ndocument.getElementsByTagName(\"form\")[0].attachEvent('onsubmit',function(){ \r\n    // Остановка всех попыток отправки данных формы \r\n    return stopDefault(); \r\n},); \r\n  \r\n// Привязка обработчика события нажатия на клавишу к элементу <body> \r\n// текущего документа \r\ndocument.body.attachEvent('onkeypress', myKeyPressHandler); \r\n  \r\n// Привязка к странице обработчика события ее загрузки \r\nwindow.attachEvent('onload', function(){ ...; });  \r\n","\r\n 122\r\nПреимущество IE-привязки \r\nПреимущество способа привязки событий, существующего в Internet Explorer, заключается в следующем: \r\n• К элементу можно привязать сколько угодно событий, без переписывания ранее привязанных \r\nобработчиков. \r\nНедостатки IE-привязки \r\nНедостатки способа привязки событий, существующего в Internet Explorer, заключаются в следующем: \r\n• Internet Explorer при захвате события поддерживает только фазу всплытия. \r\n• Внутри функции перехватчика ключевое слово this указывает на объект window, а не на текущий элемент \r\n(огромный недостаток IE). \r\n• Объект события доступен только в параметре window.event. \r\n• Название события должно иметь префикс «on» — например, onclick вместо простого click. \r\n• Он работает только в Internet Explorer. Для браузеров, не имеющих отношения к IE, нужно использовать \r\nW3C-функцию addEventListener. \r\nПоскольку свойства событий отвечают стандарту не в полной мере, существующая в Internet Explorer \r\nреализация привязки событий считается весьма ущербной. Из-за множества недостатков до сих пор приходится \r\nиспользовать различные обходные маневры, приводящие эту систему к приемлемому поведению. Но не все еще \r\nпотеряно: стандартная функция добавления событий к DOM все же существует, и она сможет в значительной \r\nстепени скрасить ситуацию. \r\naddEvent и removeEvent \r\nВ соревновании, затеянном Петером-Паулем Кохом (Peter-Paul Koch) (в http://quirksmode.org) в конце \r\n2005 года, он попросил всех, кто занимается программированием на JavaScript, разработать новую пару \r\nфункций —   addEvent и removeEvent, которые смогли бы предоставить пользователям надежный способ \r\nдобавления и удаления событий в отношении элемента DOM. Я вышел из этого соревнования победителем, создав \r\nдовольно компактный и достаточно хорошо работающий код. Но позже, один из членов жюри, Дин Эдвардс (Dean \r\nEdwards), выпустил другую версию функции, которые значительно превзошли результаты моего творчества. В его \r\nреализации использовались традиционные средства привязки обработчиков событий, полностью игнорировавшие \r\nсовременные методы. Благодаря этому его реализация могла работать на большом количестве браузеров, \r\nобеспечивая к тому же все необходимые тонкости, связанные с событиями (нормальную работу ключевого слова \r\nthis и стандартный объект события). В листинге 6.14 показан пример кодового фрагмента, в котором используются \r\nвсевозможные аспекты обработки событий, использующие преимущества новой функции addEvent, где имеет \r\nместо предотвращение исходной реакции браузера на события, включение нормального объекта события, и \r\nвключение нормального ключевого слова this. \r\nЛистинг 6.14. Пример фрагмента кода, в котором используется функция addEvent \r\n// Ожидание завершения загрузки страницы \r\naddEvent( window, \"load\", function(){ \r\n  \r\n    // Отслеживание любого пользовательского нажатия клавиши \r\n    addEvent( document.body, \"keypress\", function(e){ \r\n       // Если пользователь нажал сочетание клавиш Пробел + Ctrl \r\n       if ( e.keyCode == 32 && e.ctrlKey ) { \r\n  \r\n","\r\n 123\r\n           // Отображение нашей специальной формы \r\n           this.getElementsByTagName(\"form\")[0].style.display = 'block'; \r\n  \r\n           // Гарантирование отсутствия странного поведения \r\n           e.preventDefault(); \r\n  \r\n       } \r\n    }); \r\n});  \r\nФункция addEvent предоставляет невероятно простой и в то же время мощный способ работы с DOM-\r\nсобытиями. Если взглянуть на все его преимущества и недостатки, станет совершенно понятно, что эта функция \r\nможет служить в качестве совместимого и надежного средства работы с событиями. Ее полный исходный код, \r\nработающий со всеми браузерами, не требующий большого объема памяти, обрабатывающий ключевое слово this \r\nи определяющий стандарты функций объекта события, приведен в листинге 6.15. \r\nЛистинг 6.15. Библиотека addEvent/removeEvent, созданная Дином Эдвардсом \r\n// addEvent/removeEvent written by Dean Edwards, 2005 \r\n// with input from Tino Zijdel \r\n// http://dean.edwards.name/weblog/2005/10/add-event/ \r\n  \r\nfunction addEvent(element, type, handler) { \r\n    // присвоение каждому обработчику события уникального ID \r\n    if (!handler.$$guid) handler.$$guid = addEvent.guid++; \r\n  \r\n    // создание хэш-таблицы видов событий для элемента \r\n    if (!element.events) element.events = {}; \r\n  \r\n    // создание хэш-таблицы обработчиков событий для каждой пары \r\n    // элемент-событие \r\n    var handlers = element.events[type]; \r\n    if (!handlers) { \r\n       handlers = element.events[type] = {}; \r\n  \r\n       // сохранение существующего обработчика события \r\n       // (если он существует) \r\n       if (element[\"on\" + type]) { \r\n           handlers[0] = element[\"on\" + type]; \r\n       } \r\n    } \r\n  \r\n    // сохранение обработчика события в хэш-таблице \r\n    handlers[handler.$$guid] = handler; \r\n  \r\n    // назначение глобального обработчика события для выполнения \r\n    // всей работы \r\n    element[\"on\" + type] = handleEvent; \r\n}; \r\n","\r\n 124\r\n  \r\n// счетчик, используемый для создания уникальных ID \r\naddEvent.guid = 1; \r\n  \r\nfunction removeEvent(element, type, handler) { \r\n    // удаление обработчика события из хэш-таблицы \r\n    if (element.events && element.events[type]) { \r\n       delete element.events[type][handler.$$guid]; \r\n    } \r\n}; \r\n  \r\nfunction handleEvent(event) { \r\n    var returnValue = true; \r\n  \r\n    // захват объекта события (IE использует глобальный объект события) \r\n    event = event || fixEvent(window.event); \r\n  \r\n    // получение ссылки на хэш-таблицу обработчиков событий \r\n    var handlers = this.events[event.type]; \r\n  \r\n    // выполнение каждого обработчика события \r\n    for (var i in handlers) { \r\n       this.$$handleEvent = handlers[i]; \r\n       if (this.$$handleEvent(event) === false) { \r\n           returnValue = false; \r\n       } \r\n    } \r\n  \r\n    return returnValue; \r\n}; \r\n  \r\n// Добавление к объекту события IE некоторых \"упущенных\" методов \r\nfunction fixEvent(event) { \r\n    // добавление стандартных методов событий W3C \r\n    event.preventDefault = fixEvent.preventDefault; \r\n    event.stopPropagation = fixEvent.stopPropagation; \r\n    return event; \r\n}; \r\n  \r\nfixEvent.preventDefault = function() { \r\n    this.returnValue = false; \r\n}; \r\n  \r\nfixEvent.stopPropagation = function() { \r\n    this.cancelBubble = true; \r\n};  \r\nПреимущества addEvent \r\n","\r\n 125\r\nПреимущества разработанного Дином Эдвардсом метода привязки событий addEvent заключаются в \r\nследующем: \r\n• Он работает на всех браузерах, даже на старых, уже не поддерживаемых браузерах. \r\n• Ключевое слово this доступно во всех функциях привязки, и указывает на текущий элемент. \r\n• Нейтрализованы все специфические для конкретного браузера функции для пресечения исходных \r\nдействий браузера и для остановки всплытия события. \r\n• Объект события всегда передается в качестве первого параметра, независимо от типа браузера. \r\nНедостаток addEvent \r\nВ разработанном Дином Эдвардсом методе привязки событий addEvent существует следующий недостаток: \r\n• Он работает только во время фазы всплытия (поскольку в своей основе он использует традиционный \r\nметод привязки события). \r\nУчитывая всю мощь функций addEvent и removeEvent, не остается абсолютно никаких причин, \r\nпрепятствующих их использованию в вашем коде. C высоты того, что демонстрирует разработанный Дином \r\nисходный код, становится вполне обычной задачей добавление таких свойств, как более четкая стандартизация \r\nобъекта события, запуска обработки события, и тотального удаления обработчиков события, то есть всего того, \r\nчего очень трудно добиться от обычной структуры обработки событий. \r\nВиды событий \r\nОбщие события JavaScript могут быть классифицированы на несколько различных категорий. Вероятно \r\nнаиболее востребованной категорией являются события, связанные с мышью, от них не намного отстают события, \r\nсвязанные с клавиатурой и формами. В следующем списке представлен широкий обзор различных классов \r\nсуществующих событий, которые могут быть обработаны в веб-приложении. А многочисленные примеры работы с \r\nсобытиями приведены в приложении Б. \r\nСобытия, связанные с мышью: Эти события подразделяются на две категории: события, с помощью \r\nкоторых отслеживается текущее местоположение указателя мыши (mouseover, mouseout), и события, с помощью \r\nкоторых отслеживается щелчок мыши (mouseup, mousedown, click). \r\nСобытия, связанные с клавиатурой: С помощью этих событий отслеживается момент нажатия клавиш, и \r\nконтекст в пределах которого он произошел — к примеру, с их помощью отслеживается нажатие клавиш внутри \r\nэлемента form в отличие от нажатия клавиши в пределах всей страницы. Как и в случае с мышью, существует три \r\nразновидности событий, используемых для отслеживания клавиатуры: keyup, keydown и keypress. \r\nСобытия, связанные с пользовательским интерфейсом: Эти события используются для отслеживания, \r\nкогда пользователи используют ту или иную часть страницы. С их помощью можно, к примеру, четко определить, \r\nкогда пользователь начинает вводить данные в элемент формы. Для отслеживания этих обстоятельств \r\nиспользуются два события: focus и blur (для тех случаев, когда объект теряет фокус). \r\nСобытия формы: Эти события напрямую связаны только с тем, что случается в форме и в ее элементах \r\nввода. С помощью события отправки данных —  submit отслеживается момент передачи данных из формы; с \r\nпомощью события изменения — change отслеживается пользовательский ввод данных в элемент; а событие select \r\nвозникает, когда был обновлен элемент <select>. \r\nСобытия загрузки и ошибки: И последний класс событий относится к странице как таковой, с их помощью \r\nотслеживается состояние ее загрузки. Они связаны с первоначальной загрузкой страницы пользователем \r\n(событие load), и с тем моментом, когда он окончательно покидает страницу (события unload и beforeunload). \r\n","\r\n 126\r\nВдобавок к этому с помощью события error отслеживается возникновение ошибок JavaScript, позволяя проводить \r\nиндивидуальную обработку ошибок. \r\nКогда вы разберетесь с основными классами событий, я рекомендую внимательно просмотреть материал \r\nприложения Б, в котором я провожу анализ всех широко используемых событий, из работы и поведения на \r\nразличных браузерах, и даю описание всех премудростей, необходимых, чтобы добиться от них желаемых \r\nрезультатов. \r\nСоздание ненавязчивых DOM-сценариев \r\nВсе, что изучалось до сих пор было направлено на достижение невероятно важной цели: написанию \r\nтакого кода JavaScript, который смог бы взаимодействовать с вашими пользователями ненавязчивым и \r\nестественным образом. Движущая сила, положенная в основу этого стиля создания сценариев, заключается в \r\nпоявившейся возможности сфокусировать свою энергию на написании качественного кода, способного работать \r\nна современных браузерах, который перестает действовать, не создавая проблем в работе на устаревших (не \r\nподдерживающих его) браузерах. \r\nЧтобы достичь этой цели, можно объединить три методики, изученные в ходе обучения созданию \r\nприложений на основе ненавязчивых сценариев: \r\n1. Все выполняемые функции должны быть проверены. К примеру, если требуется обращение к модели HTML \r\nDOM, нужно проверить сам факт ее существования и наличия всех функций, необходимых для ее \r\nиспользования (например, if ( document && document.getElementById ) ). Эта методика обсуждалась в \r\nглаве 2. \r\n2. DOM должна использоваться для быстрого и однообразного обращения к элементам вашего документа. Как \r\nтолько вы узнаете, что браузер поддерживает DOM-функции, можете свободно создавать простой код, без \r\nобходных маневров и ненужных ухищрений. \r\n3. И, наконец, все события нужно привязывать к документу в динамическом режиме, используя DOM и \r\nфункцию addEvent. Теперь уже нельзя где-нибудь воспользоваться какой-нибудь конструкцией, похожей \r\nна <a href=\"#\" onclick=\"doStuff();\">...;</a>. С точки зрения ненавязчивого программирования она никуда \r\nне годится, поскольку код фактически останется не у дел, если JavaScript отключен, или если \r\nпользователь работает на старой версии браузера, не поддерживающей эту конструкцию. Поскольку вы \r\nнаправляете пользователей на бессмысленный URL, те из них, кто не имеет поддержки функций сценария, \r\nбудут лишены интерактивности. \r\nЕсли это еще не совсем очевидно, вам нужно симулировать полное отсутствие у пользователя установки \r\nJavaScript, или ущербность его браузера. Попробуйте открыть свой браузер, посетить любимую веб-страницу и \r\nотключить JavaScript, будет ли она после этого по-прежнему работать? А как насчет всех каскадных таблиц \r\nстиля —  CSS, и можете ли вы по-прежнему осуществлять все необходимые переходы? И, наконец, можно ли \r\nпользоваться вашим веб-сайтом без мыши? Все это должно стать частью завершающей задачи для вашего веб-\r\nсайта. Но благодаря тому, что вы приобрели превосходное понимание того, как создается по-настоящему \r\nэффективный код JavaScript, издержки от этого перехода незначительны, и его можно достичь с минимальными \r\nусилиями. \r\nПредупреждение отключения JavaScript \r\nСначала нужно выполнить задачу по удалению из ваших HTML-документов всех встроенных обработчиков \r\nсобытий. Есть две, часто появляющиеся проблемные области, на которые нужно обратить внимание в вашем \r\nдокументе: \r\n","\r\n 127\r\n• Если отключить на странице JavaScript и щелкнуть на любой (на всех) ссылках, смогут ли они перенести \r\nвас на нужную веб-страницу? Разработчики довольно часто используют ссылки типа href=\"\" или href=\"#\", \r\nпредполагающие для получения нужных пользователям результатов разработку некого дополнительного \r\nJavaScript-шаманства. \r\n• Если отключить JavaScript, смогут ли все формы работать и должным образом посылать свои данные? \r\nНаиболее распространенная проблема возникает при использовании в качестве динамических меню \r\nэлементов <select> (которые работают только при включенном JavaScript). \r\nТеперь, последовав этим важным урокам, вы получите веб-страницу, которая будет полезна без \r\nограничений для тех людей, у которых отключен JavaScript, и кто продолжает пользоваться ущербными \r\nбраузерами. \r\nОбеспечение независимости ссылок от JavaScript \r\nТеперь, когда пользователь может выполнить на странице все действия, нужно обеспечить ему перед \r\nвыполнением любого действия вполне адекватное извещение. Когда компания Google выпустила Google \r\nAccelerator, который проходит по всем ссылкам на странице и кэширует их для вас, пользователи обнаружили, что \r\nих электронный адрес, почтовые отправления и сообщения были магическим образом удалены без видимых \r\nпричин. Это было обусловлено тем фактом, что разработчики помещали (к примеру) на свои страницы ссылки для \r\nудаления сообщений, а затем, для подтверждения удаления выводили окно подтверждения (используя JavaScript). \r\nНо Google Accelerator полностью игнорировал этот замысел со всплывающим окном, и все равно переходил по \r\nссылке. \r\nЭтот сценарий специально упомянут, чтобы заострить ваше внимание на http-спецификации, которая \r\nиспользуется для транспортировки всех документов и файлов по сети Интернет. Наиболее простой GET-запрос \r\nпроисходит при щелчке на ссылке; POST-запрос происходит при отправке данных формы. В спецификации \r\nутверждается, что никакие GET-запросы не должны иметь побочных разрушительных эффектов (таких как \r\nудаление сообщения), поэтому Google Accelerator и работал таким вот образом. Все это в первую очередь \r\nпроисходило из-за плохого программирования, но не со стороны Google, а со стороны разработчиков веб-\r\nприложений, создававших ссылки. \r\nКороче говоря, все ссылки на вашем веб-сайте не должны вызывать разрушения информации. Если по \r\nщелчку можно удалить, отредактировать или модифицировать любые, принадлежащие пользователю данные, то \r\nдля достижения этой цели вы, скорее всего, должны вместо этого воспользоваться формой. \r\nОтслеживание блокировки CSS \r\nОдна из крайне неприятных ситуаций связана с браузерами, занимающими промежуточное положение \r\nмежду старыми и новыми разработками, слишком устаревшими для поддержки современных JavaScript-\r\nтехнологий, но достаточно новыми для поддержки стилевых установок CSS. При использовании популярной \r\nтехнологии DHTML может быть элемент, который вначале может быть скрыт (либо за счет значения display, \r\nустановленного в none, либо за счет значения visibility, установленного в hidden), а затем он постепенно \r\nпроявляется (за счет использования JavaScript) при первом посещении страницы пользователем. Но если \r\nпользователь не имеет включенной поддержки JavaScript, он этот элемент никогда не увидит. Решение этой \r\nпроблемы показано в листинге 6.16. \r\nЛистинг 6.16. Предоставление технологии проявления изображения после загрузки, безотказно \r\nработающей при отключенном JavaScript \r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \r\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> \r\n<html xmlns=\"http://www.w3.org/1999/xhtml\"> \r\n","\r\n 128\r\n<head> \r\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" /> \r\n  \r\n    <!-- Во время работы сценария к элементу <html> присоединяется новый \r\n       класс, дающий нам возможность узнать, доступен или не JavaScript.--> \r\n    <script>document.documentElement.className = \"js\";</script> \r\n  \r\n    <!-- Если JavaScript доступен, сделать текстовый блок невидимым для \r\n       дальнейшего проявления.--> \r\n    <style>.js #fadein { display: none }</style> \r\n</head> \r\n<body> \r\n    <div id=\"fadein\">Блок всего, что нужно проявить ...;</div> \r\n</body> \r\n</html>  \r\nТеперь эта технология может работать и без DHTML-проявления. Возможность узнать, подключен или \r\nотключен JavaScript, и применить стили, дает большой выигрыш предусмотрительным веб-разработчикам. \r\nДоступность события \r\nПоследнее, что осталось рассмотреть в разработке по-настоящему ненавязчивого веб-приложения — это \r\nвопрос обеспечения работы событий без использования мыши. Решая эту задачу, мы помогаем двум категориям \r\nлюдей: нуждающимся в помощи при доступе к информации (пользователям с ослабленным зрением), и людям, \r\nкоторые не любят пользоваться мышью. (Как-нибудь сядьте за компьютер, отключите от него мышь, и посмотрите, \r\nкак перемещаться по ресурсам Интернета, используя только клавиатуру. У вас на многое откроются глаза.) \r\nЧтобы сделать события JavaScript более доступными, везде, где используются события click, mouseover и \r\nmouseout, вам нужно серьезно подумать о предоставлении альтернативных, не связанных с мышью привязок. К \r\nсчастью, есть довольно простые способы, с помощью которых можно выправить эту ситуацию: \r\nСобытие щелчка (click): Разработчики браузеров предприняли один очень мудрый шаг, и привязали \r\nвозникновение событие щелчка к каждому нажатию клавиши Enter. В результате этого необходимость в \r\nпредоставлении каких-то альтернатив в отношении этого события полностью отпала. Тем не менее, нужно иметь в \r\nвиду, что некоторым разработчикам нравится привязывать обработчики щелчка к имеющимся в формах кнопкам \r\nпередачи данных —  submit, чтобы отслеживать, когда пользователь отправляет данные с веб-страницы. Вместо \r\nиспользования этого события, разработчик должен привязываться к событию формы submit, что станет более \r\nразумной и надежно работающей альтернативой. \r\nСобытие прохождения указателя мыши над элементом (mouseover): При перемещениях по веб-странице с \r\nиспользованием клавиатуры вы фактически переключаете фокус с одного элемента на другой. Привязывая \r\nобработчик событий как к mouseover, так и к focus, вы сможете гарантировать наличие совместимого решения как \r\nдля тех, кто использует клавиатуру, так и для тех, кто пользуется мышью. \r\nСобытие выхода указателя мыши за пределы элемента (mouseout): Если событие focus перекликается с \r\nсобытием mouseover, то событие blur возникает, когда фокус выходит за пределы элемента. Поэтому событие blur \r\nможно использовать в качестве средства, имитирующего событие mouseout с помощью клавиатуры. \r\nТеперь, узнав, какие пары элементов ведут себя нужным для нас образом, можно еще раз обратиться к \r\nлистингу 6.3, чтобы создать эффект, похожий на проход указателя мыши, который будет работать и без мыши (см. \r\nлистинг 6.17). \r\n","\r\n 129\r\nЛистинг 6.17. Привязка к элементам пар событий, позволяющая получить всеобщий доступ к \r\nиспользованию веб-страницы \r\n// Обнаружение всех элементов <a>, для привязки к ним обработчиков событий \r\nvar li = document.getElementsByTagName(\"a\"); \r\nfor ( var i = 0; i < a.length; i++ ) { \r\n  \r\n    // Привязка обработчика событий mouseover и focus к элементу <a>, \r\n    // с помощью которого цвет фона <a> изменяется на синий, когда \r\n    // либо перемещает над ссылкой указатель мыши, либо устанавливает на нее \r\n    // фокус (используя клавиатуру) \r\n    a[i].onmouseover = a[i].onfocus = function() { \r\n       this.style.backgroundColor = 'blue'; \r\n    }; \r\n  \r\n    // Привязка обработчика событий mouseout и blur к элементу <a>, \r\n    // с помощью которого цвет фона <a> возвращается к исходному белому, \r\n    // когда пользователь покидает ссылку \r\n    a[i].onmouseout = a[i].onblur = function() { \r\n       this.style.backgroundColor = 'white'; \r\n    }; \r\n}  \r\nНа практике добавление возможности обработки событий клавиатуры в дополнение к обычным событиям \r\nработы с мышью представляет собой вполне обычную задачу. Ее решение по крайней мере сможет облегчить \r\nпользователям, зависящим от использования клавиатуры, работу с вашим веб-сайтом, что станет большой \r\nпобедой для всех. \r\nВывод \r\nТеперь, когда вы узнали как перемещаться по DOM, и привязывать к DOM-элементам обработчики \r\nсобытий, а также узнали о всех преимуществах создания ненавязчивого кода JavaScript, можно приступать к \r\nсозданию крупных приложений и интересных эффектов. \r\nВ начале этой главы я представил работу событий в JavaScript и сравнил их с моделями событий в других \r\nязыках программирования. Затем вам было показано, какую информацию предоставляет модель события, и как ей \r\nможно лучше распорядиться. Затем был исследован вопрос привязки событий к DOM-элементам, и различные \r\nвиды доступных событий. В заключение было показано, как при создании сценариев интегрировать некоторые \r\nэффективные и ненавязчивые технологии в вашу веб-страницу. \r\nДалее я собираюсь рассмотреть, как выполняется ряд динамических эффектов и взаимных действий, в \r\nкоторых вся изученная нами технология используется наилучшим образом. \r\n","\r\n 130\r\nГлава 7 JavaScript и CSS \r\nВзаимодействие JavaScript и CSS — главная опора современного JavaScript-программирования. Фактически \r\nот всех современных веб-приложений по меньшей мере требуется использование хоть какой-нибудь формы \r\nдинамического взаимодействия. Когда это требование выполняется, пользователь получает возможность быстрее \r\nперемещаться по информационному наполнению и меньше тратить времени на ожидание загрузки страниц. \r\nОбъединение динамической технологии с теми идеями о событиях, которые были представлены в главе 6, \r\nявляется основой для создания у пользователей цельного и яркого впечатления. \r\nКаскадные таблицы стилей стали фактическим стандартом для задания стилей и компоновки удобных и \r\nпривлекательных веб-страниц, и они по-прежнему предоставляют разработчикам самое большое количество \r\nвозможностей, доставляя при этом пользователям наименьшее количество хлопот. Примечательно, что \r\nобъединение этих возможностей с JavaScript позволяет создавать мощные интерфейсы, включая такие вещи, как \r\nанимация, элементы управления окнами или динамическое отображение данных. \r\nДоступ к информации о стилях \r\nСочетание JavaScript и CSS всецело направлено на получение результата за счет взаимодействия. Для \r\nдостижения нужного набора взаимодействующих структур очень важно понимать, что именно вам доступно. \r\nИсходным инструментом для установки и получения присущих элементу свойств CSS, является его \r\nсвойство style. К примеру, если нужно получить высоту элемента, то можно воспользоваться следующим кодом: \r\nelem.style.height. А если нужно установить определенный размер высоты элемента, можно воспользоваться \r\nследующим кодом: elem.style.height = '100px'. \r\nПри работе со свойствами CSS DOM-элементов вы столкнетесь с двумя проблемами, связанными с их \r\nнеожиданным поведением. Во-первых, JavaScript при установке любого свойства, относящегося к размеру, \r\nтребует, чтобы определялась единица измерения (как это было сделано в предыдущем случае). И в то же время, \r\nлюбое, связанное с размером свойство вместо числа также возвращает строку, представляющую свойство style \r\nэлемента (к примеру, 100px вместо 100). \r\nВо-вторых, если высота элемента составляет 100 пикселов, и вы пытаетесь получить значение его текущей \r\nвысоты, то еще не факт, что будет получено ожидаемое от свойства style значение 100px. Все дело в том, что \r\nлюбая информация о стиле, предустановленная с использованием таблиц стиля или встроенного CSS отражается в \r\nсвойстве style не вполне достоверно. \r\nЭто вынуждает нас создать для работы с CSS в JavaScript весьма важную функцию: метод для извлечения \r\nреально существующих, текущих свойств стиля элемента, который дает точное, вполне ожидаемое значение. Для \r\nтого, чтобы справиться с проблемой вычисляемых значений стиля, существует довольно надежный набор методов, \r\nкоторым можно воспользоваться для получения фактических, вычисляемых свойств стиля DOM-элемента. При \r\nвызове этих методов (которые представлены в W3C- и IE-специфических вариантах) вы получаете реально \r\nсуществующее вычисляемое значение стиля элемента. В этих методах принимаются во внимание все прошлые \r\nтаблицы стилей и относящиеся к элементу свойства наряду с текущей модификацией JavaScript. Использование \r\nэтих методов принесет большую пользу при разработке точного представления тех элементов, с которыми вы \r\nработаете. \r\nТакже важно принять во внимание многочисленные различия, существующие между браузерами при \r\nполучении вычисляемых значений стиля элемента. Как и во многом остальном, Internet Explorer имеет одну \r\nметодику получения текущего вычисляемого стилевого значения элемента, а остальные браузеры используют \r\nдругую методику, определенную консорциумом W3C. \r\n","\r\n 131\r\nФункция для обнаружения вычисляемых значений стиля элемента показана в листинге 7.1, а пример \r\nвашей новой функции в действии показан в листинге 7.2. \r\nЛистинг 7.1. Функция для получения реального вычисленного значение принадлежащего элементу CSS-\r\nсвойства Style \r\n// Получение свойства style (name) определенного элемента (elem) \r\nfunction getStyle( elem, name ) { \r\n    // Если свойство присутствует в style[], значит, оно было \r\n    // недавно установлено (и является текущим) \r\n    if (elem.style[name]) \r\n       return elem.style[name]; \r\n  \r\n    // В противном случае, попытка воспользоваться методом IE \r\n    else if (elem.currentStyle) \r\n       return elem.currentStyle[name]; \r\n  \r\n    // Или методом W3C, если он существует \r\n    else if (document.defaultView && document.defaultView.getComputedStyle) { \r\n       // Вместо textAlign в нем используется традиционное правило \r\n       // написания стиля — 'text-align' \r\n       name = name.replace(/([A-Z])/g,\"-$1\"); \r\n       name = name.toLowerCase(); \r\n  \r\n        // Получение объекта style и получение значения свойства \r\n       // (если оно существует) \r\n       var s = document.defaultView.getComputedStyle(elem,\"\"); \r\n       return s && s.getPropertyValue(name); \r\n  \r\n    // В противном случае, мы используем какой-то другой браузер \r\n    } else \r\n       return null; \r\n}  \r\nЛистинг 7.2. Ситуация, в которой вычисляемое CSS-значение элемента не обязательно совпадает со \r\nзначением, которое доступно в объекте style \r\n  \r\n<html> \r\n<head> \r\n    <style>p { height: 100px; }</style> \r\n    <script> \r\n    window.onload = function(){ \r\n       // Обнаружение абзаца для проверки его высоты \r\n       var p = document.getElementsByTagName(\"p\")[0]; \r\n  \r\n       // Проверка высоты традиционным способом \r\n       alert( p.style.height + \" значение должно быть равно null\" ); \r\n  \r\n","\r\n 132\r\n       // Проверка вычисляемого значение высоты \r\n       alert( getStyle( p, \"height\" ) + \" должно быть 100px\" ); \r\n    }; \r\n    </script> \r\n</head> \r\n<body> \r\n    <p>Мой рост должен быть 100 пикселов.</p> \r\n</body> \r\n</html> \r\nВ листинге 7.2 показано, как можно получить фактическое вычисленное значение CSS-свойства DOM-\r\nэлемента. В данном случае вы получаете фактическую высоту элемента в пикселах, даже если эта высота \r\nустановлена через CSS в заголовке файла. Важно отметить, что ваша функция игнорирует альтернативные \r\nединицы измерения (к примеру, те, в которых используется процентное отношение). И хотя это решение не \r\nявляется всецело приемлемым, оно заложило неплохие стартовые позиции. \r\nТеперь, располагая этим инструментом, вы можете посмотреть, как получать и устанавливать нужные вам \r\nсвойства для создания некоторых основных моментов взаимодействия DHTML. \r\nДинамические элементы \r\nПод динамическим понимается элемент, управляемый с использованием JavaScript и CSS для создания \r\nнестатических эффектов (простым примером может послужить флажок, указывающий на ваш интерес к \r\nинформационным бюллетеням, и всплывающая область ввода сообщений электронной почты). \r\nВ создании динамических эффектов в основном используются три главных свойства: позиции, размера и \r\nвидимости. Пользуясь тремя этими свойствами вы можете воспроизводить на современных браузерах наиболее \r\nчасто встречающиеся моменты взаимодействия с пользователем. \r\nПозиция элемента \r\nРабота с позицией элемента является важной строительной составляющей для разработки на веб-странице \r\nинтерактивных элементов. Обращение к CSS-свойствам позиции и изменение их значений дает возможность \r\nэффективно воспроизводить ряд распространенных анимационных эффектов и интерактивных действий (к \r\nпримеру, осуществлять перетаскивание). \r\nВажным шагом в работе с позиционированием элементов является знание такого, часто востребуемого \r\nвопроса, как работа системы позиционирования в CSS. В CSS элементы позиционируются с использованием \r\nсмещений. Используемое при этом измерение представляет собой значение смещения от левого верхнего угла \r\nродительского элемента. Пример системы координат, используемой в CSS, показан на рис. 7.1. \r\n","\r\n 133\r\n \r\nРис. 7.1. Пример системы координат на веб-странице при использовании CSS \r\nЭлемента на странице имеют то или иное смещение сверху (вертикальная координата) и слева \r\n(горизонтальная координата). Вообще-то большинство элементов в зависимости от тех элементов, которые их \r\nокружают, имеют простое статическое позиционирование. Согласно предложениям стандарта CSS, элемент \r\nдолжен иметь ряд различных схем позиционирования. Чтобы в этом лучше разобраться, посмотрим на обычную \r\nHTML веб-страницу, показанную в листинге 7.3. \r\nЛистинг 7.3.   HTML веб-страница, которой можно воспользоваться для демонстрации различий в \r\nпозиционировании \r\n  \r\n<html> \r\n<head> \r\n<style> \r\np{ \r\n    border: 3px solid red; \r\n    padding: 10px; \r\n    width: 400px; \r\n    background: #FFF; \r\n} \r\n  \r\np.odd { \r\n    /* Сюда помещается информация о позиционировании */ \r\n    position: static; \r\n    top: 0px; \r\n    left: 0px; \r\n} \r\n</style> \r\n</head> \r\n<body> \r\n","\r\n 134\r\n    <p>Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Etiam ...;p> \r\n<p class='odd'>Phasellus dictum dignissim justo. Duis nec risus id \r\n                                                           nunc...;p> \r\n    <p>Sed vel leo. Nulla iaculis, tortor non laoreet dictum, turpis diam \r\n                                                                ...;</p> \r\n</body> \r\n</html>  \r\nПосмотрим, как с установками, имеющимися в нашей простой HTML-странице, изменяется \r\nпозиционирование второго параграфа при различных схемах компоновки веб-сайта: \r\nСтатическое позиционирование: Это исходный способ позиционирования элемента; он просто следует \r\nнормальному ходу формирования документа. Свойства сверху —   top и слева —   left при статическом \r\nпозиционировании элемента не имеют никакого эффекта. На рис. 7.2 показан абзац, который имеет следующее \r\nCSS-позиционирование: position: static; top: 0px; left: 0px;. \r\n \r\n","\r\n 135\r\nРис. 7.2. Абзац при обычном (статическом) формировании страницы \r\nОтносительное позиционирование: Этот способ позиционирования очень похож на статическое \r\nпозиционирование, поскольку элемент будет так же следовать обычному ходу формирования документа, пока ему \r\nне будет указано что-либо иное. Но установка свойств top или left приведет к смещению элемента по отношению \r\nоригинальной (статической) позиции. Пример относительного позиционирования с использованием CSS position: \r\nrelative; top: -50px; left: 50px; показан на рис. 7.3. \r\n \r\nРис. 7.3. Относительное позиционирование, при котором элемент смещен вверх и перекрывает \r\nпредыдущий элемент, а не следует обычному ходу формирования документа \r\nАбсолютное позиционирование: Абсолютное позиционирование элемента полностью выключает его из \r\nнормального хода формирования документа. При абсолютном позиционировании элемент будет отображен \r\nотносительно первого родительского элемента, который не имеет статической позиции. Если родительские \r\nэлементы отсутствуют , он позиционируется относительно всего документа. Пример абсолютного \r\nпозиционирования с использованием CSS position: absolute; top: 20px; left: 0px; показан на рис. 7.4. \r\n","\r\n 136\r\n \r\nРис. 7.4. Абсолютное позиционирование, при котором элемент позиционированный относительно левого \r\nверхнего угла страницы, находится поверх того элемента, который уже был отображен на этом месте \r\nФиксированное позиционирование: Фиксированное позиционирование работает за счет позиционирования \r\nэлемента относительно окна браузера. Установка значения свойств элемента top и left в 0 пикселов приведет к \r\nотображению этого элемента в верхнем левом углу браузера на все время пребывания пользователя на этой \r\nстранице, при этом все случаи использования прокрутки окна браузера этим элементом будут полностью \r\nпроигнорированы. Пример фиксированного позиционирования с использованием CSS position: fixed; top: 20px; \r\nright: 0px; показан на рис. 7.5. \r\nЗнание того, как может быть позиционирован элемент, играет важную роль в понимании, где элемент \r\nдолжен быть размещен в DOM-структуре, или какое средство позиционирования нужно использовать для \r\nдостижения наилучшего эффекта. \r\nТеперь мы посмотрим, как извлечь и использовать точную позицию элемента, независимо от того, какая \r\nкомпоновка применяется, или какие CSS-свойства установлены. \r\n","\r\n 137\r\n \r\nРис. 7.5. Фиксированное позиционирование, при котором элемент позиционируется в левом верхнем углу \r\nстраницы, даже если окно браузера прокручено вниз \r\nПолучение позиции \r\nРазмещение элемента варьируется в зависимости от его CSS-параметров и того контента, который \r\nнепосредственно к нему примыкает. Один только доступ к CSS-свойствам или к их вычисленным значениям еще \r\nне предоставляет возможность узнать точную позицию на странице, или даже внутри другого элемента. \r\nДля начала рассмотрим нахождение позиции элемента на странице. Для получения этой информации в \r\nвашем распоряжении имеется несколько свойств элемента. Следующие три свойства поддерживаются всеми \r\nсовременными браузерами, а вот как они их обрабатываю, это уже другой вопрос: \r\noffsetParent: Теоретически это свойство указывает на родительский элемент, внутри которого \r\nосуществляется позиционирование. Но на практике элемент, на который ссылается offsetParent зависит от \r\nбраузера (к примеру, в Firefox он ссылается на корневой узел, а в Opera — на непосредственно родительский \r\nэлемент). \r\noffsetLeft и offsetTop: Эти параметры являются горизонтальным и вертикальным смещением элемента в \r\nпределах контекста offsetParent. Хорошо, что во всех современных браузерах их назначение точно соблюдается. \r\nТеперь самым хитрым делом будет найти способ определения подходящей кроссбраузерной системы \r\nизменений размещения элементов. Наиболее унифицированным способом решения этой задачи будет \r\nиспользование методов, представленных в листинге 7.4, с помощью которых осуществляется перемещение вверх \r\nпо дереву DOM с использованием свойства offsetParent, и сложения встречающихся на этом пути значений \r\nсмещения. \r\nЛистинг 7.4. Две вспомогательные функции для определения местоположения элемента (x и y) \r\nотносительно всего документа \r\n// Определение X (горизонтальной слева) позиции элемента \r\nfunction pageX(elem) { \r\n    // Проверка на достижение корневого элемента \r\n    return elem.offsetParent ? \r\n","\r\n 138\r\n  \r\n       // Если не дошли до самого верха, добавление текущего смещения и \r\n       // продолжение движения вверх \r\n       elem.offsetLeft + pageX( elem.offsetParent ) : \r\n  \r\n       // В противном случае, получение текущего смещения \r\n       elem.offsetLeft; \r\n} \r\n  \r\n// Определение Y (вертикальной сверху) позиции элемента \r\nfunction pageY(elem) { \r\n    // Проверка на достижение корневого элемента \r\n    return elem.offsetParent ? \r\n  \r\n       // Если не дошли до самого верха, добавление текущего смещения и \r\n       // продолжение движения вверх \r\n       elem.offsetTop + pageY( elem.offsetParent ) : \r\n  \r\n       // В противном случае, получение текущего смещения \r\n       elem.offsetTop; \r\n}  \r\nСледующая часть головоломки с позиционированием заключается в определении горизонтальной и \r\nвертикальной позиции элемента в пределах его родителя. Важно отметить, что для этого вовсе недостаточно \r\nиспользовать свойства элемента style.left или style.top, поскольку вам может потребоваться определить позицию \r\nэлемента, стиль которого не задавался при помощи JavaScript или CSS. \r\nИспользуя позицию элемента относительно его родителя вы сможете добавлять в DOM дополнительные \r\nэлементы, относительно их родительских элементов. Это, к примеру, особенно пригодится для создания \r\nконтекстных подсказок. \r\nЧтобы найти позицию элемента относительно его родительского элемента, нужно опять вернуться к \r\nсвойству offsetParent. Поскольку это свойство не гарантирует возвращения фактического родителя для заданного \r\nэлемента, для обнаружения разницы между родительским и дочерним элементами необходимо воспользоваться \r\nфункциями pageX и pageY. В двух функциях, показанных в листинге 7.5, я пытаюсь сначала воспользоваться \r\nсвойством offsetParent, если оно действительно указывает на фактического родителя текущего элемента; в \r\nпротивном случае я продолжаю перемещаться вверх по DOM, используя методы pageX и pageY для определения \r\nего реальной позиции. \r\nЛистинг 7.5. Две функции для определения позиции элемента относительно его родительского элемента \r\n// Определение горизонтальной позиции элемента внутри его родителя \r\nfunction parentX(elem) { \r\n    // Если offsetParent указывает на родителя элемента, то раннее \r\n    // завершение работы \r\n    return elem.parentNode == elem.offsetParent ? \r\n       elem.offsetLeft : \r\n  \r\n       // В противном случае нужно найти позицию относительно всей страницы \r\n       // для обоих элементов и вычислить разницу \r\n","\r\n 139\r\n       pageX( elem ) -pageX( elem.parentNode ); \r\n} \r\n  \r\n// Определение вертикальной позиции элемента внутри его родителя \r\nfunction parentY(elem) { \r\n    // Если offsetParent указывает на родителя элемента, то раннее \r\n    // завершение работы \r\n    return elem.parentNode == elem.offsetParent ? \r\n       elem.offsetTop : \r\n  \r\n       // В противном случае нужно найти позицию относительно всей страницы \r\n       // для обоих элементов и вычислить разницу \r\n       pageY( elem ) -pageY( elem.parentNode ); \r\n}  \r\nЗаключительная часть работы с позиционированием элементов заключается в определении позиции \r\nэлемента относительно его CSS-контейнера. Как ранее уже было рассмотрено, элемент фактически может быть \r\nсодержимым одного элемента, а позиционирован относительного другого родительского элемента (с \r\nиспользованием относительного и абсолютного позиционирования). Имея это в виду, вы можете вернуться \r\nобратно к функции getStyle и определить вычисленное значение CSS-смещения, поскольку именно ему позиция и \r\nравна. \r\nЧтобы справиться с этой задачей есть две простые интерфейсные функции, показанные в листинге 7.6, \r\nкоторыми можно воспользоваться. Обе они просто вызывают функцию getStyle, но также еще и удаляют любую \r\n«внешнюю» (пока вы не станете использовать там, где это нужно, не пиксельный формат) информацию о \r\nединицах измерения (к примеру, 100px превратится в 100). \r\nЛистинг 7.6. Вспомогательные функции для определения CSS-позиционирования элемента \r\n// Определения левой позиции элемента \r\nfunction posX(elem) { \r\n    // Получение вычисляемого значения style и извлечение числа из значения \r\n    return parseInt( getStyle( elem, \"left\" ) ); \r\n} \r\n  \r\n// Определение верхней позиции элемента \r\nfunction posY(elem) { \r\n    // Получение вычисляемого значения style и извлечение числа из значения \r\n    return parseInt( getStyle( elem, \"top\" ) ); \r\n}  \r\nУстановка позиции \r\nВ отличие от получения позиции элемента, ее установка носит значительно менее гибкий характер. Но \r\nкогда она используется в сочетании с различными способами задания формата (абсолютным, относительным, \r\nфиксированным), вы можете получить вполне сопоставимые и приемлемые результаты. \r\nВ настоящее время существует только один способ корректировки позиции элемента — изменение его \r\nCSS-свойств. Чтобы сохранить постоянство методологии, вам нужно подвергать изменениям лишь свойства left и \r\ntop, хотя существуют и другие свойства (снизу — bottom и справа — right). Для начала вы можете просто создать \r\n","\r\n 140\r\nпару функций, показанных в листинге 7.7, которые можно будет использовать для установки позиции элемента \r\nнезависимо от его текущего положения. \r\nЛистинг 7.7. Две функции для установки x и y позиций элемента, независимо от его текущей позиции \r\n// Функция для установки горизонтальной позиции элемента \r\nfunction setX(elem, pos) { \r\n    // Установка CSS-свойства 'left' с использованием единицы измерения, \r\n    // выраженной в пикселах \r\n    elem.style.left = pos + \"px\"; \r\n} \r\n  \r\n// Функция для установки вертикальной позиции элемента \r\nfunction setY(elem, pos) { \r\n    // Установка CSS-свойства 'top' с использованием единицы измерения, \r\n    // выраженной в пикселах \r\n    elem.style.top = pos + \"px\"; \r\n}  \r\nТем не менее, становится вполне очевидной необходимость разработки второго набора функций, \r\nпоказанного в листинге 7.8, который можно будет использовать для установки позиции элемента относительно его \r\nпоследней позиции — к примеру, установить элемент на 5 пикселов левее его текущей позиции. Использование \r\nэтих методов тесно связано с различными анимационными эффектами, являющимися основой DHTML-разработки. \r\nЛистинг 7.8. Две функции для установки позиции элемента относительно его текущей позиции \r\n// Функция добавления пикселов к горизонтальной позиции элемента. \r\nfunction addX(elem,pos) { \r\n    // Получение текущей горизонтальной позиции и добавление к ней \r\n    // смещения. \r\n    setX( posX(elem) + pos ); \r\n} \r\n  \r\n// Функция добавления пикселов к вертикальной позиции элемента. \r\nfunction addY(elem,pos) { \r\n    // Получение текущей вертикальной позиции и добавление к ней \r\n    // смещения. \r\n    setY( posY(elem) + pos ); \r\n}  \r\nВот теперь я полностью прошелся по всей               палитре работы, связанной с позиционированием \r\nэлемента. Представление о том, как работает позиционирование элемента, как получать и устанавливать его \r\nточную позицию, является основным аспектом работы с динамическими элементами. Следующей стороной этой \r\nработы, которую я собираюсь рассмотреть, является точный размер элемента. \r\nРазмер элемента \r\nОпределение высоты и ширины элемента может быть как невероятно простой, так и мучительно тяжелой \r\nзадачей, в зависимости от ситуации и той цели, для которой она выполняется. В большинстве случаев для \r\nполучения текущей высоты и ширины элемента нужно будет всего лишь воспользоваться модифицированной \r\nверсией функции getStyle (см. листинг 7.9). \r\n","\r\n 141\r\nЛистинг 7.9. Две функции для извлечения текущей высоты или ширины DOM-элемента \r\n// Получение текущей высоты элемента (с использованием вычисляемого CSS) \r\nfunction getHeight( elem ) { \r\n    // Получение вычисляемого значения CSS и извлечение необходимого \r\n    // числового значения \r\n    return parseInt( getStyle( elem, 'height' ) ); \r\n} \r\n  \r\n// Получение текущей ширины элемента (с использованием вычисляемого CSS) \r\nfunction getWidth( elem ) { \r\n    // Получение вычисляемого значения CSS и извлечение необходимого \r\n    // числового значения \r\n    return parseInt( getStyle( elem, 'width' ) ); \r\n}  \r\nСложности возникают при попытке сделать две вещи: первое, когда вам нужно получить полную высоту \r\nэлемента, у которого есть предопределенная высота (к примеру, вы начинаете анимацию с 0 пикселов, но вам \r\nнужно узнать насколько высоким или широким может быть элемент), и второе, это значение получить \r\nневозможно, когда элемент невидим, то есть его свойство display имеет значение none. Обе эти проблемы \r\nвозникают при попытке выполнения анимационного эффекта. Вы начинаете анимацию объекта (который к этому \r\nмоменту вполне возможно имеет значение display установленное в none) с 0 пикселов, и вам нужно развернуть \r\nего в высоту до полного размера. \r\nВ листинге 7.10 представлены две функции, показывающие, как можно определить потенциальную высоту \r\nи ширину элемента независимо от его текущих значений высоты и ширины. Эта задача выполняется за счет \r\nобращения к свойствам clientWidth и clientHeight, предоставляющим полную возможную область прокрутки \r\nэлемента. \r\nЛистинг 7.10. Две функции для получения полной потенциальной высоты или ширины элемента, даже \r\nесли он скрыт \r\n// Получение полной возможной высоты элемента (в отличие от фактической \r\n// текущей высоты) \r\n  \r\nfunction fullHeight( elem ) { \r\n    // Если элемент отображен на экране, то сработает свойство \r\n    // offsetHeight а если оно не сработает, то сработает getHeight() \r\n    if ( getStyle( elem, 'display' ) != 'none' ) \r\n       return elem.offsetHeight || getHeight( elem ); \r\n  \r\n    // В противном случае нам придется иметь дело с элементом, \r\n    // у которого display имеет значение none, поэтому \r\n    // нужно переустановить его CSS-свойства, чтобы считать более \r\n    // точный результат \r\n    var old = resetCSS( elem, { \r\n       display: '', \r\n       visibility: 'hidden', \r\n       position: 'absolute' \r\n    }); \r\n","\r\n 142\r\n  \r\n    // Определяем полную высоту элемента, используя clientHeight, \r\n    // а если это свойство не работает, используем getHeight \r\n    var h = elem.clientHeight || getHeight( elem ); \r\n  \r\n    // В завершение восстанавливаем прежние CSS-свойства \r\n    restoreCSS( elem, old ); \r\n  \r\n    // и возвращаем полную высоту элемента \r\n    return h; \r\n} \r\n  \r\n// Получение полной возможной ширины элемента (в отличие от фактической \r\n// текущей ширины) \r\nfunction fullWidth( elem ) { \r\n    // Если элемент отображен на экране, то сработает свойство \r\n    // offsetWidth а если оно не сработает, то сработает getWidth() \r\n    if ( getStyle( elem, 'display' ) != 'none' ) \r\n       return elem.offsetWidth || getWidth( elem ); \r\n  \r\n    // В противном случае нам придется иметь дело с элементом, \r\n    // у которого display имеет значение none, поэтому \r\n    // нужно переустановить его CSS-свойства, чтобы считать более \r\n    // точный результат \r\n    var old = resetCSS( elem, { \r\n       display: '', \r\n       visibility: 'hidden', \r\n       position: 'absolute' \r\n    });  \r\n  \r\n    // Определяем полную ширину элемента, используя clientWidth, \r\n    // а если это свойство не работает, используем getWidth \r\n    var w = elem.clientWidth || getWidth( elem ); \r\n  \r\n    // В завершение восстанавливаем прежние CSS-свойства \r\n    restoreCSS( elem, old ); \r\n  \r\n    // и возвращаем полную ширину элемента \r\n    return w; \r\n} \r\n  \r\n// Функция, используемая для переустановки набора CSS-свойств, которые \r\n// позже можно будет восстановить \r\nfunction resetCSS( elem, prop ) { \r\n    var old = {}; \r\n  \r\n    // Перебор всех свойств \r\n","\r\n 143\r\n    for ( var i in prop ) { \r\n       // Запоминание старых значений свойств \r\n       old[ i ] = elem.style[ i ]; \r\n  \r\n       // и установка новых значений \r\n       elem.style[ i ] = prop[i]; \r\n    } \r\n  \r\n    // возвращение набора значений для использования в функции restoreCSS \r\n    return old; \r\n} \r\n  \r\n// Функция для устранения побочных эффектов функции resetCSS \r\nfunction restoreCSS( elem, prop ) { \r\n    // Переустановка всех свойств и возвращение им первоначальных значений \r\n    for ( var i in prop ) \r\n       elem.style[ i ] = prop[ i ]; \r\n}  \r\nИмея возможность получить как текущую, так и потенциальную высоту и ширину элемента, вы можете \r\nпопробовать применить некоторые анимационные эффекты, доступные благодаря использованию этих значений. \r\nНо перед тем как перейти к подробностям анимации, вам следует рассмотреть вопрос изменения видимости \r\nэлемента. \r\nВидимость элемента \r\nВидимость элемента — довольно мощный инструмент, который может быть использован в JavaScript для \r\nсоздания многих вещей, от анимации и эффектов и до быстрого вывода шаблонов. Но важнее всего то, что это \r\nсвойство может быть использовано для быстрого устранения элемента из поля зрения пользователя, предоставляя \r\nему некоторые основные возможности интерактивной работы. \r\nС использованием CSS существует два различных способа эффективного устранения элемента из поля \r\nвидимости, у каждого из которых есть как свои преимущества, так и непредвиденные последствия, в зависимости \r\nот того, как именно они будут использоваться: \r\n• Свойство visibility переключает видимость элемента, сохраняя при этом обычный ход формирования \r\nдокумента. Свойство visibility может иметь два значения: видимый — visible (по умолчанию) и скрытый — \r\nhidden (чтобы сделать элемент полностью невидимым). К примеру, если у вас есть текст, обрамленный \r\nтегами <b>, а его свойство visibility установлено в hidden, это выразится в простом блоке пробелов в \r\nтексте, точно такого же размера, как и оригинальный текст. Сравните, к примеру две следующие \r\nтекстовые строки: \r\n    // Обычный текст: \r\n    Hello John, how are you today? \r\n  \r\n    // а теперь к элементу 'John' применено visibility: hidden \r\n    Hello     , how are you today? \r\n• Свойство display предоставляет разработчику более широкий выбор для управления формированием \r\nэлементов. Этот выбор варьируется между линейным значением — inline (такие теги, как <b> и <span> \r\n","\r\n 144\r\nявляются линейными, потому что следуют обычному текстовому потоку), блочным значением — block \r\n(такие теги, как <p> и <div> являются блоками, потому, что они разбивают обычный текстовый поток), и \r\nзначением none (которое предписывает полное устранение элемента из документа). Результат установки \r\nдля элемента свойства display выглядит, как будто вы только что удалили элемент из документа, но не \r\nполностью, поскольку позже он может быть быстро возвращен в поле видимости. Поведение свойства \r\ndisplay отображено в следующих строках: \r\n    // Обычный текст: \r\n    Hello John, how are you today? \r\n  \r\n    // а теперь к элементу 'John' применено display: none \r\n    Hello, how are you today? \r\nХотя у свойства visibility есть свои особенности применения, важность свойства display трудно \r\nпереоценить. Тот факт, что при установке свойства visibility в hidden элемент при обычном ходе формирования \r\nдокумента все еще существует, снижает возможность применения этого свойства в большинстве приложений. В \r\nлистинге 7.11 показаны два метода, которые могут быть использованы для переключения видимости элемента с \r\nиспользованием свойства display. \r\nЛистинг 7.11. Набор функций для переключения видимости элемента с использованием его CSS-свойства \r\ndisplay \r\n// Функция для скрытия элемента (с использование свойства display) \r\nfunction hide( elem ) { \r\n    // Определение текущего состояния свойства display \r\n    var curDisplay = getStyle( elem, 'display' ); \r\n  \r\n    // Запоминание состояния свойства display на будущее \r\n    if ( curDisplay != 'none' ) \r\n       elem.$oldDisplay = curDisplay; \r\n  \r\n    // Установка display в none (скрытие элемента) \r\n    elem.style.display = 'none'; \r\n} \r\n  \r\n// Функция показа элемента (с использованием свойства display) \r\nfunction show( elem ) { \r\n    // Возвращение свойства display к тому значению, которое им \r\n    // использовалось, или использование \r\n    // 'block', если предыдущее состояние этого свойства не было \r\n    // сохранено \r\n    elem.style.display = elem.$oldDisplay || ''; \r\n}  \r\nВторой стороной видимости элемента является степень его прозрачности — opacity. Корректировка \r\nстепени прозрачности элемента приводит к результату, очень похожему на корректировку его видимости, но при \r\nэтом предоставляет больше возможностей для управления его видимостью. Это означает, что вы можете получать \r\nэлемент с 50% видимостью, и видеть элемент, который находится под ним. И опять-таки, несмотря на то, что все \r\nсовременные браузеры в известной степени поддерживают прозрачность, и Internet Explorer (что касается IE 5.5), \r\nи W3C-совместимые браузеры имеют различия в ее реализации. Чтобы обойти это обстоятельство, для управления \r\n","\r\n 145\r\nпрозрачностью элемента нужно создавать стандартную функцию, показанную в листинге 7.12. Уровень 0 \r\nозначает, что элемент полностью прозрачен, а уровень 100 — что он полностью непрозрачен. \r\nЛистинг 7.12. Функция, предназначенная для корректировки уровня прозрачности элемента \r\n// Установка уровня прозрачности элемента \r\n// (где уровень является числом в диапазоне 0-100) \r\nfunction setOpacity( elem, level ) { \r\n    // Если существуют какие-нибудь фильтры, значит, \r\n    // мы имеем дело с IE, и нужно устанавливать фильтр Alpha \r\n    if ( elem.filters ) \r\n       elem.style.filters = 'alpha(opacity=' + level + ')'; \r\n       // В противном случае мы используем W3C-свойство opacity \r\n    else \r\n       elem.style.opacity = level / 100; \r\n}  \r\nТеперь, когда в вашем распоряжении имеются способы корректировки позиции, размера и видимости \r\nэлемента, настало время приступить к исследованию некоторых забавных вещей, которые могут быть созданы при \r\nобъединении всех имеющихся возможностей. \r\nАнимация \r\nТеперь, когда у вас уже имеются базовые знания, необходимые для осуществления DHTML-операций, \r\nдавайте рассмотрим один из самых популярных и наглядных эффектов динамических веб-приложений: анимацию. \r\nЕе применение в разумных пределах может предоставить пользователю весьма полезную обратную реакцию \r\nприложения, к примеру, привлечение внимания к только что созданному на экране элементу. \r\nНачнем с рассмотрения двух различных широко распространенных анимационных приемов, а затем еще \r\nраз вернемся к этой теме при рассмотрении наиболее популярных DHTML-библиотек. \r\nВыплывание \r\nПервый анимационный эффект заключается в том, что берется скрытый (с использованием свойство \r\ndisplay, установленного в none) элемент, и вместо использования для его отображения довольно грубой функции \r\nshow(), вы постепенно, в течение секунды, проявляете этот элемент за счет увеличения его высоты. В \r\nлистинге 7.13 показана функция, которую можно применить для замены функции show() эффектом выпадения, \r\nкоторый вызывает у пользователя более плавное визуальное впечатление. \r\nЛистинг 7.13. Функция, предназначенная для медленного появления скрытого элемента за счет \r\nувеличения его высоты в течение секунды \r\nfunction slideDown( elem ) { \r\n    // Начало выплывания вниз с 0 \r\n    elem.style.height = '0px'; \r\n  \r\n    // Показ элемента (но вы его не увидите, пока высота равна 0) \r\n    show( elem ); \r\n  \r\n    // Определение полной, потенциальной высоты элемента \r\n    var h = fullHeight( elem ); \r\n  \r\n","\r\n 146\r\n    // Мы собираемся за секунду показать анимацию, состоящую из \r\n    // 20 'кадров' \r\n    for ( var i = 0; i <= 100; i += 5 ) { \r\n       // Замкнутое выражение, гарантирующее, что у нас в распоряжении \r\n       // находится именно та переменная 'i', которая нам нужна \r\n       (function(){ \r\n           var pos = i; \r\n  \r\n           // Установка времени ожидания для совершения будущих \r\n           // действий в определенное время \r\n           setTimeout(function(){ \r\n  \r\n               // Установка новой высоты элемента \r\n               elem.style.height = ( pos / 100 ) * h ) + \"px\"; \r\n           }, ( pos + 1 ) * 10); \r\n       })(); \r\n    } \r\n}  \r\nПроявление \r\nСледующий анимационный эффект, который мы собираемся рассмотреть, очень похож на предыдущий, но \r\nв нем используется функция setOpacity( ), которая встраивается вместо модификации высоты. Конкретно наша \r\nфункция (показанная в листинге 7.14) показывает скрытый элемент, а затем проявляет его за счет изменения \r\nстепени непрозрачности от 0 (полностью прозрачен) до 100% (полностью непрозрачен). Во многом напоминая \r\nфункцию, показанную в листинге 7.13, эта функция создает у пользователей более плавное визуальное \r\nвпечатление. \r\nЛистинг 7.14. Функция, предназначенная для медленного проявления скрытого элемента за счет \r\nувеличения в течение секунды его непрозрачности \r\nfunction fadeIn( elem ) { \r\n    // Начало непрозрачности с 0 \r\n    setOpacity( elem, 0 ); \r\n  \r\n    // Отображение элемента (но вы его не увидите, пока непрозрачность \r\n    // равна 0) \r\n    show( elem ); \r\n  \r\n    // Мы собираемся за секунду показать анимацию, состоящую из \r\n    // 20 'кадров' \r\n    for ( var i = 0; i <= 100; i += 5 ) { \r\n       // Замкнутое выражение, гарантирующее, что у нас в распоряжении \r\n       // находится именно та переменная 'i', которая нам нужна \r\n       (function(){ \r\n           var pos = i; \r\n  \r\n           // Установка времени ожидания для совершения будущих \r\n           // действий в определенное время \r\n           setTimeout(function(){ \r\n","\r\n 147\r\n  \r\n               // Установка новой степени прозрачности элемента \r\n               setOpacity( elem, pos ); \r\n  \r\n           }, ( pos + 1 ) * 10); \r\n       })(); \r\n    } \r\n}  \r\nПримеры этих, и других анимационных эффектов показаны в главе 9. \r\nБраузер \r\nПосле работы со специфическими DOM-элементами, знания, позволяющие изменять или отслеживать \r\nнастройки браузера и его компонентов, могут значительно улучшить взаимодействие пользователя с веб-сайтом. \r\nДва наиболее важных аспекта работы с браузерами заключаются в определении позиции указателя мыши, и \r\nопределении степени прокрутки страницы пользователем. \r\nПозиция указателя мыши \r\nОпределение позиции указателя мыши является важнейшим аспектом предоставления пользователю \r\nвозможностей по перетаскиванию элементов и использованию контекстных меню, и обе эти возможности \r\nпоявляются только при использовании взаимодействия между JavaScript и CSS. \r\nПервые две переменные, значение которых нужно установить — это позиции x и y указателя мыши \r\nотносительно всей веб-страницы (см. листинг 7.15). поскольку получить координаты указателя можно лишь с \r\nпомощью событий, связанных с мышью, вам для их захвата потребуется использование общих событий мыши, в \r\nчастности MouseMove или MouseDown (дополнительные примеры показаны в разделе «Перетаскивание»). \r\nЛистинг 7.15. Две универсальные функции для получения текущей позиции указателя мыши относительно \r\nвсего пространства страницы \r\n// Получение горизонтальной позиции указателя \r\nfunction getX(e) { \r\n    // нормализация объекта события \r\n    e = e || window.event; \r\n  \r\n    // Сначала получение позиции из браузеров, не относящихся к IE, \r\n    // а затем из IE \r\n    return e.pageX || e.clientX + document.body.scrollLeft; \r\n} \r\n  \r\n// Получение вертикальной позиции указателя \r\nfunction getY(e) { \r\n    // нормализация объекта события \r\n    e = e || window.event; \r\n  \r\n    // Сначала получение позиции из браузеров, не относящихся к IE, \r\n    // а затем из IE \r\n    return e.pageY || e.clientY + document.body.scrollTop; \r\n}  \r\n","\r\n 148\r\nВ заключение будет полезно узнать о вторичных, связанных с мышью переменных, позициях указателя x и \r\ny, относительно того элемента, с которым в данный момент происходит взаимодействие. В листинге 7.16 \r\nприведены две функции, которые можно использовать для извлечения этих значений. \r\nЛистинг 7.16. Две функции, предназначенные для получения позиции указателя мыши относительно \r\nтекущего элемента \r\n// Получение X-позиции указателя относительно целевого элемента, \r\n// который используется в объекте события 'e' \r\nfunction getElementX( e ) { \r\n    // Определение соответствующего смещения элемента \r\n    return ( e && e.layerX ) || window.event.offsetX; \r\n} \r\n  \r\n// Получение Y-позиции указателя относительно целевого элемента, \r\n// который используется в объекте события 'e' \r\nfunction getElementY( e ) { \r\n    // Определение соответствующего смещения элемента \r\n    return ( e && e.layerY ) || window.event.offsetY; \r\n} \r\nКогда в этой главе мы перейдем к разделу «Перетаскивание», то уделим внимание взаимодействию с \r\nмышью еще раз. Дополнительно, чтобы получить больше примеров, связанных с событиями мыши, нужно \r\nобратиться к главе 6 и приложению Б, в которых приведено значительно больше примеров работы с мышью. \r\nОбласть просмотра \r\nОбластью просмотра браузера можно считать все, что находится внутри его полос прокрутки. Кроме этого \r\nобласть прокрутки состоит из нескольких компонентов: окна области просмотра, страницы и полос прокрутки. \r\nОпределение точной позиции и размеров каждого из этих компонентов нужны для разработки четкого \r\nвзаимодействия с протяженными частями содержимого (среди которых, к примеру, чат-окна с автопрокруткой). \r\nРазмер страницы \r\nПервый набор свойств, требующих рассмотрения — высота и ширина текущей веб-страницы. Чаще всего \r\nбывает так, что большая часть просматриваемой страницы лежит за пределами области просмотра (что можно \r\nопределить за счет проверки размеров области просмотра и позиции полосы прокрутки). В листинге 7.17 \r\nпоказаны две функции, использующие вышеупомянутые свойства scrollWidth и scrollHeight, которые уточняют \r\nполную возможную ширину и высоту элемента, а не только текущие отображаемые размеры. \r\nЛистинг 7.17. Две функции, предназначенные для определения длины и ширины текущей веб-страницы \r\n// Возвращение высоты веб-страницы \r\n// (может изменяться при добавлении к странице нового содержимого) \r\nfunction pageHeight() { \r\n    return document.body.scrollHeight; \r\n} \r\n  \r\n// Возвращение ширины веб-страницы \r\nfunction pageWidth() { \r\n    return document.body.scrollWidth; \r\n","\r\n 149\r\n}  \r\nПозиции полос прокрутки \r\nТеперь мы посмотрим, как определить позиции полос прокрутки браузера (или, в другом смысле, \r\nопределить насколько вниз по странице переместилась область просмотра). Их числовые значения (которые \r\nможно получить при помощи функций, показанных в листинге 7.18) необходимы для предоставления \r\nдинамической прокрутки в самом приложении, не принимая в расчет того, что предоставлено браузером \r\nизначально. \r\nЛистинг 7.18. Две функции, предназначенные для определения, где находится область просмотра \r\nотносительно верхней части документа \r\n// Функция для определения величины горизонтальной прокрутки браузера \r\nfunction scrollX() { \r\n    // Сокращение на случай использования Internet Explorer 6 в строгом \r\n    // (strict) режиме \r\n    var de = document.documentElement; \r\n  \r\n    // Использование свойства браузера pageXOffset, если оно доступно \r\n    return self.pageXOffset || \r\n  \r\n    // в противном случае попытка получить прокрутку слева из \r\n    // корневого узла \r\n    ( de && de.scrollLeft ) || \r\n  \r\n    // И наконец, попытка получить прокрутку слева из элемента body \r\n    document.body.scrollLeft; \r\n} \r\n  \r\n// Функция для определения величины вертикальной прокрутки браузера \r\nfunction scrollY() { \r\n    // Сокращение на случай использования Internet Explorer 6 в строгом \r\n    // (strict) режиме \r\n    var de = document.documentElement; \r\n  \r\n    // Использование свойства браузера pageYOffset, если оно доступно \r\n    return self.pageYOffset || \r\n  \r\n    // в противном случае попытка получить прокрутку сверху из \r\n    // корневого узла \r\n       ( de && de.scrollTop ) || \r\n  \r\n    // И наконец, попытка получить прокрутку сверху из элемента body \r\n       document.body.scrollTop; \r\n}  \r\nПеремещение полос прокрутки \r\n","\r\n 150\r\nТеперь, располагая текущим смещением полос прокрутки на странице и длиной самой страницы, можно \r\nрассмотреть предоставляемый браузерами метод scrollTo, который можно использовать для корректировки \r\nтекущей позиции области просмотра на странице. \r\nМетод scrollTo существует в виде свойства объекта window (или любого другого элемента, имеющего \r\nполосы прокрутки содержимого или <iframe>) и принимает два аргумента, смещения x и y, необходимые для \r\nпрокрутки области просмотра (или элемента, или <iframe>). В листинге 7.19 показаны два примера \r\nиспользования метода scrollTo. \r\nЛистинг 7.19. Примеры использования метода scrollTo для корректировки позиции области просмотра \r\nбраузера \r\n// Если нужно осуществить прокрутку окна браузера до самого верха, можно \r\n// сделать следующее: \r\nwindow.scrollTo(0,0); \r\n  \r\n// Если нужно осуществить прокрутку до позиции определенного элемента, можно \r\n// сделать следующее: \r\nwindow.scrollTo( 0, pageY( document.getElementById(\"body\") ) );  \r\nРазмер области просмотра \r\nЗаключительный аспект области просмотра является, наверное, наиболее очевидным: это размер самой \r\nобласти. Знание размера области просмотра дает хорошее представление о том, какую часть содержимого \r\nпользователь может в данный момент видеть, независимо от разрешения экрана или размера окна браузера. Для \r\nопределения значений размера можно воспользоваться двумя функциями, представленными в листинге 7.20. \r\nЛистинг 7.20. Две функции, предназначенные для определения высоты и ширины области просмотра \r\nбраузера \r\n// Определение высоты области просмотра \r\nfunction windowHeight() { \r\n    // Сокращение на случай использования Internet Explorer 6 в строгом \r\n    // (strict) режиме \r\n    var de = document.documentElement; \r\n  \r\n  \r\n    // Использование свойства браузера innerHeight, если оно доступно \r\n    return self.innerHeight || \r\n  \r\n       // в противном случае попытка получить высоту из корневого узла \r\n        ( de && de.clientHeight ) || \r\n  \r\n        // И наконец, попытка получить высоту из элемента body \r\n       document.body.clientHeight; \r\n} \r\n  \r\n// Определение ширины области просмотра \r\nfunction windowWidth() { \r\n    // Сокращение на случай использования Internet Explorer 6 в строгом \r\n    // (strict) режиме \r\n","\r\n 151\r\n    var de = document.documentElement; \r\n  \r\n    // Использование свойства браузера innerWidth, если оно доступно \r\n    return self.innerWidth || \r\n  \r\n       // в противном случае попытка получить ширину из корневого узла \r\n       ( de && de.clientWidth ) || \r\n  \r\n       // И наконец, попытка получить ширину из элемента body \r\n       document.body.clientWidth; \r\n}  \r\nПользу от работы с областью просмотра трудно переоценить. Взгляните на современные веб-приложения, \r\nк примеру, на Gmail или Campfire, и увидите в них примеры того, как манипуляции с областью просмотра \r\nприводят к вполне предсказуемым результатам (Gmail предоставляет контекстные накладки, а Campfire — чаты с \r\nавтопрокруткой). В главе 11 будут рассмотрены другие способы возможного использования области просмотра, \r\nулучшающие восприятие веб-приложений с высоким уровнем интерактивности. \r\nПеретаскивание \r\nОдно из наиболее популярных пользовательских интерактивных действий, доступных в браузере — \r\nперетаскивания элемента по странице. Теперь, используя уже изученный материал (возможность определения \r\nпозиции элемента, ее корректировки, и понимание различий между разными видами позиционирования), вы \r\nбудете в состоянии полностью разобраться с тем, как работает система перетаскивания элементов. \r\nДля исследования этой технологии, я решил рассмотреть библиотеку DOM-Drag, созданную Аароном \r\nБудманом (Aaron Boodman) (http://boring.youngpup.net/2001/domdrag). Его библиотека предоставляет массу \r\nполезных вещей, включая следующие: \r\nОписатели перетаскивания: У вас может быть один фактически перемещаемый родительский элемент, и \r\nдругой, перетаскиваемый вместе с ним подэлемент. Это пригодится при создании элементов интерфейса, похожих \r\nна окна. \r\nФункции обратного вызова: Вы можете отслеживать определенные события, к примеру, когда \r\nпользователь начинает перетаскивание элемента, перетаскивает его, или завершает перетаскивание, а также \r\nполучать информацию о текущем местоположении элемента. \r\nМинимальная и максимальная области перетаскивания: Вы можете в определенных пределах ограничить \r\nобласть перетаскивания элемента (к примеру, не дать его перетащить за пределы экрана). Это пригодится для \r\nсоздания полос прокрутки. \r\nСобственная система координат: Если вы не испытываете удобств при работе с системой координат CSS, \r\nможно выбрать работу с любой комбинацией отображения координатной системы x/y. \r\nСобственное преобразование системы координат x и y: Вы можете заставить перетаскиваемый элемент \r\nдвигаться необычными способами (по пульсирующей или круговой колебательной траектории). \r\nИспользование системы DOM-Drag не представляет особых трудностей. Сначала к элементу прикрепляется \r\nобработчик перетаскивания (кроме этого могут быть определены любые дополнительные варианты работы), а \r\nтакже любые дополнительные функции наблюдения. Некоторые примеры использования DOM-Drag приведены в \r\nлистинге 7.21. \r\n","\r\n 152\r\nЛистинг 7.21. Использование DOM-Drag для имитации перетаскиваемых окон \r\n<html> \r\n<head> \r\n    <title>DOM-Drag — демонстрация перетаскиваемого окна </title> \r\n    <script src=\"domdrag.js\" type=\"text/javascript\"></script> \r\n    <script type=\"text/javascript\"> \r\n    window.onload = function(){ \r\n       // Инициализация функции DOM-Drag, при которой элемент, \r\n       // имеющий ID 'window', становится перетаскиваемым \r\n       Drag.init( document.getElementById(\"window\") ); \r\n    }; \r\n    </script> \r\n    <style> \r\n    #window { \r\n       border: 1px solid #DDD; \r\n       border-top: 15px solid #DDD; \r\n       width: 250px; \r\n       height: 250px; \r\n    } \r\n    </style> \r\n</head> \r\n<body> \r\n    <h1>Draggable Window Demo</h1> \r\n    <div id=\"window\">Я — перетаскиваемое окно, можете попробовать меня \r\n                                                    перетащить!</div> \r\n</body> \r\n</html>  \r\nПолностью документированная копия библиотеки DOM-Drag показана в листинге 7.22. Код присутствует в \r\nвиде единого глобального объекта, чьи методы могут быть вызваны для объектов для инициализации процесса \r\nперетаскивания. \r\nЛистинг 7.22. Полностью документированная библиотека DOM-Drag \r\nvarDrag = { \r\n  \r\n    // текущий перетаскиваемый элемент \r\n    obj: null, \r\n  \r\n    // функция инициализации для перетаскиваемого объекта \r\n    // o = элемент, действующий в качестве описателя перетаскивания \r\n    // oRoot = перетаскиваемый элемент, если не определено другое, \r\n    // описатель будет перетаскиваемым элементом. \r\n    // minX, maxX, minY, maxY = минимальные и максимальные координаты, \r\n    // разрешенные для элемента \r\n    // bSwapHorzRef = переключатель горизонтальной системы координат \r\n    // bSwapVertRef = переключатель вертикальной системы координат \r\n    // fxMapper, fyMapper = функции для преобразования координат x и y \r\n    // в другие координаты \r\n","\r\n 153\r\n    init: function(o, oRoot, minX, maxX, minY, \r\n           maxY, bSwapHorzRef, bSwapVertRef, fXMapper, fYMapper) { \r\n  \r\n       // Отслеживания начала перетаскивания \r\n       o.onmousedown = Drag.start; \r\n  \r\n       // Определение используемой системы координат \r\n       o.hmode = bSwapHorzRef ? false : true ; \r\n       o.vmode = bSwapVertRef ? false : true ; \r\n  \r\n       // Определение элемента, который служит описателем перетаскивания \r\n       o.root = oRoot && oRoot != null ? oRoot : o ; \r\n  \r\n       // Инициализация указанной системы координат \r\n       if (o.hmode && isNaN(parseInt(o.root.style.left ))) \r\n           o.root.style.left = \"0px\"; \r\n       if (o.vmode && isNaN(parseInt(o.root.style.top ))) \r\n           o.root.style.top = \"0px\"; \r\n       if (!o.hmode && isNaN(parseInt(o.root.style.right ))) \r\n           o.root.style.right = \"0px\"; \r\n       if (!o.vmode && isNaN(parseInt(o.root.style.bottom))) \r\n           o.root.style.bottom = \"0px\"; \r\n  \r\n       // Проверка предоставления пользователем минимальных и \r\n       // максимальных значений координат x и y \r\n       o.minX = typeof minX != 'undefined' ? minX : null; \r\n       o.minY = typeof minY != 'undefined' ? minY : null; \r\n       o.maxX = typeof maxX != 'undefined' ? maxX : null; \r\n       o.maxY = typeof maxY != 'undefined' ? maxY : null; \r\n  \r\n       // Проверка на существование любых заданных преобразователей \r\n       // x и y координат \r\n       o.xMapper = fXMapper ? fXMapper : null; \r\n       o.yMapper = fYMapper ? fYMapper : null; \r\n    \r\n       // Добавление оболочки для всех функций, определяемых пользователем             \r\no.root.onDragStart = new Function(); \r\n       o.root.onDragEnd = new Function(); \r\n       o.root.onDrag = new Function(); \r\n    }, \r\n  \r\n    start: function(e) { \r\n        // Определение перетаскиваемого объекта \r\n        var o = Drag.obj = this; \r\n  \r\n        // Нормализация объекта события \r\n        e = Drag.fixE(e); \r\n  \r\n","\r\n 154\r\n        // Получение текущих координат x и y \r\n        var y = parseInt(o.vmode ? o.root.style.top : o.root.style.bottom); \r\n        var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right ); \r\n  \r\n        // Вызов функции пользователя с текущими координатами x и y \r\n        o.root.onDragStart(x, y); \r\n  \r\n        // Запоминание начальной позиции указателя мыши \r\n        o.lastMouseX = e.clientX; \r\n        o.lastMouseY = e.clientY; \r\n  \r\n        // Если используется система координат CSS \r\n        if (o.hmode) { \r\n           // установка min и max координат там, где они применяются \r\n           if (o.minX != null) o.minMouseX = e.clientX -x + o.minX; \r\n           if (o.maxX != null) o.maxMouseX = o.minMouseX + o.maxX -o.minX; \r\n  \r\n        // В противном случае применение обычной математической системы \r\n       //координат \r\n        } else { \r\n            if (o.minX != null) o.maxMouseX = -o.minX + e.clientX + x; \r\n           if (o.maxX != null) o.minMouseX = -o.maxX + e.clientX + x; \r\n        } \r\n  \r\n        // Если используется система координат CSS \r\n        if (o.vmode) { \r\n           // установка min и max координат там, где они применяются \r\n           if (o.minY != null) o.minMouseY = e.clientY -y + o.minY; \r\n           if (o.maxY != null) o.maxMouseY = o.minMouseY + o.maxY -o.minY; \r\n    \r\n       // В противном случае применение обычной математической системы \r\n       //координат \r\n        } else { \r\n            if (o.minY != null) o.maxMouseY = -o.minY + e.clientY + y; \r\n           if (o.maxY != null) o.minMouseY = -o.maxY + e.clientY + y; \r\n        } \r\n    \r\n        // отслеживание событий перетаскивания и завершения \r\n       // перетаскивания \r\n        document.onmousemove = Drag.drag; \r\n        document.onmouseup = Drag.end; \r\n  \r\n        return false; \r\n    }, \r\n  \r\n    // Функция, предназначенная для отслеживания всех перемещений \r\n    // указателя мыши в ходе события перетаскивания \r\n    drag: function(e) { \r\n","\r\n 155\r\n        // Нормализация объекта события \r\n        e = Drag.fixE(e); \r\n  \r\n        // получение нашей ссылки на перетаскиваемый элемент \r\n        var o = Drag.obj; \r\n  \r\n        // получение позиции указателя мыши в пределах окна \r\n        var ey = e.clientY; \r\n        var ex = e.clientX; \r\n  \r\n        // Получение текущих координат x и y \r\n        var y = parseInt(o.vmode ? o.root.style.top : o.root.style.bottom); \r\n        var x = parseInt(o.hmode ? o.root.style.left : o.root.style.right ); \r\n        var nx, ny; \r\n  \r\n    // Если была установлена минимальная позиция X, убедиться в том, \r\n    // что она не пройдена \r\n        if (o.minX != null) ex = o.hmode ? \r\n           Math.max(ex, o.minMouseX) : Math.min(ex, o.maxMouseX); \r\n        \r\n    // Если была установлена максимальная позиция X, убедиться в том, \r\n    // что она не пройдена \r\n        if (o.maxX != null) ex = o.hmode ? \r\n            Math.min(ex, o.maxMouseX) : Math.max(ex, o.minMouseX); \r\n  \r\n    // Если была установлена минимальная позиция Y, убедиться в том, \r\n    // что она не пройдена \r\n        if (o.minY != null) ey = o.vmode ? \r\n            Math.max(ey, o.minMouseY) : Math.min(ey, o.maxMouseY); \r\n  \r\n    // Если была установлена максимальная позиция Y, убедиться в том, \r\n    // что она не пройдена \r\n        if (o.maxY != null) ey = o.vmode ? \r\n           Math.min(ey, o.maxMouseY) : Math.max(ey, o.minMouseY); \r\n  \r\n        // Вычисление координат x и y последнего перемещения \r\n        nx = x + ((ex -o.lastMouseX) * (o.hmode ? 1 : -1)); \r\n        ny = y + ((ey -o.lastMouseY) * (o.vmode ? 1 : -1)); \r\n  \r\n        // и преобразование их с помощью x или y функции преобразования \r\n       // координат (если таковая предоставлена) \r\n        if (o.xMapper) nx = o.xMapper(y) \r\n        else if (o.yMapper) ny = o.yMapper(x) \r\n  \r\n        // Установка для элемента новых x и y координат \r\n        Drag.obj.root.style[o.hmode ? \"left\" : \"right\"] = nx + \"px\"; \r\n        Drag.obj.root.style[o.vmode ? \"top\" : \"bottom\"] = ny + \"px\"; \r\n  \r\n","\r\n 156\r\n        // и запоминание последней позиции указателя мыши \r\n        Drag.obj.lastMouseX = ex; \r\n        Drag.obj.lastMouseY = ey; \r\n  \r\n        // Вызов пользовательской функции onDrag с текущими координатами \r\n       // x и y \r\n        Drag.obj.root.onDrag(nx, ny); \r\n  \r\n        return false; \r\n    }, \r\n  \r\n    // Функция, обрабатывающая завершение события перетаскивания \r\n    end: function() { \r\n        // События мыши больше не отслеживать (поскольку перетаскивание \r\n       // уже произошло) \r\n        document.onmousemove = null; \r\n        document.onmouseup = null; \r\n  \r\n        // В конце перетаскивания вызов нашей специальной функции \r\n       // onDragEnd с координатами элемента x и y \r\n        Drag.obj.root.onDragEnd( \r\n         parseInt(Drag.obj.root.style[Drag.obj.hmode ? \"left\" : \"right\"]), \r\n         parseInt(Drag.obj.root.style[Drag.obj.vmode ? \"top\" : \"bottom\"])); \r\n        // No longer watch the object for drags \r\n        Drag.obj = null; \r\n    }, \r\n  \r\n    // Функция, предназначенная для нормализации объекта события \r\n    fixE: function(e) { \r\n        // Если объекта события не существует, значит это IE, и нужно \r\n       // предоставить объект события IE \r\n        if (typeof e == 'undefined') e = window.event; \r\n  \r\n    // Если свойство layer не установлено, получение \r\n    // значений из эквивалентного свойства offset \r\n       if (typeof e.layerX == 'undefined') e.layerX = e.offsetX; \r\n       if (typeof e.layerY == 'undefined') e.layerY = e.offsetY; \r\n  \r\n       return e; \r\n    } \r\n};  \r\nЕсли честно, то DOM-Drag, возможно, лишь одна из сотен JavaScript-библиотек перетаскивания. Тем не \r\nменее, к ней у меня особое пристрастие, благодаря ее качественному объектно-ориентированному синтаксису и \r\nотносительной простоте. В следующем разделе я рассмотрю библиотеку Scriptaculous, которая обладает \r\nпревосходной и мощной реализацией перетаскивания, которую я настоятельно рекомендую опробовать в работе. \r\nБиблиотеки \r\n","\r\n 157\r\nЕсли нужно разработать какой-нибудь эффект или средство взаимодействия, может получиться так же, как \r\nи со многими другими трудоемкими задачами в JavaScript — вполне вероятно, что подобная вещь уже была \r\nсоздана. Давайте проведем краткий обзор трех разных библиотек, предоставляющих различные средства DHTML- \r\nвзаимодействия, чтобы получить представление о том, что вам доступно, как разработчику. \r\nmoo.fx и jQuery \r\nЕсть две небольшие библиотеки, которые очень хорошо подходят для управления простыми эффектами: \r\nmoo.fx и jQuery. Обе они предоставляют основные комбинации эффектов, которые могут быть объединены для \r\nсоздания вполне впечатляющей, но несложной анимации. Дополнительная информация о каждой из этих \r\nбиблиотек может быть найдена на связанных с ними веб-страницах. В листинге 7.23 приведены некоторые \r\nосновные примеры использования этих библиотек. \r\nЛистинг 7.23. Основные примеры анимации, получаемой с использованием библиотек moo.fx и jQuery \r\n// Простая анимация, в которой скрытый элемента сначала показывается \r\n// за счет расширения, а потом, когда этот процесс завершится, \r\n// снова сжимается \r\n  \r\n// Реализация этого анимационного эффекта в moo.fx \r\nnew fx.Height( \"side\", { \r\n    duration: 1000, \r\n    onComplete: function() { \r\n       new fx.Height( \"side\", { duration: 1000 } ).hide(); \r\n    } \r\n}).show(); \r\n  \r\n// Реализация в jQuery \r\n$(\"#side\").slideDown( 1000, function(){ \r\n    $(this).slideUp( 1000 ); \r\n}); \r\n  \r\n// Еще одна простая анимация, в которой высота, ширина и непрозрачность \r\n// элемента одновременно сокращаются (или уменьшаются), чем достигается \r\n// довольно интересный эффект скрытия \r\n  \r\n// Реализация этого анимационного эффекта в moo.fx \r\nnew fx.Combo( \"body\", { \r\n    height: true, \r\n    width: true, \r\n    opacity: true \r\n}).hide(); \r\n  \r\n// Реализация анимации в jQuery \r\n$(\"#body\").hide( \"fast\" );  \r\nНаверное, судя по примерам, вы сможете сказать, что библиотеки moo.fx и jQuery действительно \r\nупрощают создание некоторых, довольно тонких анимационных эффектов. В обоих проектах на их веб-сайтах \r\nпредставлено множество примеров их кода в действии, что может послужить великолепным способом изучения \r\nмеханизмов работы несложной JavaScript-анимации: \r\n","\r\n 158\r\n• Домашняя страница moo.fx: http://moofx.mad4milk.net/ \r\n• Примеры документации mootoolkit: http://moofx.mad4milk.net/documentation/ \r\n• Домашняя страница jQuery: http://jquery.com/ \r\n• Документация по эффектам и примеры jQuery: http://jquery.com/docs/fx/ \r\nScriptaculous \r\nЕсли потребовалось бы возвести на королевский трон какую-нибудь из DHTML-библиотек, то речь \r\nмогла бы идти только о Scriptaculous. Построенная на основе популярной библиотеки Prototype, Scriptaculous \r\nпредоставляет огромное количество различных интерактивных средств, то есть практически все, от анимаций и \r\nэффектов, до интерактивных действий (например, перетаскивания). На веб-сайте Scriptaculous может быть \r\nнайдена масса сведений и примеров: \r\n• Домашняя страница: http://script.aculo.us/ \r\n• Документация: http://wiki.script.aculo.us/scriptaculous/ \r\n• Демонстрационные программы: http://wiki.script.aculo.us/scriptaculous/show/Demos/ \r\nОдной из областей, в которой Scriptaculous предоставляет наивысший уровень возможностей, сохраняя \r\nпри этом наилучший уровень простоты использования, является перетаскивание. Чтобы вы смогли составить себе \r\nпредставление, я привожу два простых примера. \r\nПерестроение путем перетаскивания \r\nОдной из задач, решаемых легко и просто с помощью Scriptaculous является перестроение списков. Если \r\nпринять во внимание простоту кода (и легкость получения доступа к функциональным возможностям Ajax, \r\nпродемонстрированную на веб-сайте библиотеки), это решение настоятельно рекомендуется для большинства \r\nвеб-разработчиков. Пример, показанный в листинге 7.24 представляет собой перестраиваемый список, созданный \r\nс использованием библиотеки Scriptaculous. \r\nЛистинг 7.24. Способ создания списка, перестраиваемого за счет технологии, доступной в библиотеке \r\nScriptaculous \r\n<html> \r\n<head> \r\n    <title>script.aculo.us — демонстрация перестроения путем \r\n       перетаскивания </title> \r\n    <script src=\"prototype.js\" type=\"text/javascript\"></script> \r\n    <script src=\"scriptaculous.js\" type=\"text/javascript\"></script> \r\n    <script src=\"effects.js\" type=\"text/javascript\"></script> \r\n    <script src=\"dragdrop.js\" type=\"text/javascript\"></script> \r\n    <script type=\"text/javascript\"> \r\n    window.onload = function(){ \r\n       // Превращение элемента с id равным 'list' в перетаскиваемый, \r\n       // перестраиваемый список \r\n       Sortable.create('list'); \r\n    }; \r\n    </script> \r\n</head> \r\n<body> \r\n    <h1>Перестроение путем перетаскивания</h1> \r\n","\r\n 159\r\n  \r\n    <p>Чтобы перестроить элемент его нужно перетащить.</p> \r\n  \r\n    <ul id=\"list\"> \r\n       <li>Элемент No 1</li> \r\n       <li>Элемент No 2</li> \r\n       <li>Элемент No 3</li> \r\n       <li>Элемент No 4</li> \r\n       <li>Элемент No 5</li> \r\n       <li>Элемент No 6</li> \r\n    </ul> \r\n</body> \r\n</html>  \r\nЯ надеюсь, что этот пример убедит вас в мощности, заключенной внутри этой библиотеки, но если этого \r\nнедостаточно, вы можете посмотреть следующий пример создания управляющего элемента — ползунка для ввода \r\nданных. \r\nПолзунок для ввода данных \r\nБиблиотека Scriptaculous предоставляет ряд управляющих элементов, которые можно использовать для \r\nрешения общих вопросов разработки интерфейса. Управляющий элемент, который нетрудно получить с \r\nиспользованием большинства библиотек перетаскивания — это ползунок для ввода данных (сдвигающийся \r\nползунок для получение числового ввода) и Scriptaculous в этом смысле не исключение, о чем свидетельствует \r\nкод, представленный в листинге 7.25. \r\nЛистинг 7.25. Использование ползунка для ввода данных из библиотеки Scriptaculous, чтобы получить \r\nальтернативный способ ввода в форму вашего возраста \r\n<html> \r\n<head> \r\n    <title>script.aculo.us — демонстрация ползунка для ввода данных</title> \r\n    <script src=\"prototype.js\" type=\"text/javascript\"></script> \r\n    <script src=\"scriptaculous.js\" type=\"text/javascript\"></script> \r\n    <script src=\"effects.js\" type=\"text/javascript\"></script> \r\n    <script src=\"dragdrop.js\" type=\"text/javascript\"></script> \r\n    <script src=\"controls.js\" type=\"text/javascript\"></script> \r\n    <script type=\"text/javascript\"> \r\n    window.onload = function(){ \r\n       // Превращение элемента, имеющего значение ID, равное ageHandle, \r\n       // в ползунок, и элемента, имеющего значение ID, равное ageBar, \r\n       // в шкалу ползунка \r\n       new Control.Slider( 'ageHandle', 'ageBar', { \r\n           // При перемещении или завершении перемещения ползунка \r\n           // вызывается функция updateAge \r\n           onSlide: updateAge \r\n       }); \r\n  \r\n       // Обработка любых перемещений ползунка \r\n       function updateAge(v) { \r\n","\r\n 160\r\n           // при обновлении позиции ползунка, обновление значения \r\n           // элемента age с целью представления текущего возраста \r\n           // пользователя \r\n           $('age').value = Math.floor( v * 100 ); \r\n       } \r\n    }; \r\n    </script> \r\n</head> \r\n<body> \r\n    <h1>Демонстрация ползунка для ввода данных </h1> \r\n  \r\n    <form action=\"\" method=\"POST\"> \r\n       <p>Сколько Вам лет? <input type=\"text\" name=\"age\" id=\"age\" /></p> \r\n  \r\n       <div id=\"ageBar\" style=\"width:200px; background: #000; height:5px;\"> \r\n           <div id=\"ageHandle\" style=\"width:5px; height:10px; \r\n               background: #000; cursor:move;\"></div> \r\n       </div> \r\n  \r\n       <input type=\"submit\" value=\"Submit Age\"/> \r\n    </form> \r\n</body> \r\n</html>  \r\n  \r\nЯ настоятельно советую, прежде чем решиться на создание какого-нибудь следующего интерактивного \r\nсредства проверить его наличие в некоторых DHTML-библиотеках, следуя тому простому факту, что авторы \r\nбиблиотек скорее всего уже затратили больше времени и усилий на разработку именно этого средства, чем вы на \r\nсоздание всего своего приложения. Широкое использование библиотек наверняка позволит вам существенно \r\nсэкономить время на разработке приложения. \r\nВывод \r\nВозможности, открывающиеся в веб-приложении при использовании динамических интерактивных \r\nсредств, предоставляют замечательные способы достижения новых уровней скорости и удобства работы ваших \r\nпользователей. Кроме того, при использовании любых популярных библиотек, вы сможете значительно снизить \r\nсроки разработки приложения. В следующей главе мы объединим все изученные в этой главе интерактивные \r\nтехнологии для создания полноценного интерактивного приложения. \r\nВ этой главе мы рассмотрели все многообразие технологий, направленных на достижение необходимого \r\nуровня симбиоза между JavaScript и CSS. В результате была получена возможность создания впечатляющих \r\nанимационных эффектов и динамических средств взаимодействия с пользователем. \r\nНеобходимо помнить, что добавления на веб-страницу любых форм динамической интерактивности может \r\nотпугнуть часть вашей аудитории. Нужно всегда заботиться о том, чтобы ваше приложение не теряло удобств в \r\nработе с ним, даже если будут отключены JavaScript или CSS. Создание приложения, способного с легкостью \r\nработать в упрощенном режиме, должно быть идеалом для любого JavaScript- разработчика. \r\n","\r\n 161\r\nГлава 8 Усовершенствование форм \r\nФормы являются средством получения от пользователя структурированных данных, и поэтому имеют для \r\nвеб-разработчиков особую важность. По своей сути, форма имеет совсем немного ограничений на действия \r\nпользователя, на характер вводимых им данных, и на то, в каком качестве ее использовать. \r\nНа той стадии разработки, когда уже создана семантически развитая форма, настает время добавить к ней \r\nкод JavaScript, предоставляющий пользователю дополнительную ответную реакцию. Зная как или почему с \r\nформой может что-то произойти, пользователь сможет быстрее ее заполнить, и получить от работы с ней лучшее \r\nвпечатление. \r\nВ этой главе мы собираемся рассмотреть выполнение основной проверки формы на стороне клиента и \r\nпредоставление пользователю результатов этой проверки вполне толковым и ненавязчивым образом. Затем мы \r\nсобираемся рассмотреть ряд способов, позволяющих повысить общие удобства пользования формой. Объединение \r\nэтих двух технологий может быть использовано для предоставления пользователям существенно улучшенных \r\nформ, заполнение которых может превратиться в сплошное удовольствие. \r\nПроверка данных формы \r\nДобавление к веб-странице проверки формы на стороне клиента может обеспечить пользователям \r\nускорение работы, но без особых выгод: проверка формы на стороне клиента никогда не заменит проверку на \r\nстороне сервера, она ее может только усилить. Стало быть, добавление к веб-странице проверки формы на \r\nстороне клиента — превосходный пример уже изученной вами ненавязчивой технологии разработки сценариев. \r\nПеред тем как приступить к составлению любого, связанного с формой сценария, нужно создать форму и \r\nубедиться в том, что она работает как и планировалось (например, проверка пользовательского ввода, выдача \r\nсоответствующих сообщений об ошибках, и т. д.). В этой главе мы собираемся использовать семантически \r\nвыверенную XHTML-форму. Внутри этой формы все элементы <input> имеют четкую классификацию (например, \r\nэлементы, по своему типу относящиеся к тексту, имеют в атрибуте class значение text), и содержатся внутри \r\nсоответствующих наборов полей с точными обозначениями. Все это можно увидеть в листинге 8.1. \r\nЛистинг 8.1. Простая XHTML-форма, которую можно улучшить за счет JavaScript \r\n<html> \r\n<head> \r\n    <title>Простая форма</title> \r\n</head> \r\n<body> \r\n<form action=\"\" method=\"POST\"> \r\n    <fieldset class=\"login\"> \r\n       <legend>Регистрационные данные</legend> \r\n       <label for=\"username\" class=\"hover\">Имя пользователя</label> \r\n       <input type=\"text\" id=\"username\" class=\"required text\"/> \r\n  \r\n       <label for=\"password\" class=\"hover\">Пароль</label> \r\n       <input type=\"password\" id=\"password\" class=\"required text\"/> \r\n    </fieldset> \r\n    <fieldset> \r\n       <legend>Личные сведения</legend> \r\n    \r\n       <label for=\"name\">Имя</label> \r\n","\r\n 162\r\n        <input type=\"text\" id=\"name\" class=\"required text\"/><br/> \r\n  \r\n       <label for=\"email\">Адрес электронной почты</label> \r\n       <input type=\"text\" id=\"email\" class=\"required email text\"/><br/> \r\n  \r\n       <label for=\"date\">Дата</label> \r\n       <input type=\"text\" id=\"date\" class=\"required date text\"/><br/> \r\n  \r\n       <label for=\"url\">Веб-сайт</label> \r\n       <input type=\"text\" id=\"url\" class=\"url text\" value=\"http://\"/><br/> \r\n  \r\n       <label for=\"phone\">Телефон</label> \r\n       <input type=\"text\" id=\"phone\" class=\"phone text\"/><br/> \r\n  \r\n       <label for=\"age\">Вам уже исполнилось 13 лет?</label> \r\n       <input type=\"checkbox\" id=\"age\" name=\"age\" value=\"yes\"/><br/> \r\n  \r\n       <input type=\"submit\" value=\"Submit Form\" class=\"submit\"/> \r\n    </fieldset> \r\n</form> \r\n</body> \r\n</html>  \r\nСледующий шаг заключается в применении к форме некоторых основных CSS-стилей, чтобы придать ей \r\nболее приглядный вид. Это поможет вам в следующих разделах главы подобающим образом отобразить \r\nсообщения об ошибках и ответную реакцию. Используемая в форме CSS показана в листинге 8.2. \r\nЛистинг 8.2. Таблица стилей CSS, используемая для улучшения внешнего вида вашей формы \r\nform { \r\n    font-family: Arial; \r\n    font-size: 14px; \r\n    width: 300px; \r\n} \r\n  \r\nfieldset { \r\n    border: 1px solid #CCC; \r\n    margin-bottom: 10px; \r\n} \r\n  \r\nfieldset.login input { \r\n    width: 125px; \r\n} \r\n  \r\nlegend { \r\n    font-weight: bold; \r\n    font-size: 1.1em; \r\n} \r\n  \r\n","\r\n 163\r\nlabel { \r\n    display: block; \r\n    width: 60px; \r\n    text-align: right; \r\n    float: left; \r\n    padding-right: 10px; \r\n    margin: 5px 0; \r\n} \r\n  \r\ninput { \r\n    margin: 5px 0; \r\n} \r\n  \r\ninput.text { \r\n    padding: 0 0 0 3px; \r\n    width: 172px; \r\n} \r\n  \r\ninput.submit { \r\n    margin: 15px 0 0 70px; \r\n}  \r\nКопия экрана, показанная на рис. 8.1, даст вам достаточное представление о внешнем виде формы \r\n(готовой к наслоению новых режимов работы за счет использования JavaScript). \r\n \r\nРис. 8.1. Копия экрана стилизованной формы, к которой будет добавляться новый режим работы за счет \r\nприменения JavaScript \r\nТеперь, имея в своем распоряжении хорошо стилизованную форму, можно приступать к углубленному \r\nрассмотрению вопросов проверки формы на стороне клиента. Для этой проверки существует ряд технологий, \r\nнаиболее часто применяемых к формам. Все эти технологии вращаются вокруг обеспечения того, что данные \r\nвведенные пользователем в форму, соответствуют ожиданиям программы на серверной стороне. \r\n","\r\n 164\r\nГлавное преимущество обеспечение проверки на стороне клиента состоит в том, что у пользователей \r\nпоявляется практически мгновенная ответная реакция относительно введенных ими данных, которая помогает \r\nлишь улучшить общее впечатление от ввода информации в форму. Должно быть абсолютно ясно, что решение о \r\nреализации проверки формы на стороне клиента, не означает, что нужно убрать или проигнорировать проверку \r\nна стороне сервера. Проверка формы должна продолжаться и при выключенном JavaScript, обеспечивая \r\nпользователям, не имеющим включенного JavaScript, возможность ее дальнейшего использования. \r\nВ этом разделе мы собираемся рассмотреть определенный код, необходимый для проверки ряда \r\nразличных элементов ввода данных, чтобы удостовериться, что они содержат определенные данные, \r\nвостребованные формой. По отдельности каждая из этих проверочных процедур может и не играть особой роли, \r\nно в совокупности они могут обеспечить полный набор для проверки и тестирования, показанный в следующем \r\nразделе. \r\nОбязательные поля \r\nВозможно, самая важная из всех проводимых проверок полей, относится к проверке обязательного поля \r\n(это значит, что пользователь обязательно должен ввести в него данные). В большинстве случаев это требование \r\nможет быть сведено к проверке того, что это поле не пустое. Но иногда у поля может быть уже введенное в него \r\nзначение по умолчанию, а это значит, что у вас должна быть проверка, учитывающая такую возможность, и \r\nпозволяющая убедиться в том, что пользователь как минимум внес в предоставленные полем данные хотя бы \r\nкакие-нибудь изменения. Эти две проверки охватывают большинство полей формы, включая <input type=“text”>, \r\n<select> и <textarea>. \r\nНо проблемы возникают при попытке обнаружить, изменял ли пользователь значения обязательных полей \r\nфлажков или переключателей. Чтобы обойти эту проблему нужно найти все поля с таким же названием (которые \r\nсоставляют совокупность элементов поля), а затем проверить, устанавливал ли пользователь любой из них. \r\nПример проверки обязательных полей показан в листинге 8.3. \r\nЛистинг 8.3. Проверка на модификацию обязательного поля (включая флажки и переключатели) \r\n// Универсальная функция проверки элемента ввода на наличие введенной \r\n// информации \r\nfunction checkRequired( elem ) { \r\n    if ( elem.type == \"checkbox\" || elem.type == \"radio\" ) \r\n       return getInputsByName( elem.name ).numChecked; \r\n    else \r\n       return elem.value.length > 0 && elem.value != elem.defaultValue; \r\n} \r\n  \r\n// Обнаружение всех элементов ввода с определенным именем (для обнаружения \r\n// и работы с флажками и переключателями) \r\nfunction getInputsByName( name ) { \r\n    // Массив для подходящих входных элементов \r\n    var results = []; \r\n    // Отслеживание, сколько из них было установлено \r\n    results.numChecked = 0; \r\n  \r\n    // Обнаружение всех элементов ввода в документе \r\n    var input = document.getElementsByTagName(\"input\"); \r\n    for ( var i = 0; i < input.length; i++ ) { \r\n","\r\n 165\r\n       // Обнаружение всех полей с определенным именем \r\n       if ( input[i].name == name ) { \r\n           // Сохранение результатов, чтобы впоследствии их можно было \r\n           // вернуть \r\n           results.push( input[i] ); \r\n           // Запоминание количества полей, подвергавшихся \r\n           // установке \r\n           if ( input[i].checked ) \r\n               results.numChecked++; \r\n       } \r\n    } \r\n    // Возвращение набора подходящих полей \r\n    return results; \r\n} \r\n  \r\n// Ожидание окончания загрузки документа \r\nwindow.onload = function() \r\n    // Получение формы и отслеживание попытки отправки данных. \r\n    document.getElementsByTagName(\"form\")[0].onsubmit = function(){ \r\n  \r\n       // Получение проверяемого элемента ввода \r\n       var elem = document.getElementById(\"age\"); \r\n  \r\n       // Определение установки флажка в поле age \r\n       if ( ! checkRequired( elem ) ) { \r\n           // Отображение сообщения об ошибке и предотвращение отправки \r\n           // данных формы. \r\n           alert( \"Обязательное поле не отмечено – \" + \r\n               \"для использования сайта Вам должно быть свыше 13 лет\". ); \r\n           return false; \r\n       } \r\n  \r\n       // Получение проверяемого элемента ввода \r\n       var elem = document.getElementById(\"name\"); \r\n  \r\n       // Определение ввода в поле name какого-нибудь текста \r\n       if ( ! checkRequired( elem ) ) { \r\n          // Если текст не введен, отображение сообщения об ошибке и \r\n          // предотвращение отправки данных формы. \r\n          alert( \"Обязательное поле не заполнено – пожалуйста, \r\n                  введите Ваше имя\". ); \r\n          return false; \r\n       } \r\n    }; \r\n};  \r\nСправившись с проверкой заполнения обязательных полей, нужно убедиться в том, что введенные поля \r\nсодержат вполне ожидаемые значения. В следующем разделе мы собираемся рассмотреть, как осуществляется \r\nпроверка содержимого полей. \r\n","\r\n 166\r\nСоответствие шаблону \r\nВторой составляющей проверки большинства элементов ввода (особенно текстовых полей) является \r\nопределение соответствия шаблону, чтобы проверить, что содержимое полей отвечает определенным \r\nпредположениям. \r\nПри использовании следующей технологии важно понять, что ваши требования к содержимому поля \r\nдолжны быть точно и ясно определены. В противном случае не все пользователи смогут понять, что именно от них \r\nтребуется. Неплохим примером подобных требования может послужить запрос дат в определенном формате, \r\nпоскольку даты меняются в зависимости от сложившихся традиций и даже от разных подходов в спецификациях. \r\nВ этом разделе мы собираемся рассмотреть ряд различных технологий, которые могут быть использованы \r\nдля проверки содержимого полей, включая адреса электронной почты, URL, телефонные номера и даты. \r\nАдреса электронной почты \r\nПоле запроса адреса электронной почты встречается в веб-формах довольно часто, поскольку это \r\nпрактически повсеместная форма идентификации и связи. Но провести подлинную проверку на истинность \r\nэлектронного адреса (в соответствии со спецификациями на которых он основан) очень трудно. Вместо этого \r\nможно обеспечить упрощенную проверку, которая сможет работать со всеми встречающимися примерами. В \r\nлистинге 8.4 показан пример проверки поля ввода на наличие в нем адреса электронной почты. \r\nЛистинг 8.4. Проверка на наличие в определенном элементе ввода адреса электронной почты \r\n// Универсальная функция для проверки, похоже ли содержимое элемента ввода \r\n// на адрес электронной почты \r\nfunction checkEmail( elem ) { \r\n    // Определение, что в поле что-то введено, и что введенное значение \r\n    // похоже на приемлемый адрес электронной почты \r\n    return elem.value == '' || \r\n       /^[a-z0-9_+.-]+\\@([a-z0-9-]+\\.)+[a-z0-9]{2,4}$/i.test( elem.value ); \r\n} \r\n  \r\n// Получение проверяемого элемента ввода \r\nvar elem = document.getElementById(\"email\"); \r\n  \r\n// Проверка приемлемости содержимого поля \r\nif ( ! checkEmail( elem ) ) { \r\n    alert( \"Поле не содержит адреса электронной почты\". ); \r\n} \r\nURL \r\nВо многих формах ввода комментариев (и других сетевых областях) довольно часто запрашивается адрес \r\nпользовательского веб-сайта в форме URL. Это еще один пример (наряду с адресом электронной почты) когда \r\nочень трудно полностью задать технические требования по его определению. Но существуют и другие ситуации, в \r\nкоторых все, что необходимо на самом деле — это небольшое подмножество полных технических требований. В \r\nдействительности вам нужны лишь веб-адреса, основанные на протоколах http или https (если нужно что-либо \r\nдругое, то изменения внести совсем не трудно). Кроме того, для поля URL типичным началом будет строка http://, \r\nпоэтому вам при проверки формы следует убедиться, что это обстоятельно было принято во внимание. Пример \r\nпроверки приемлемости предоставленных в форме URL показан в листинге 8.5. \r\n","\r\n 167\r\nЛистинг 8.5. Проверка на наличие URL в элементе ввода \r\n// Универсальная функция, предназначенная для проверки наличия URL в \r\n// элементе ввода \r\nfunction checkURL( elem ) { \r\n    // Определение, что в поле что-то введено, и что введенное значение \r\n    // не является уже введенным по умолчанию текстом http:// \r\n    return elem.value == '' || !elem.value == 'http://' || \r\n    // Определение, что введенное значение похоже на приемлемый URL \r\n    /^https?:\\/\\/([a-z0-9-]+\\.)+[a-z0-9]{2,4}.*$/.test( elem.value ); \r\n} \r\n  \r\n// Получение проверяемого элемента ввода \r\nvar elem = document.getElementById(\"url\"); \r\n  \r\n// Проверка, содержит ли поле приемлемый URL \r\nif ( ! checkURL( elem ) ) { \r\n    alert( \"Поле не содержит URL\". ); \r\n} \r\nТелефонные номера \r\nТеперь мы рассмотрим два разных поля, содержимое которых различается в зависимости от места вашего \r\nпребывания: поле телефонных номеров и поле дат. Чтобы упростить задачу, я воспользовался телефонными \r\nномерами (и датами) центральной части США; приспособить задачу под условия другой страны не представляет \r\nособой сложности. \r\nТеперь рассмотрим несколько вариантов поля телефонных номеров. Номера могут быть записаны \r\nнесколькими различными способами, следовательно это нужно учесть (например, 123-456-7890, или (123) 456-\r\n7890). \r\nМы собираемся не только проверить приемлемость телефонного номера, но и привести его к \r\nопределенному формату. Эта задача решается за счет весьма универсального поиска в значении поля \r\nтелефонного номера, направленного на простое обнаружение двух групп по три цифры и одной группы из \r\nчетырех цифр, при этом все дополнительное форматирование, введенное пользователем вокруг этих цифр, \r\nигнорируется. \r\nКод этой проверки и приведения значения к определенному формату, показан в листинге 8.6. \r\nЛистинг 8.6. Проверка поля на наличие телефонного номера \r\n  \r\n// Универсальная функция, предназначенная для проверки наличия в элементе \r\n// ввода телефонного номера \r\nfunction checkPhone( elem ) { \r\n    // Проверка на наличие чего-либо похожего на приемлемый телефонный \r\n    // номер \r\n    var m = /(\\d{3}).*(\\d{3}).*(\\d{4})/.exec( elem.value ); \r\n  \r\n    // Если похоже что, номер приемлем, приведение его к \r\n","\r\n 168\r\n    // определенному желаемому формату: (123) 456-7890 \r\n    if ( m !== null) \r\n       elem.value = \"(\" + m[1] + \") \" + m[2] + \"-\" + m[3]; \r\n    \r\n    return elem.value == '' || m !== null; \r\n    } \r\n  \r\n// Получение проверяемого элемента ввода \r\nvar elem = document.getElementById(\"phone\"); \r\n  \r\n// Проверка наличия в поле приемлемого телефонного номера \r\nif ( ! checkPhone( elem ) ) { \r\n    alert( \"Поле не содержит телефонного номера\". ); \r\n}  \r\nДата \r\nИ теперь нам осталось рассмотреть проверку дат. Мы опять обратимся к Центральноамериканскому \r\nформату, на этот раз для даты (ММ/ДД/ГГГГ). И опять, как в случае с телефонными номерами или другими полями, \r\nчье заполнение зависит от конкретного региона, регулярное выражение, используемое для проверки, при \r\nнеобходимости может быть легко перенастроено под региональные особенности. Простая проверка содержимого \r\nполя даты может быть произведена с помощью функции, показанной в листинге 8.7. \r\nЛистинг 8.7. Проверка поля на наличие даты \r\n// Универсальная функция, предназначенная для проверки наличия даты в \r\n// элементе ввода \r\nfunction checkDate( elem ) { \r\n    // Определение, что в поле что-то введено, и что введенное значение \r\n    // похоже на приемлемую дату в формате ММ/ДД/ГГГГ \r\n    return !elem.value || /^\\d{2}\\/\\d{2}\\/\\d{2,4}$/.test(elem.value); \r\n} \r\n  \r\n// Получение проверяемого элемента ввода \r\nvar elem = document.getElementById(\"date\"); \r\n  \r\n// Проверка наличия в поле приемлемой даты \r\nif ( ! checkDate( elem ) ) { \r\n    alert( \"Поле не содержит даты\". ); \r\n} \r\nНабор правил \r\nТеперь, используя различные функции проверки из предыдущего раздела, вы можете создать \r\nуниверсальную структуру для работы со всем многообразием проверочных технологий. Важно, чтобы все тесты \r\nотрабатывались однообразно, с использованием общих названий и общей семантики сообщений об ошибках. \r\nПолная структура набора правил изложена в листинге 8.8. \r\nЛистинг 8.8. Стандартный набор правил и описательных сообщений об ошибках для построения основного \r\nмеханизма проверки \r\n","\r\n 169\r\nvar errMsg = { \r\n    // Проверка обязательности определенного поля \r\n    required: { \r\n       msg: \"Это обязательное поле\"., \r\n       test: function(obj,load) { \r\n           // Обеспечение отсутствия в поле введенного текста \r\n           // и задержки начала работы на загружаемой странице \r\n           // (демонстрация сообщения 'Это обязательное поле' при загрузке \r\n           // страницы будет только раздражать пользователя) \r\n           return obj.value.length > 0 || load || obj.value == \r\n                                                   obj.defaultValue; \r\n       } \r\n    }, \r\n  \r\n    // Определение наличия в поле приемлемого адреса электронной почты \r\n    email: { \r\n       msg: \"Введенный адрес неприемлем\"., \r\n       test: function(obj) { \r\n           // Определение, что в поле что-то введено, и что введенное \r\n           // значение похоже на адрес электронной почты \r\n           return !obj.value || \r\n           /^[a-z0-9_+.-]+\\@([a-z0-9-]+\\.)+[a-z0-9]{2,4}$/i.test( \r\n                                                       obj.value ); \r\n       } \r\n    }, \r\n  \r\n    // Определение, что поле содержит телефонный номер, и \r\n    // его автоформатирование в случае положительного результата \r\n    phone: { \r\n       msg: \"Введенный номер неприемлем\"., \r\n       test: function(obj) { \r\n           // Определение, что введенное значение  похоже \r\n           // на приемлемый телефонный номер \r\n           var m = /(\\d{3}).*(\\d{3}).*(\\d{4})/.exec( obj.value ); \r\n  \r\n           // Если похоже на то, что, номер приемлем, приведение \r\n           // его к определенному желаемому формату: (123) 456-7890 \r\n           if ( m ) obj.value = \"(\" + m[1]+\") \" + m[2]+\"-\"+m[3]; \r\n  \r\n           return !obj.value || m; \r\n       } \r\n    }, \r\n  \r\n    // Определение, что поле содержит приемлемую дату \r\n    // формата ММ/ДД/ГГГГ \r\n    date: { \r\n       msg: \"Дата неприемлема\"., \r\n       test: function(obj) { \r\n","\r\n 170\r\n           // Определение, что в поле что-то введено, и что введенное \r\n           // значение похоже на приемлемую дату формата ММ/ДД/ГГГГ \r\n           return !obj.value || /^\\d{2}\\/\\d{2}\\/\\d{2,4}$/.test(obj.value); \r\n       } \r\n    }, \r\n  \r\n    // Определение, что поле содержит приемлемый URL \r\n    url: { \r\n       msg: \"URL неприемлем\"., \r\n       test: function(obj) { \r\n           // Определение, что в поле введен какой-нибудь текст, и он \r\n           // отличается от уже введенного по умолчанию текста \r\n           // http:// \r\n               return !obj.value || obj.value == 'http://' || \r\n                  // Определение, что введенное значение похоже на \r\n                  // приемлемый URL \r\n                  /^https?:\\/\\/([a-z0-9-]+\\.)+[a-z0-9]{2,4}.*$/.test( \r\n                                                           obj.value ); \r\n       } \r\n    } \r\n};  \r\nТеперь, используя эту новую структуру набора правил, вы можете создать общие, согласованные средства \r\nпроверки формы и отображения сообщений об ошибках, которые я рассматриваю в следующем разделе. \r\nОтображение сообщений об ошибках \r\nЕсли процесс проверки данных формы не вызывает особых затруднений, то отображения контекстно-\r\nзависимых сообщений об ошибках, способных помочь пользователю более качественно заполнить форму, \r\nзачастую вызывает определенные трудности. Теперь все созданное в предыдущем разделе мы собираемся \r\nиспользовать для создания полноценной системы проверки и отображения сообщений об ошибках. Мы собираемся \r\nрассмотреть, как осуществляется проверка формы и отображение сообщений об ошибках, и когда все это должно \r\nпроисходить, чтобы пользователь все понял наилучшим образом. \r\nПроверка приемлемости данных \r\nИспользуя новую структуру данных можно построить согласованную, расширяемую пару функций, которая \r\nможет быть использована для проверки приемлемости данных формы или отдельного поля, и отображения на \r\nоснове этой проверки контекстно-зависимого сообщения об ошибке. \r\nЧтобы добиться динамической проверки формы используются две технологии. Первая из них \r\nпредоставляется браузерами и представляет собой часть HTML DOM-спецификации. Все <form>-элементы (в DOM) \r\nобладают дополнительным свойством под названием elements. Это свойство содержит массив всех полей, \r\nприсутствующих в форме, и это значительно облегчает переход по всем имеющимся полям для проверки ошибок \r\nввода. \r\nВторая важная составляющая заключается во включении во все поля дополнительных классов для \r\nпереключения различных правил проверки. К примеру, наличие класса — required (обязательное) потребует от \r\nполя ввода какой-нибудь формы ввода данных. Каждый из классов должен соответствовать тем, которые были \r\nпредоставлены в наборе правил, показанном в листинге 8.8. \r\n","\r\n 171\r\nТеперь, используя эти две технологий, вы можете создать две универсальные функции для проверки \r\nприемлемости данных всех форм и отдельных полей (и обе эти задачи потребуют полноценного проверочного \r\nсценария). Эти две функции показаны в листинге 8.9. \r\nЛистинг 8.9. Функции, предназначенные для проверки приемлемости данных, введенных в форму, и \r\nотображения сообщений об ошибках \r\n// Функция проверки всех полей внутри формы. \r\n// Аргумент form должен быть ссылкой на элемент формы \r\n// Аргумент load должен быть булевой ссылкой на то, что функция проверки \r\n// запускается не в динамическом режиме, а после загрузке страницы \r\nfunction validateForm( form, load ) { \r\n    var valid = true; \r\n  \r\n    // Последовательный перебор всех имеющихся в форме элементов полей \r\n    // form.elements — массив всех имеющихся в форме полей \r\n    for ( var i = 0; i < form.elements.length; i++ ) { \r\n  \r\n       // Скрытие любых сообщений об ошибках, если они были показаны \r\n       hideErrors( form.elements[i] ); \r\n  \r\n       // Проверка содержимого поля на приемлемость \r\n       if ( ! validateField( form.elements[i], load ) ) \r\n           valid = false; \r\n    } \r\n    \r\n    // Возвращение false, если содержимое поля неприемлемо, \r\n    // и true, если значение всех полей приемлемо \r\n    return valid; \r\n} \r\n  \r\n// Проверка приемлемости содержимого отдельного поля \r\nfunction validateField( elem, load ) { \r\n    var errors = []; \r\n    \r\n    // Последовательный перебор всех имеющихся технологий проверки \r\n    // приемлемости \r\n    for ( var name in errMsg ) { \r\n       // Определение, имеет ли поле класс, определенный типом ошибки \r\n       var re = new RegExp(\"(^|\\\\s)\" + name + \"(\\\\s|$)\"); \r\n  \r\n       // Определение, имеет ли элемент класс, и передан ли он тесту \r\n       // на приемлемость данных \r\n       if ( re.test( elem.className ) && !errMsg[name].test( elem, load ) ) \r\n           // Если проверка не удалась, добавление сообщения об ошибке к \r\n           // списку \r\n           errors.push( errMsg[name].msg ); \r\n    } \r\n  \r\n","\r\n 172\r\n    // Отображение сообщений об ошибке, если таковые имеются \r\n    if ( errors.length ) \r\n       showErrors( elem, errors ); \r\n  \r\n    // Возвращение false, если поле не прошло какую-нибудь процедуру \r\n    // проверки \r\n    return errors.length > 0; \r\n}  \r\nВозможно, в предыдущем коде вы заметили отсутствие двух функций, относящихся к скрытию и \r\nотображению сообщений об ошибках, обнаруженных во время проверки. Возможно, эти функции потребуют \r\nнекоторой настройки в соответствии с вашими желаниями по характеру отображения сообщений об ошибках. Но \r\nдля данной конкретной формы я избрал вариант отображения сообщений об ошибках внутри самой формы, сразу \r\nпосле отображения каждого из полей. Две функции, предназначенные для выполнения этого замысла, показаны в \r\nлистинге 8.10. \r\nЛистинг 8.10. Функции для отображения и скрытия сообщениях об ошибках, обнаруженных во время \r\nпроверки определенного поля формы \r\n// Скрытие любых отображаемых на данный момент сообщений об ошибках, \r\n// обнаруженных во время проверки \r\nfunction hideErrors( elem ) { \r\n    // Обнаружение следующего за текущим полем элемента \r\n    var next = elem.nextSibling; \r\n  \r\n    // Если следующий элемент ul и имеет класс errors \r\n    if ( next && next.nodeName == \"UL\" && next.className == \"errors\" ) \r\n       // его следует удалить (в нашем смысле — 'скрыть') \r\n       elem.parenttNode.removeChild( next ); \r\n    } \r\n  \r\n    // Отображение набора сообщений об ошибках для определенного поля \r\n    // внутри формы \r\n    function showErrors( elem, errors ) { \r\n       // Обнаружение следующего за полем элемента \r\n       var next = elem.nextSibling; \r\n  \r\n        // Если поле не является одним из наших специальных контейнеров \r\n       // для сообщений об ошибке \r\n       if ( next && ( next.nodeName != \"UL\" || next.className \r\n                                            != \"errors\" ) ) { \r\n           // То такое поле нужно создать \r\n           next = document.createElement( \"ul\" ); \r\n           next.className = \"errors\"; \r\n  \r\n           // а затем вставить его в нужное место в DOM-структуре \r\n           elem.paretNode.insertBefore( next, elem.nextSibling ); \r\n    } \r\n  \r\n","\r\n 173\r\n    // Теперь, имея ссылку на контейнер сообщений об ошибках — UL \r\n    // осуществляем последовательный перебор всех сообщений \r\n    for ( var i = 0; i < errors.length; i++ ) { \r\n       // создаем новый контейнер li для каждого из них \r\n       var li = document.createElement( \"li\" ); \r\n       li.innerHTML = errors[i]; \r\n  \r\n       // и вставляем его в DOM \r\n       next.appendChild( li ); \r\n    } \r\n} \r\nТеперь, когда работа с кодом JavaScript завершена, осталось лишь добавить сообщениям об ошибках \r\nкакое-нибудь дополнительное стилевое оформление, чтобы придать им вполне приглядный вид. Код CSS, \r\nпредназначенный для решения этой задачи, показан в листинге 8.11. \r\nЛистинг 8.11. Дополнительный код CSS, предназначенный для придания сообщениям об ошибках \r\nсоответствующего вида \r\nul.errors { \r\n    list-style: none; \r\n    background: #FFCECE; \r\n    padding: 3px; \r\n    margin: 3px 0 3px 70px; \r\n    font-size: 0.9em; \r\n    width: 165px; \r\n} \r\nИ наконец, когда все составляющие сложены воедино, можно посмотреть на конечный результат работы \r\nJavaScript и таблицы стилей, показанный на рис. 8.2  (полученный после того, как все это было связано с \r\nотслеживателями событий, рассматриваемыми в следующем разделе). \r\nТеперь, когда вы точно знаете, как осуществить проверку приемлемости данных формы (и полей, которые \r\nв ней содержатся) и отобразить сообщения об ошибках, основанные на любых неудачах, настало время \r\nопределить момент запуска ваших проверочных процедур. Одновременное проведение проверки всех полей не \r\nвсегда является лучшим вариантом, зачастую больше подходит ее постепенное проведение. Мы рассмотрим \r\nпреимущества всех остальных случаев, в которых используется проверка приемлемости в следующем разделе. \r\n","\r\n 174\r\n \r\nРис. 8.2. Пример приемлемого и неприемлемого ввода данных в вашей заново стилизованной и \r\nобработанной сценарием форме \r\nКогда следует проводить проверку \r\nОдин из наиболее трудных аспектов проведения проверки формы является определение подходящего \r\nмомента для отображения сообщений об ошибках. Для проверки формы (или поля) есть три различных момента \r\nвремени: непосредственно перед отправкой данных формы, после внесения изменений в поле, и после загрузки \r\nстраницы. У каждого из них есть свои преимущества и недостатки, требующие отдельного рассмотрения. \r\nИспользование разработанных в предыдущем разделе функций упрощает и облегчает осмысление этого процесса. \r\nПроверка, предшествующая отправке данных формы \r\nНаибольшее распространение получила проверка, осуществляемая непосредственно перед отправкой \r\nформы, поскольку она лучше всего вписывается в стандартные проверочные технологии. Чтобы отследить момент, \r\nнаступающий непосредственно перед передачей формы, нужно осуществить привязку обработчика события, \r\nкоторый будет ожидать завершения заполнения формы и щелчка на кнопке отправки — Submit (или нажатия \r\nклавиши Enter). При этом не ставится обязательное условие, что во все поля пользователь уже ввел какие-нибудь \r\nзначения, но раз форма направлена на отправку, она проходит проверку на соответствие всем правилам \r\nопределенного набора. Если какое-то из полей не соответствует какому-нибудь правилу, форма не будет \r\nотправлена, и пользователю придется разбираться в предъявленных ему сообщениях об ошибках (что делается за \r\nсчет подавления исходных действий обработчика события submit). Необходимы для реализации этой технологии \r\nкод показан в листинге 8.12. \r\nЛистинг 8.12. Ожидание события отправки для запуска функции проверки формы \r\nfunction watchForm( form ) { \r\n","\r\n 175\r\n    // Отслеживание события отправки формы \r\n    addEvent( form, 'submit', function(){ \r\n  \r\n       // Обеспечение прохождения формой проверки приемлемости данных \r\n       return validateForm( form ); \r\n    }); \r\n} \r\n  \r\n// Обнаружение первой формы на странице \r\nvar form = document.getElementsByTagName( \"form\" )[0]; \r\n  \r\n// и отслеживание ее события отправки для того, чтобы подвергнуть проверке \r\nwatchForm( form );  \r\nПроверка после внесения в поле изменений \r\nДругая технология, применяемая для проверки приемлемости данных формы, заключается в отслеживании \r\nвнутри отдельных полей формы. Для этого можно воспользоваться событием нажатия клавиши — keypress, но это \r\nприведет к нежелательным результатам. Постоянное отслеживание ошибки при каждом нажатии клавиши в \r\nпределах поля будет сбивать пользователей с толку. Они (к примеру) могут приступить к вводу адреса своей \r\nэлектронной почты, и увидят сообщение об ошибке, в котором утверждается, что их адрес некорректен. Но это \r\nбудет неверно, поскольку они еще не завершили ввод данных в поле. В общем, нам такая технология не \r\nподойдет, поскольку пользователь будет от нее не в восторге. \r\nВторой способ отслеживания изменений в поле заключается в ожидании, пока пользователь его не \r\nпокинет (в надежде на то, что он ввел всю необходимую информацию). Проведение такой проверки \r\nвоспринимается пользователем намного легче, поскольку он получает возможность ввести всю желаемую \r\nинформацию, и ему по прежнему выдается оперативное сообщение об ошибке, вызванной неприемлемостью \r\nданных. \r\nПример реализации этой технологии показан в листинге 8.13. \r\nЛистинг 8.13. Отслеживание изменений в поле перед запуском любых проверочных функций \r\nfunction watchFields( form ) { \r\n    // Последовательный перебор всех элементов полей формы \r\n    for ( var i = 0; i < form.elements.length; i++ ) { \r\n  \r\n       // и прикрепление к ним обработчика события 'change' (отслеживающего \r\n       // потерю фокуса элементом ввода) \r\n       addEvent( form.elements[i], 'change', function(){ \r\n           // Как только фокус утрачен, перепроверка поля \r\n           return validateField( this ); \r\n       }); \r\n    } \r\n} \r\n  \r\n// Обнаружение первой формы на странице \r\nvar form = document.getElementsByTagName( \"form\" )[0]; \r\n  \r\n","\r\n 176\r\n// Отслеживание изменений во всех полях формы \r\nwatchFields( form ); \r\nПроверка после загрузки страницы \r\nПроверка формы после загрузки страницы не столь востребована, как предыдущие две технологии, но \r\nесли вы хотите охватить и особые случаи, ее тоже нужно включить в свой арсенал. Если пользователь вводит в \r\nформу информацию, а затем повторно загружает окно браузера (или если браузер или само приложение заранее \r\nзаполняет форму пользовательской информацией), существует вероятность, что ошибка будет допущена в \r\nинформации, используемой для предварительного заполнения. Эта технология разработана для запуска проверки \r\nприемлемости данных формы при каждой загрузке страницы для оценки качества уже введенных данных. \r\nПри этом пользователь получает возможность немедленной работы над ошибками, не дожидаясь проверки \r\nданных, запущенной по событию их отправки. \r\nКод, необходимый для проверки приемлемости данных формы после загрузки страницы, показан в \r\nлистинге 8.14. \r\nЛистинг 8.14. Осуществление проверки формы после загрузки страницы \r\naddEvent( window, \"load\", function() { \r\n    // Обнаружение всех форм на странице \r\n    var forms = document.getElementsByTagName(\"form\"); \r\n  \r\n    // Последовательный перебор всех форм на странице \r\n    for ( var i = 0; i < forms.length; i++ ) { \r\n  \r\n       // Проверка каждой из форм, установив аргумент 'load' \r\n       // в true, чтобы остановить появление определенных, совершенно \r\n       // ненужных ошибок \r\n       validateForm( forms[i], true ); \r\n    } \r\n});  \r\nОсвоив всевозможные формы проверки, способы отображения сообщений об ошибках, и даже рассмотрев \r\nвопрос, когда следует проводить проверку формы, мы подошли к достойному финишу: полной проверке формы на \r\nстороне клиента. После того, как мы справились с этой задачей, можно приступать к исследованию двух \r\nдополнительные технологии, повышающих качество работы с формами и с определенными типами ее полей. \r\nПовышение качества работы с формами \r\nУчитывая, что формы относятся к наиболее часто используемым элементам веб-страниц, повышение \r\nкачества работы с ними принесет пользователю несомненные выгоды. В этом разделе я собираюсь рассмотреть \r\nдве разные, довольно широко распространенные технологии, которые довольно часто используются для \r\nповышения качества работы с формами. \r\nКроме этого вам представится еще одна возможность воспользоваться библиотекой JavaScript для \r\nупрощения трудоемких DOM-перемещений и изменений, необходимых для выполнения намеченной нами задачи. \r\nДля двух представленных здесь технологий я выбрал использование JavaScript-библиотеки jQuery \r\n(http://jquery.com/), которая, в частности, хорошо подходит для осуществления DOM-перемещений и изменений. \r\nНакладные надписи \r\n","\r\n 177\r\nПервое из рассматриваемых усовершенствований, касается установочных (накладных) надписей поверх \r\nсвязанных с ними полей, и их скрытия, как только соответствующее им поле получает фокус. Эта технология \r\nимеет двойное предназначение. Она абсолютно точно объясняет пользователю, что предполагается вводить в \r\nконкретное поле (поскольку то, что предполагается в него вводить написано поверх самого поля). И к тому же она \r\nпозволяет уменьшить общее пространство, необходимое для поля и соответствующей ему надписи. \r\nВ нашей исходной форме мы добавим эти две накладные надписи к полям имени пользователя — username \r\nи пароля — password, чтобы получить результат, показанный на рис. 8.3. \r\n \r\nРис. 8.3. Использование накладных надписей для полей имени пользователя и пароля \r\nКод JavaScript, необходимый для получения этого специфического эффекта, будет сравнительно \r\nнепростым. Для гладкой работы в него потребуется включить множество мелких подробностей. Рассмотрим две \r\nособенности, необходимые для получения конечного результата. \r\nВо-первых, чтобы позиционировать надписи поверх самих элементов ввода, сначала нужно поместить и \r\nнадпись, и элемент ввода в div-контейнер. Этот div используется таким образом, чтобы можно было абсолютно \r\nпозиционировать надпись поверх поля. \r\nВо-вторых, это нужно сделать так, чтобы когда поле получало или утрачивало фокус, надпись \r\nсоответственно скрывалась (или отображалась). Кроме этого, когда пользователь покидает поле, нужно \r\nпроверить, имеет ли оно какое-нибудь значение, и если имеет, больше не показывать надпись. \r\nИ наконец, нужно обеспечить, чтобы надпись не появлялась, если значение помещается в поле по \r\nумолчанию (иначе у вас получится полная мешанина). \r\nПамятуя обо всем этом, давайте взглянем на код, необходимый для получения накладных надписей внутри \r\nформы, который представлен в листинге 8.15. \r\nЛистинг 8.15. Накладные надписи, появляющиеся поверх полей, реализованные с помощью JavaScript-\r\nбиблиотеки jQuery \r\n// Обнаружение всех элементов ввода, следующих за надписями, имеющими \r\n// класс hover \r\n$(\"label.hover+input\") \r\n","\r\n 178\r\n  \r\n    // Заключение элемента ввода в div (имеющий класс hover-wrap), \r\n    // чтобы получить следующий HTML: \r\n    // <div class='hover-wrap'><input type=\"text\" ...;/></div> \r\n    .wrap(\"<div class='hover-wrap'></div>\") \r\n  \r\n    // Скрытие надписи при каждом получении элементом ввода фокуса \r\n    // (либо за счет щелчка, либо за счет клавиатурных манипуляций) \r\n    .focus(function(){ \r\n       $(this).prev().hide(); \r\n    }) \r\n  \r\n    // Повторный показ надписи при выходе пользователя за пределы \r\n    // элемента ввода (без ввода в него какого-либо текста). \r\n    .blur(function(){ \r\n       if ( !this.value ) $(this).prev().show() \r\n    }) \r\n  \r\n    // Индивидуальный перебор всех элементов ввода \r\n    .each(function(){ \r\n       // Внедрение надписи в <div class='hover-wrap'></div> \r\n       $(this).before( $(this).parent().prev() ); \r\n  \r\n       // Обеспечение автоматического скрытия надписи, если \r\n       // значение уже введено \r\n       if ( this.value ) $(this).prev().hide(); \r\n});  \r\nНо для достижения желаемого результата одного JavaScript недостаточно. Все-таки для того, чтобы \r\nнадписи и поля встали на правильные позиции, нужно обязательно включить дополнительные стили CSS. \r\nНеобходимый для этого код показан в листинге 8.16. \r\nЛистинг 8.16. Стили CSS, необходимые, чтобы заставить надписи накладываться на связанные с ними поля \r\ndiv.hover-wrap { \r\n    position: relative; \r\n    display: inline; \r\n} \r\n  \r\ndiv.hover-wrap input.invalid { \r\n    border: 2px solid red; \r\n} \r\n  \r\ndiv.hover-wrap ul.errors { \r\n    display: none; \r\n} \r\n  \r\ndiv.hover-wrap label.hover { \r\n    position: absolute; \r\n","\r\n 179\r\n    top: -0.7em; \r\n    left: 5px; \r\n    color: #666; \r\n}  \r\nВот так, без особого труда, мы создали очень полезное усовершенствование, повышающее качество \r\nработы с формой. Использование этой специализированной технологии позволяет убить сразу двух зайцев: \r\nсэкономить место на экране, и сохранить необходимые для пользователя указания. \r\nПометка обязательных полей \r\nВторая технология, которую мы собираемся рассмотреть, касается пометки обязательных полей каким-\r\nнибудь знаком. Большинство веб-разработчиков выбрали для пометки обязательных полей на своих веб-сайтах \r\nкрасную звездочку. Но дополнительная разметка, необходимая для включения этих звездочек, выходит за рамки \r\nобычной семантики, и может стать обескураживающим моментом. Но для нас это станет лишь прекрасной \r\nвозможностью воспользоваться для добавления знака JavaScript. Пример этой технологии показан на рис. 8.4. \r\n \r\nРис. 8.4. Результат добавления контекстно-зависимых звездочек к обязательным полям формы \r\nОдним из аспектов добавления этих знаков к надписям обязательных полей заключается в дополнении \r\nформы специальным вспомогательным текстом, который служит пояснением для пользователей. Использование \r\nатрибута title позволит предоставить пользователям сообщение, поясняющее значение красной звездочки (на тот \r\nслучай, если они с ним не знакомы). В общем, реализация этого усовершенствования не отличается сложностью, \r\nи показана в листинге 8.17. \r\nЛистинг 8.17. Добавление контекстно-зависимых звездочек (*) и пояснительных сообщений к \r\nобязательным полям формы с использованием JavaScript-библиотеки jQuery \r\n// обнаружение всех полей ввода, помеченных обязательными (required) \r\n$(\"input.required\") \r\n    // затем обнаружение предшествующей им надписи \r\n    .prev(\"label\") \r\n  \r\n    // Изменение курсора при прохождении над надписью на более \r\n    // полезный элемент \r\n","\r\n 180\r\n    .css(\"cursor\", \"help\") \r\n  \r\n    // Обеспечение появления поясняющей надписи для звездочки при \r\n    // прохождении над ней указателя мыши \r\n    .title( errMsg.required ) \r\n  \r\n    // И наконец, добавление звездочки (*) к надписи, чтобы обозначить \r\n    // обязательное поле \r\n    .append(\" <span class='required'>*</span>\"); \r\nДля получения стилевого оформления, необходимо добавить к значку красную расцветку (см. \r\nлистинг 8.18). \r\nЛистинг 8.18. Дополнительный код CSS для стилевого оформления звездочки (*) \r\nlabel span.required { \r\n    color: red; \r\n} \r\nДобавление пометок и накладных надписей — это существенное повышение качества работы с формами, \r\nкоторое можно получить за счет использования JavaScript в ненавязчивой и полезной форме. Я уверен, что в \r\nсвоих приложениях вы всегда найдете массу возможностей для усовершенствования работы с формами и полями \r\nза счет использования простого кода JavaScript. \r\nВыводы \r\nПоказав вам сначала ряд аспектов, затрудняющих использование форм в веб-приложених, я надеюсь, что \r\nсумел поднять ваше настроение научив, как с помощью простого дополнительного кода на JavaScript существенно \r\nулучшить общее качество работы с формами. Пример всего, что удалось достичь в этой главе, показан на рис. 8.5. \r\n","\r\n 181\r\n \r\nРис. 8.5. Законченный вид формы, усовершенствованной за счет JavaScript \r\nМы начали главу с рассмотрения, как наиболее точно провести проверку приемлемости данных на стороне \r\nклиента, оставив при этом у пользователя наилучшие впечатления от ее работы. Этого удалось добиться за счет \r\nсоздания набора проверочных правил, проверки приемлемости данных в полях формы в самые подходящие для \r\nэтого моменты, и отображения полезных для пользователя сообщений об ошибках. Вдобавок мы рассмотрели две \r\nтехнологии, повышающие качество работы пользователя с формой за счет накладных надписей и пометки \r\nобязательных полей. \r\nЯ надеюсь, что все вместе взятые представленные здесь технологии, могут быть широко задействованы \r\nвами в тех формах, которые вам еще предстоит разработать. \r\n  \r\n","\r\n 182\r\nГлава 9 Создание галерей изображений \r\nРабота с DOM, перемещение по элементам и динамическое использование CSS — все это направлено на \r\nто, что бы создать у конечного пользователя положительное впечатление о веб-сайте о простоте и легкости \r\nуправления его работой. Галерея изображений (позволяющая осуществлять из просмотр и перебор) является \r\nодним из тех приложений, которые получают от применения этих технологий явное преимущество. Повысившееся \r\nкачество браузеров позволяет использовать динамические сценарии и утилиты. В последнее время эти \r\nусовершенствования привели к созданию ряда высококачественных галерей изображений. \r\nВ этой главе мы рассмотрим две такие галереи, и посмотрим, в чем заключается их конкретная \r\nуникальность, а затем создадим свою собственную галерею, используя динамический, ненавязчивый код \r\nJavaScript. При этом будет рассмотрен ряд вопросов, касающихся подробностей конструкции и реализации \r\nгалереи. Конечным результатом станет эффективно работающий сценарий создания галереи изображений, \r\nкоторый может без труда размещен на любом веб-сайте. Кроме этого у нас появится отличная возможность для \r\nприменения функций, разработанных в пятой и седьмой главах, в которых для создания простого и качественного \r\nкода будет использована совместная работа DOM, JavaScript и CSS. \r\nПримеры галерей \r\nИмеется несколько превосходных, современных сценариев галерей изображений, оставляющих яркое \r\nвпечатление, удобных в работе и полностью отвечающих принципам ненавязчивости. Два сценария, которые мы \r\nсобираемся рассмотреть подробнее, обладают очень похожими визуальными эффектами, но используют в основе \r\nсвоего кода разные библиотеки. \r\nРаботу галерей можно кратко представить следующим образом: \r\n• Когда на одном из изображений галереи происходит щелчок мышью, вместо перенаправления \r\nпользователя на просмотр этого изображения, происходит его наложение на экран. \r\n• Когда отображается наложенное на экран изображение, поверх страницы накладывается прозрачный \r\nсерый фильтр (снижая яркость всего, что под него попало). \r\n• Отображаемое в данный момент изображение каким-либо образом помечается в галерее изображений. \r\n• Существует какой-нибудь способ перехода по галерее от одного изображения к другому. \r\nВ этом разделе мы собираемся рассмотреть галереи, которые создаются двумя очень известными \r\nбиблиотеками — Lightbox и ThickBox. \r\nLightbox \r\nLightbox является первой из DOM-галерей «нового стиля». Ее выпуск подтолкнул на создание ряда других \r\nгалерей подобного стиля, положенных в основу материалов этой главы. \r\nЭта галерея разрабатывалась с нуля (без использования в качестве основы какой-то конкретной \r\nJavaScript-библиотеки). Но с тех пор она была приспособлена к использованию различных библиотек (что \r\nпривело к сокращению общего объема ее кода). Дополнительная информация об этом сценарии может быть \r\nнайдена по адресам http://www.huddletogether.com/projects/lightbox/ и http://particletree.com/ features/lightbox-\r\ngone-wild/, где представлены сведения о Lightbox, использующей JavaScript-библиотеку Prototype. \r\nНа рис. 9.1 показан пример копии экрана галереи Lightbox в действии, с ее уникальным наложением \r\nпрозрачного затемнения и размещенным по центру изображением. \r\n","\r\n 183\r\n \r\nРис. 9.1. Lightbox отображает отдельное изображение, принадлежащее галереи \r\nLightbox всецело работает в ненавязчивой манере. Чтобы воспользоваться этой библиотекой нужно просто \r\nвключить сценарий в заголовок вашего HTML-файла и модифицировать HTML изображения, которые вы хотите \r\nотображать с ее использованием, и тогда код сценария сделает все остальное: \r\n<a href=\"images/image-1.jpg\" rel=\"lightbox\" title=\"сопроводительная \r\n                                                   надпись\">фото No1</a>  \r\nК сожалению, ненавязчивая природа кода не столь совершенна, как могла бы быть (вместо того, чтобы \r\nотслеживать готовность DOM, библиотека ожидает загрузки всех изображений). Тем не менее, задействованные \r\nDOM-сценарии (см. листинг 9.1) совершенно рациональны и пригодны к использованию. \r\nЛистинг 9-1. Обнаружение всех элементов ссылки (anchor) и их преобразование для правильного отображения \r\n// Обнаружение на странице всех тегов anchor \r\nvar anchors = document.getElementsByTagName(\"a\"); \r\n  \r\n// Последовательный перебор всех тегов anchor \r\nfor ( var i=0; i < anchors.length; i++ ) { \r\n    var anchor = anchors[i]; \r\n  \r\n    // Проверка на принадлежность ссылки к \"lightbox\" \r\n    if ( anchor.href && anchor.rel == \"lightbox\" ) { \r\n  \r\n","\r\n 184\r\n       // Обеспечение отображения Lightbox по щелчку \r\n       anchor.onclick = function () { \r\n           showLightbox(this); \r\n           return false; \r\n       }; \r\n    } \r\n}  \r\nПод влиянием отзывов новых пользователей Lightbox постепенно развивалась, в нее добавлялись новые \r\nсвойства, к примеру, переходы с помощью клавиатуры и анимационные эффекты. Тем не менее в своем самом \r\nпростом варианте, Lightbox вдохновляет на создание вашей собственной подобное галереи изображений. \r\nThickBox \r\nВторая галерея изображений, которую мне захотелось вам показать — это ThickBox, созданная Коди \r\nЛиндли (Cody Lindley), в которой используется JavaScript-библиотека jQuery. Эта реализация очень похожа на \r\nLightbox, но значительно меньше по размерам и поддерживает с использованием Ajax загрузку внешних HTML-\r\nфайлов. Дополнительные сведения об этой библиотеке могут быть найдены на его веб-сайте \r\n(http://codylindley.com/Javascript/257/thickbox-one-box-to-rule-them-all), могут быть найдены и примеры, \r\nдемонстрирующее ее в действии (http:// jquery.com/demo/thickbox/). \r\nКак видно на копии экрана (см. рис. 9.2), результат отображения картинок с помощью ThickBox очень \r\nпохож на результаты работы Lightbox. Как и в Lightbox, в ThickBox используются ненавязчивые средства ее \r\nзагрузки и выполнения. После простого включения сценария в заголовок страницы, он пройдет по всей DOM-\r\nструктуре и отыщет все ссылки, имеющие класс thickbox, подобные показанной в следующем коде: \r\n<a href=\"ajaxLogin.htm?height=100&width=250\" class=\"thickbox\">ThickBox login</a>  \r\n","\r\n 185\r\n \r\nРис. 9.2. ThickBox отображает отдельное изображение поверх всей остальной страницы \r\nВ листинге 9.2 показан код, который ThickBox использует для динамического и ненавязчивого применения \r\nсвоих функциональных возможностей, как только DOM будет готов к работе (что произойдет до того, как будут \r\nзагружены все имеющиеся на странице изображения, создавая у пользователей более благоприятное \r\nвпечатление). \r\nЛистинг 9.2. Применение функциональных возможностей ко всем элементам anchor, имеющим класс \r\n“thickbox” \r\n// Обнаружение всех элементов thickbox, когда DOM будет готов к работе \r\n$(document).ready(function(){ \r\n  \r\n    // добавление thickbox к элементам href, имеющим класс .thickbox \r\n    $(\"a.thickbox\").click(function(){ \r\n       // Определение надписи для thickbox \r\n       var t = this.title || this.name || this.href || null; \r\n  \r\n       // Отображение thickbox \r\n       TB_show(t,this.href); \r\n  \r\n       // Удаление фокуса со ссылки \r\n       this.blur(); \r\n  \r\n       // Обеспечение блокировки обычной работы ссылки \r\n","\r\n 186\r\n       return false; \r\n    }); \r\n});  \r\nБлагодаря количеству дополнительных возможностей, включенных в ThickBox, а также более компактному \r\nкоду, эта библиотека несомненно предпочтительнее Lightbox. \r\nДалее мы собираемся рассмотреть, как создать свой собственный клон галереи, с учетом всех \r\nхитросплетений, необходимых для того, чтобы выполнить эту работу вполне корректно. \r\nСоздание галереи \r\nПервым шагом к созданию галереи изображений должен стать набор изображений, по которым можно \r\nбудет осуществлять переходы. Я собираюсь выдвинуть предположение, что на странице может быть любое \r\nколичество галерей, и в каждой галерее может быть любое количество изображений. Кроме этого очень важно, \r\nчтобы перед любым применением вашего JavaScript, изображения были отображены в понятной и семантически \r\nнепротиворечивой манере. Это поможет обеспечить пользователям, имеющим выключенный JavaScript (или \r\nимеющим ущербную поддержку CSS) получать тем не менее вполне приемлемое впечатление от страницы. \r\nОсновной HTML-код, который мы собираемся использовать для нашей галереи, показан в листинге 9.3. \r\nЛистинг 9.3. Основной HTML-код страницы, содержащей нашу галерею изображений \r\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \r\n    \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> \r\n<html> \r\n<head> \r\n    <title>Произвольные изображения кошек</title> \r\n</head> \r\n<body> \r\n    <h1>Произвольные изображения кошек</h1> \r\n  \r\n    <p>Lorem ipsum dolor . . . </p> \r\n  \r\n    <!-- \r\n       Наша галерея, которая должна содержать <ul>, class которого \r\n       равен \"gallery\", а title связан с этой галереей. \r\n    ---> \r\n    <ul class=\"gallery\" title=\"Произвольные изображения кошек\"> \r\n  \r\n       <!-- \r\n           Каждое изображение галереи должно быть заключено в элементы \r\n           <li>, и иметь ссылку, указывающую на текущее место изображения. \r\n           Если изображение большое, в него к тому же нужно включить class \r\n           \"tall\". \r\n       --> \r\n  \r\n       <li><a href=\"image1.jpg\"><img src=\"image1.jpg\" \r\n           alt=\"Спящий жирный кот \"/></a></li> \r\n       <li><a href=\"image2.jpg\"><img src=\"image2.jpg\" \r\n           alt=\"На одной кровати\"/></a></li> \r\n","\r\n 187\r\n       <li class=\"tall\"><a href=\"image3.jpg\"><img src=\"image3.jpg\" \r\n           alt=\"За окошком \"/></a></li> \r\n       <li class=\"tall\"><a href=\"image4.jpg\"><img src=\"image4.jpg\" \r\n           alt=\"На солнышке\"/></a></li> \r\n       <li><a href=\"image5.jpg\"><img src=\"image5.jpg\" \r\n           alt=\"Удобно устроился\"/></a></li> \r\n  \r\n    </ul> \r\n  \r\n    <p>Lorem ipsum dolor . . . </p> \r\n</body> \r\n</html>  \r\nЗатем нужно применить к изображениям дополнительное стилевое оформление, чтобы получить более \r\nприглядный вид и более наглядное перемещение. Соответствующий код CSS показан в листинге 9.4 9-4. \r\nЛистинг 9.4. CSS для соответствующего стилевого оформления страницы \r\nbody { \r\n    font-family: Arial; \r\n    font-siz: 14px; \r\n} \r\n  \r\n/* Включает красивое обрамление вокруг галереи изображений. */ \r\nul.gallery { \r\n    list-style: none; \r\n    padding: 5px; \r\n    background: #EEE; \r\n    overflow: auto; \r\n    border: 1px solid #AAA; \r\n    margin-top: 0px; \r\n} \r\n  \r\n/* Создает вокруг каждого изображения прямоугольник стандартной ширины и высоты. */ \r\nul.gallery li { \r\n    float: left; \r\n    margin: 6px; \r\n    width: 110px; \r\n    height: 110px; \r\n    background: #FFF; \r\n    border: 2px solid #AAA; \r\n} \r\n  \r\n/* Изображения горизонтального формата шириной 100px */ \r\nul.gallery img { \r\n    width: 100px; \r\n    margin: 5px; \r\n    border: 0px; \r\n    margin-top: 17px; \r\n","\r\n 188\r\n} \r\n  \r\n/* Изображения вертикального формата высотой 100px */ \r\nul.gallery li.tall img { \r\n    height: 100px; \r\n    width: auto; \r\n    margin-top: 5px; \r\n    margin-left: 17px; \r\n}  \r\nПолучившийся результат работы базового HTML и CSS показан на рис. 9.3. Теперь, после установки на \r\nстранице базового HTML, мы готовы приступить к сведению воедино компонентов, необходимых для создания \r\nкрасивой, приводимой в действие кодом JavaScript галереи изображений. \r\n \r\nРис. 9.3. Веб-страница, содержащая изображения с простым стилевым оформлением \r\nНенавязчивая загрузка \r\nОдной из сторон, которой согласно нашим требованиям должна обладать галерея изображений, должна \r\nбыть ненавязчивая работа сценария. Нам не хотелось бы заставлять пользователей сценария включать какой-\r\nнибудь лишний (и не отвечающей семантике) HTML на их веб-страницы, только ради того, чтобы придать им \r\n","\r\n 189\r\nболее приглядный вид. Поэтому мы собираемся начать со вставки некоторого количества HTML-элементов в DOM \r\nвеб-страницы, как только закончится ее загрузка. Соответствующий код показан в листинге 9.5. \r\nЛистинг 9.5. Вставка исходного HTML в DOM и привязка всех необходимых обработчиков событий к \r\nкаждому элементу \r\n// Отслеживания изображения, которое рассматривается в данный момент \r\nvar curImage = null; \r\n  \r\n// Ожидание окончания загрузки страницы перед тем, как вносить \r\n// изменения или перемещаться по DOM \r\nwindow.onload = function() { \r\n    /* \r\n     * создание следующей DOM-структуры: \r\n     * <div id=\"overlay\"></div> \r\n     * <div id=\"gallery\"> \r\n     * <div id=\"gallery_image\"></div> \r\n     * <div id=\"gallery_prev\"><a href=\"\">&laquo; Предыдущее</a></div> \r\n     * <div id=\"gallery_next\"><a href=\"\">Следующее &raquo;</a></div> \r\n     * <div id=\"gallery_title\"></div> \r\n     * </div> \r\n     */ \r\n  \r\n    // Создание контейнера для всей галереи \r\n    var gallery = document.createElement(\"div\"); \r\n    gallery.id = \"gallery\"; \r\n  \r\n    // И добавление в него всех управляющих контейнеров div \r\n    gallery.innerHTML = '<div id=\"gallery_image\"></div>' + \r\n       '<div id=\"gallery_prev\"><a href=\"\">&laquo; Предыдущее</a></div>' + \r\n       '<div id=\"gallery_next\"><a href=\"\">Следующее &raquo;</a></div>' + \r\n       '<div id=\"gallery_title\"></div>'; \r\n    \r\n    // Добавление gallery в DOM \r\n    document.body.appendChild( gallery ); \r\n  \r\n    // Поддержка обработки каждой ссылки Следующее и Предыдущее \r\n    // на которых был щелчок в пределах галереи \r\n    id(\"gallery_next\").onclick = nextImage; \r\n    id(\"gallery_prev\").onclick = prevImage; \r\n  \r\n    // Обнаружение всех галерей на странице \r\n    var g = byClass( \"gallery\", \"ul\" ); \r\n  \r\n    // Последовательные перебор всех галерей \r\n    for ( var i = 0; i < g.length; i++ ) { \r\n       // и обнаружение всех ссылок на демонстрируемые изображения \r\n       var link = tag( \"a\", g[i] ); \r\n  \r\n","\r\n 190\r\n       // Последовательный перебор ссылок на изображения \r\n       for ( var j = 0; j < link.length; j++ ) { \r\n           // Обеспечение, чтобы по щелчку на ссылке вместо перехода \r\n           // к изображению осуществлялась демонстрация галереи \r\n           // изображений \r\n           link[j].onclick = function(){ \r\n               // Отображение серого фона \r\n               showOverlay(); \r\n  \r\n               // Отображение изображения в галерее \r\n               showImage( this.parentNode ); \r\n    \r\n               // Блокировка обычных действий браузера по переходу на \r\n               // изображение \r\n               return false; \r\n           }; \r\n       } \r\n       // Добавление к галерее средств перехода в режиме демонстрации \r\n       // изображений \r\n       addSlideShow( g[i] ); \r\n    } \r\n};  \r\nПозаботившись об этом важном шаге, вы можете приступать к созданию различных компонентов самой \r\nгалереи. \r\nНаложение затемнения \r\nСначала мы собираемся создать наложение затемнения, которое используется как Lightbox, так и в \r\nThickBox. Мы собираемся убедиться в том, что по большей части эта довольно легкая задача, имеющая только \r\nодин сложный аспект: налагаемое затемнения должно соответствовать высоте и ширине текущей страницы. Но \r\nдля нас все сложилось удачно, ведь в главе 7 мы уже разрабатывали необходимые для этого функции: \r\npageWidth() и pageHeight(). \r\nНачнем с создания простого div-элемента, имеющего атрибут ID (чтобы позже можно было получить к нему \r\nдоступ) и добавления его к DOM. Все это показано в листинге 9.6. \r\nЛистинг 9.6. Создание простого div-элемента и добавление его к DOM \r\n// Создание полупрозрачного затемнения \r\nvar overlay = document.createElement(\"div\"); \r\noverlay.id = \"overlay\"; \r\n  \r\n// Обеспечение скрытия фона и галереи по щелчку на сером фоне \r\noverlay.onclick = hideOverlay; \r\n  \r\n// Добавление затемнения к DOM \r\ndocument.body.appendChild( overlay ); \r\n  \r\n","\r\n 191\r\nДалее нужно создать две функции, необходимые для скрытия и проявления затемнения. Именно здесь и \r\nвозникают сложности. Сам процесс скрытия и проявления сравнительно прост, но определение правильной \r\nширины и высоты затемнения —дело непростое. В обычной ситуации было бы достаточно определить размеры \r\nвысоты и ширины в 100%, но этот подход неприемлем, поскольку пользователь мог для отображения галереи \r\nпрокрутить страницу вниз (и сдвинуть затемнение). Это можно исправить, если сделать высоту и ширину \r\nзатемнения как и у всей страницы. Чтобы определить нужные параметры, можно воспользоваться функциями \r\npageHeight() и pageWidth(), разработанными в главе 7. \r\nПолный код для скрытия и проявления затемнения показан в листинге 9.7. \r\nЛистинг 9.7. Две функции, необходимые для скрытия и проявления затемнения, используемого в галерее \r\nизображений \r\n// Скрытие затемнения и текущей галереи \r\nfunction hideOverlay() { \r\n    // Обеспечение перезапуска значения текущего изображения \r\n    curImage = null; \r\n  \r\n    // и скрытия затемнения и галереи \r\n    hide( id(\"overlay\") ); \r\n    hide( id(\"gallery\") ); \r\n} \r\n  \r\n// Проявление затемнения \r\nfunction showOverlay() { \r\n    // Обнаружение затемнения \r\n    var over = id(\"overlay\"); \r\n  \r\n    // Установка его размеров по высоте и ширине текущей страницы \r\n    // (что будет полезным при использовании прокрутки) \r\n    over.style.height = pageHeight() + \"px\"; \r\n    over.style.width = pageWidth() + \"px\"; \r\n  \r\n    // и проявление \r\n    fadeIn( over, 50, 10 ); \r\n}  \r\nИ наконец, давайте присовокупим к этому CSS, необходимый для правильного отображения затемнения. \r\nСоответствующий код показан в листинге 9.8. \r\nЛистинг 9.8. Код CSS, необходимый для правильного отображения затемнения \r\n#overlay { \r\n    background: #000; \r\n    opacity: 0.5; \r\n    display: none; \r\n    position: absolute; \r\n    top: 0px; \r\n    left: 0px; \r\n    width: 100%; \r\n","\r\n 192\r\n    height: 100%; \r\n    z-index: 100; \r\n    cursor: pointer; \r\n    cursor: hand; \r\n}  \r\nСобранные воедино, встраиваемый HTML и CSS приведут к внешнему виду страницы, показанному на \r\nрис. 9.4. \r\n \r\nРис. 9.4. Результат отображения затемнения, наложенного поверх страницы \r\nСоздав затемнение, и вставив его в страницу, вы будете готовы приступить к отображению изображения \r\nповерх этого затемнения. \r\nПозиционируемый контейнер \r\nНам нужно создать компонент галереи изображений, который станет контейнером, всплывающим над \r\nзатемнением и содержащим текущее изображение. К сожалению, из-за недостаточной поддержки CSS 2 в \r\nнекоторых современных браузерах, реализация этого шага представляет определенные трудности. При должной \r\nподдержке CSS, изображение просто будет иметь фиксированную позицию (создавая тем самым иллюзию \r\nпозиционирования поверх всего остального, независимо от текущей позиции прокрученной страницы). \r\nНачнем с предположения, что у нас на странице уже есть DOM-структура вроде той, что показана в \r\nлистинге 9.9 (и что вы ее уже добавили к той странице, что была показана в листинге 9.5). \r\nЛистинг 9.9. HTML для отображения позиционированной галереи изображений поверх затемнения \r\n","\r\n 193\r\n<div id=\"gallery\"> \r\n    <div id=\"gallery_image\"></div> \r\n    <div id=\"gallery_prev\"><a href=\"\">&laquo; Предыдущее</a></div> \r\n    <div id=\"gallery_next\"><a href=\"\">Следующее &raquo;</a></div> \r\n    <div id=\"gallery_title\"></div> \r\n</div>  \r\nОбладая основной HTML-структурой, нужно создать соответствующую функцию для проявления div-\r\nконтейнера галереи и добавления к нему изображения. Существует несколько способов запуска такой функции, \r\nно наиболее очевидным будет запуск при щелчке пользователя на одном из изображений вашей галереи \r\n(показанном на основной HTML-странице), после которого поверх всего остального проявляется его увеличенная \r\nверсия. Функция, осуществляющая такое отображение, показана в листинге 9.10. \r\nЛистинг 9.10. Показ галереи на основе выбранного изображения \r\n// Отображение текущей галереи изображений \r\nfunction showImage(cur) { \r\n    // Запоминание текущего рабочего изображения \r\n    curImage = cur; \r\n  \r\n    // Обнаружение изображения галереи \r\n    var img = id(\"gallery_image\"); \r\n  \r\n    // Удаление изображения, если таковое уже было отображено \r\n    if ( img.firstChild ) \r\n       img.removeChild( img.firstChild ); \r\n  \r\n    // и добавление вместо него нового изображения \r\n    img.appendChild( cur.firstChild.cloneNode( true ) ); \r\n  \r\n    // Установка надписи изображения галереи в качестве содержимого \r\n    // аргумента 'alt' обычного изображения \r\n    id(\"gallery_title\").innerHTML = cur.firstChild.firstChild.alt; \r\n  \r\n    // Обнаружение основной галереи \r\n    var gallery = id(\"gallery\"); \r\n  \r\n    // Установка правильного класса (чтобы был получен правильный размер) \r\n    gallery.className = cur.className; \r\n  \r\n    // Постепенное проявление \r\n    fadeIn( gallery, 100, 10 ); \r\n  \r\n    // Обеспечение позиционирования галереи в правильном месте \r\n    // экрана \r\n    adjust(); \r\n}  \r\nПоследним шагом в функции showImage вызывается функция adjust. Эта функция отвечает за \r\nперепозиционирование галереи изображений на точный центр пользовательского окна (даже если пользователь \r\n","\r\n 194\r\nосуществил прокрутку или изменил размеры окна). Этот важный шаг, который позволяет галереи выглядеть и \r\nвести себя вполне естественно, показан в листинге 9.11. \r\nЛистинг 9.11. Перепозиционирование галереи на основе высоты и ширины изображения, и того места, до \r\nкоторого была осуществлена пользовательская прокрутка \r\n// Перепозиционирование галереи по центру видимой части страницы \r\n// даже после ее прокрутки \r\nfunction adjust(){ \r\n    // Обнаружение галереи Locate the gallery \r\n    var obj = id(\"gallery\"); \r\n  \r\n    // Определение существования галереи \r\n    if ( !obj ) return; \r\n  \r\n    // Определение ее текущей высоты и ширины \r\n    var w = getWidth( obj ); \r\n    var h = getHeight( obj ); \r\n  \r\n    // Вертикальное позиционирование контейнера по средине окна \r\n  \r\n    var t = scrollY() + ( windowHeight() / 2 ) - ( h / 2 ); \r\n  \r\n    // Но не выше верхней части страницы \r\n    if ( t < 0 ) t = 0; \r\n  \r\n    // Горизонтальное позиционирование контейнера по средине окна \r\n    var l = scrollX() + ( windowWidth() / 2 ) - ( w / 2 ); \r\n  \r\n    // Но не левее, чем левый край страницы \r\n    if ( l < 0 ) l = 0; \r\n  \r\n    // Установка выверенной позиции элемента \r\n    setY( obj, t ); \r\n    setX( obj, l ); \r\n}; \r\n  \r\n// Корректировка позиции галереи после каждого применения прокрутки страницы \r\n// или изменения размеров окна браузера \r\nwindow.onresize = document.onscroll = adjust;  \r\n  \r\nИ наконец, в листинге 9.12 показан код CSS, необходимый для сохранения правильного \r\nпозиционирования галереи. Можно заметить, что на самом деле это ничто иное, как абсолютно \r\nспозиционированный div-контейнер с большим показателем стилевого свойства z-index, позволяющим поместить \r\nего поверх всего остального, что есть на странице. \r\nЛистинг 9.12. Код CSS для правильного позиционирования галереи \r\n","\r\n 195\r\n#gallery { \r\n    position: absolute; \r\n    width: 650px; \r\n    height: 510px; \r\n    background: #FFF; \r\n    z-index: 110; \r\n    display: none; \r\n} \r\n  \r\n#gallery_title { \r\n    position: absolute; \r\n    bottom: 5px; \r\n    left: 5px; \r\n    width: 100%; \r\n    font-size: 16px; \r\n    text-align: center; \r\n} \r\n  \r\n#gallery img { \r\n    position: absolute; \r\n    top: 5px; \r\n    left: 5px; \r\n    width: 640px; \r\n    height: 480px; \r\n    border: 0px; \r\n    z-index: 115; \r\n} \r\n  \r\n#gallery.tall { \r\n    width: 430px; \r\n    height: 590px; \r\n} \r\n  \r\n#gallery.tall img { \r\n    width: 420px; \r\n    height: 560px; \r\n}  \r\nТеперь, добившись совместной работы CSS, HTML и JavaScript, мы получили позиционированную галерею \r\nизображений, которая, судя по рис. 9.5, выглядит довольно неплохо. \r\n","\r\n 196\r\n \r\nРис. 9.5. Позиционированная галерея изображений, помещенная поверх затемнения \r\nПосле того как важный шаг по созданию красивой галереи изображений уже позади, нужно сосредоточить \r\nусилия на облегчении пользователю переходов по различным изображением галереи. \r\nПереходы \r\nКогда изображение отображено поверх всей остальной страницы (а между ним и страницей наложено \r\nзатемнение), ко всему этому нужно добавить лучшие средства для осуществления переходов между различными \r\nизображениями галереи. Чуть раньше, когда мы задавали HTML для затемнения галереи, туда были включены \r\nссылки, которые можно было использовать для осуществления переходов. Эти ссылки позволяют пользователю \r\nперемещаться по галерее взад-вперед, сохраняя затемнение. \r\nОтслеживая, какое именно изображение просматривается в данный момент, вы можете добавить это \r\nфункциональное свойства к своей галерее (в данном случае ссылка на изображение хранится в переменной \r\ncurImage). Оперируя этими сведениями, можно легко определить, в какое изображение галереи просматривается, \r\nи осуществить перемещение в нужном пользователю направлении (см. листинг 9.13). \r\nЛистинг 9.13. Две функции, необходимые для того, чтобы направить пользователей на желаемую ими \r\nпозицию в галерее \r\n// Обнаружение и отображение предыдущего изображения \r\nfunction prevImage() { \r\n","\r\n 197\r\n    // Определение местоположения и демонстрация предыдущего изображения \r\n    // галереи \r\n    showImage( prev( curImage ) ); \r\n  \r\n    // Блокировка обычных действий ссылки \r\n    return false; \r\n} \r\n  \r\n// Обнаружение и отображение следующего изображения \r\nfunction nextImage() { \r\n    // Определение местоположения и демонстрация следующего изображения \r\n    // галереи \r\n    showImage( next( curImage ) ); \r\n  \r\n    // Блокировка обычных действий ссылки \r\n    return false; \r\n}  \r\nОсобенность ссылок перемещений состоит в том, что нужно определить, когда именно уместно вывести их \r\nотображение. Нужно обеспечить, чтобы ссылки показывались только тогда, когда в галерее до и после текущего \r\nизображения есть изображения, на которые можно перейти. Контекстуальное скрытие или появление ссылок в \r\nгалерее изображений будет использовано из функции showImage() для отображения этих ссылок там, где это \r\nуместно. Код, управляющий состоянием средств управления переходами показан в листинге 9.14. \r\nЛистинг 9.14. Определение, когда должны быть показаны или скрыты ссылки перехода Следующее и \r\nПредыдущее \r\n// Скрытие ссылки Следующее, если мы дошли до конца показа \r\nif ( !next(cur) ) \r\n    hide( id(\"gallery_next\") ); \r\n  \r\n// Если нет, обеспечение ее показа \r\nelse \r\n    show( id(\"gallery_next\") ); \r\n  \r\n// Скрытие ссылки Предыдущее, если мы дошли до начала показа \r\nif ( !prev(cur) ) \r\n    hide( id(\"gallery_prev\") ); \r\n  \r\n// Если нет, обеспечение ее показа \r\nelse \r\n    show( id(\"gallery_prev\") );  \r\n  \r\nИ наконец, в листинге 9.15 показан код CSS, необходимый для правильного позиционирования ссылок \r\nперехода. \r\nЛистинг 9.15. Код CSS, необходимый для позиционирования ссылок перехода \r\n#gallery_prev, #gallery_next { \r\n","\r\n 198\r\n    position: absolute; \r\n    bottom: 0px; \r\n    right: 0px; \r\n    z-index: 120; \r\n    width: 60px; \r\n    text-align: center; \r\n    font-size: 12px; \r\n    padding: 4px; \r\n} \r\n  \r\n#gallery_prev { \r\n    left: 0px; \r\n} \r\n  \r\n#gallery_prev a, #gallery_next a { \r\n    color: #000; \r\n    text-decoration: none; \r\n}  \r\nНа рис. 9.5 показан пример использования ссылок перехода. Обратите внимание, что в нижней части \r\nгалереи изображений показана ссылка, направляющая пользователя на просмотр следующего изображения \r\nгалереи. Ссылка показывается и скрывается в соответствии с тем, в каком месте галереи находится \r\nпросматриваемое пользователем изображение. \r\nДемонстрация изображений \r\nФинальная часть создания галереи изображений придаст ей черты привлекательности, которые могут \r\nобрадовать многих пользователей: динамическая, изящная демонстрация всех изображений галереи. По \r\nсравнению с предыдущей работой по созданию переходов по изображениями, это дополнение не потребует \r\nособых усилий. Все очень просто. Процесс создания демонстрационного режима разбивается на два шага: \r\n• Создание в документе дополнительной ссылки, по щелчку на которой пользователь мог бы запустить \r\nдемонстрацию. \r\n• Создание демонстрационного процесса как такового (управляющего тем, какие изображения показывать, \r\nи как переключаться между ними). \r\nПервый шаг показан в листинге 9.16. \r\nЛистинг 9.16. Добавление к DOM дополнительного навигационного элемента для запуска демонстрации \r\nизображений \r\nfunction addSlideshow( elem ) { \r\n    // Мы собираемся создать некоторую дополнительную контекстную \r\n    // информацию, сопровождающую демонстрацию \r\n  \r\n    // создание заголовка демонстрации и его контейнера \r\n    var div = document.createElement(\"div\"); \r\n    div.className = \"slideshow\"; \r\n  \r\n","\r\n 199\r\n    // Отображение имени демонстрации на основе названия галереи \r\n    var span = document.createElement(\"span\"); \r\n    span.innerHTML = g[i].title; \r\n    div.appendChild( span ); \r\n  \r\n    // Создание ссылки, позволяющей увидеть демонстрацию всех \r\n    // изображений галереи \r\n    var a = document.createElement(\"a\"); \r\n    a.href = \"\"; \r\n    a.innerHTML = \"&raquo; Просмотреть демонстрацию изображений\"; \r\n  \r\n    // Обеспечение запуска демонстрации по щелчку на ссылке \r\n    a.onclick = function(){ \r\n       startShow( this.parentNode.nextSibling ); \r\n       return false; \r\n    }; \r\n    \r\n    // Добавление нового управляющего элемента и заголовка к странице \r\n    div.appendChild( a ); \r\n    elem.parentNode.insertBefore( div, elem ); \r\n}  \r\nА теперь настало время создать средство управления всей серией демонстрационной анимации. Все \r\nуправление построено на серии временных задержек, инициализация которых происходит одновременно \r\n(поскольку они настроены так, что их сроки истекают с разносом по времени). Конечный результат выражается в \r\nплавной, изящной демонстрации, создающей весьма цельное представление. Код, запускающий демонстрацию, \r\nпоказан на рис. 9.17. \r\nЛистинг 9.17. Код, запускающий демонстрацию конкретной галереи \r\n// Запуск демонстрации всех изображений, находящихся в конкретной галерее \r\nfunction startShow(obj) { \r\n    // Определение местонахождения всех отдельных изображений галереи \r\n    var elem = tag( \"li\", obj ); \r\n  \r\n    // Определение местонахождения всей демонстрируемой галереи \r\n    var gallery = id(\"gallery\"); \r\n    \r\n    // Последовательный перебор всех, принадлежащих галереи изображений \r\n    for ( var i = 0; i < elem.length; i++ ) new function() { \r\n       // Запоминание, на какой текущий элемент была ссылка \r\n       var cur = elem[i]; \r\n  \r\n       // Мы собираемся показывать новое изображение каждые 5 секунд \r\n       setTimeout(function(){ \r\n           // Отображение отдельного изображения \r\n           showImage( cur ); \r\n  \r\n           // И начала его растворения после 3,5 секунд \r\n","\r\n 200\r\n           // (со временем растворения в 1 секунду) \r\n           setTimeout(function(){ \r\n               fadeOut( gallery, 0, 10 ); \r\n           }, 3500 ); \r\n       }, i * 5000 ); \r\n    }; \r\n  \r\n    // А затем скрытие затемнения, когда все закончится \r\n    setTimeout( hideOverlay, 5000 * elem.length ); \r\n  \r\n    // Но появление затемнения при запуске демонстрации \r\n    showOverlay(); \r\n}  \r\nВ завершение нужно не забыть добавить код CSS для ссылки на запуск демонстрации. Соответствующий \r\nкод показан в листинге 9.18. \r\nЛистинг 9.18. Дополнительный код CSS для отображения ссылки на запуск демонстрации \r\ndiv.slideshow { \r\n    text-align: right; \r\n    padding: 4px; \r\n    margin-top: 10px; \r\n    position: relative; \r\n} \r\n  \r\ndiv.slideshow span { \r\n    position: absolute; \r\n    bottom: 3px; \r\n    left: 0px; \r\n    font-size: 18px; \r\n    font-weight: bold; \r\n} \r\n  \r\ndiv.slideshow a { \r\n    color: #000; \r\n}  \r\nИзготовить копию экрана, показывающую демонстрацию в действии очень сложно, но на рис. 9.6 можно \r\nкак минимум посмотреть на ссылку запуска, добавленную на страницу. \r\nПредставленные ранее демонстрация и переходы по изображениям послужили реальным началом показа \r\nвозможностей по созданию своих собственных динамических веб-приложений (к примеру, части \r\nпрезентационного программного обеспечения). Чтобы получить более четкое представление о том, как работает \r\nдемонстрация изображений, я рекомендую вам установить кол, представленный в этой главе, и посмотреть на \r\nпростые, но убедительные результаты его работы. \r\n","\r\n 201\r\n \r\nРис. 9.6. Дополнительная ссылка на запуск демонстрации, добавленная на страницу \r\nВывод \r\nГалерея изображений, переходы по изображениям и их автоматическая демонстрация, представленные в \r\nэтой главе, реально показывают пользу от применения DOM-сценариев для создания дополнительных \r\nфункциональных возможностей на веб-станице, не создающих каких-либо существенных трудностей или \r\nнеразберихи. Опираясь на все ранее изученное, можно прийти к очевидному выводу, что для динамического, \r\nненавязчивого применения DOM-сценариев нет практически ничего невозможного. \r\nВ этой главе были рассмотрены две другие галереи изображений, вдохновившие нас на создание своего \r\nсобственного экземпляра. Затем мы определили для галереи стандартный HTML-синтаксис и порядок ее \r\nотображения, а также набор ее основных комплектующих (включая затемнение, позиционируемый контейнер и \r\nпереходы по изображениям). В качестве заключительного аккорда, мы добавили запускаемую пользователем \r\nавтоматическую демонстрацию изображений. Таким образом без лишней суеты и с минимальным объемом кода мы \r\nсоздали мощный фрагмент динамического сценария, использующего объектную модель документа. \r\n  \r\nГлава 10 Введение в Ajax \r\n","\r\n 202\r\nAjax — это термин, придуманный Джесси Джеймсом Гарретом (Jesse James Garrett) из компании Adaptive \r\nPath для объяснения асинхронной связи между клиентом и сервером, открывающей возможности использования \r\nобъекта XMLHttpRequest, предоставляемого всеми современными браузерами. Ajax — это всего лишь термин, \r\nозначающий Asynchronous JavaScript и XML, который используется для краткого изложения технологии, \r\nнеобходимой для создания динамического веб-приложения. Кроме того, отдельные компоненты технологии Ajax \r\nявляются полностью взаимозаменяемыми — вполне приемлемо, к примеру, вместо XML использовать HTML. \r\nВ этой главе мы собираемся рассмотреть детали формирования полноценного Ajax-процесса (который \r\nконцентрируется на осуществлении запроса от браузера к серверу). Будет рассмотрено все, от физического \r\nзапроса как такового, до JavaScript-взаимодействия и работы с данными, необходимой для выполнения всей \r\nработы. Сюда включаются: \r\n• Исследование различных типов HTTP-запросов и определение, как наилучшим образом отправить объекты \r\nданных на сервер. \r\n• Рассмотрение всего http-ответа и попытка обработки всех ошибок, которые могут с ним произойти, \r\nвключая истечение времени отклика сервера. \r\n• Чтение данных, присланных сервером в ответ, перемещение по ним и их обработка. \r\nПолностью разобравшись с тем, как осуществляется Ajax-процесс и как он может быть реализован, вы \r\nпоймете, как он может быть использован во всем, от типичных ситуаций, до полноценных приложений. В \r\nглавах 11, 12 и 13, мы также будем рассматривать ряд случаев использования Ajax-технологий. \r\nИспользование Ajax \r\nДля создания простой Ajax-реализации не требуется большого объема кода, но ее предоставляемые ею \r\nвозможности впечатляют. К примеру, вместо того, чтобы заставлять пользователя после отправки формы целиком \r\nзапрашивать всю страницу, процесс отправки может быть обработан асинхронно, и после его завершения будет \r\nотображена только небольшая часть страницы с желаемыми результатами. Например, процесс поиска доступных \r\nдоменных имен (с целью их приобретения) может быть медленным и трудоемким. Как только вам захочется найти \r\nновое имя , нужно набирать запрос в форме, отправлять его, и наблюдать за перезагрузкой страницы. С \r\nиспользованием Ajax можно получить мгновенный результат, такой, как, к примеру, предоставляет веб-\r\nприложение Instant Domain Search (http:// instantdomainsearch.com/), показанное на рис. 10.1. \r\n \r\nРис. 10.1. Пример использования Instant Domain Search для поиска доменных имен по мере набора текста \r\nHTTP-запросы \r\n","\r\n 203\r\nПожалуй наиболее важным и, наверное, самым совместимым аспектом Ajax является та часть процесса, \r\nкоторая относится к HTTP-запросу. Hypertext Transfer Protocol (HTTP) был разработан для простой передачи HTML-\r\nдокументов и однородных файлов. К счастью все современные браузеры поддерживают средства для \r\nдинамической установки HTTP-соединения с использованием JavaScript. Как показала практика, эти средства \r\nочень полезны для разработки более «отзывчивых» веб-приложений. \r\nАсинхронная отправка данных на сервер и получение в ответ дополнительных данных является основным \r\nназначением Ajax. Как именно отформатированы данные в конечном счете зависит от определенных вами \r\nтребований, которые будут рассмотрены разделе «Обработка данных ответа». \r\nВ следующих разделах мы собираемся посмотреть, как форматировать данные, передаваемые на сервер с \r\nиспользованием HTTP-запросов. Затем мы собираемся рассмотреть, как устанавливаются основные соединения с \r\nсервером, и посмотреть на подробности их реализации в кроссбраузерной среде. \r\nУстановка соединения \r\nПервоначальным аспектом Ajax-процесса является открытие соединения с сервером. Чтобы этого добиться \r\nсуществует несколько различных способов, но мы рассмотрим специфические средства, с помощью которых \r\nможно легко не только послать, но и получить данные. Эта технология обычно называется «использование \r\nобъекта XMLHttpRequest». \r\nВ зависимости от пользовательского браузера передача данных производится двумя различными \r\nспособами применения объекта XMLHttpRequest: \r\n• Internet Explorer, которые впервые проложил путь этому средству браузерной передачи данных, \r\nустанавливает все свои соединения с помощью ActiveXObject (конкретная версия которого изменяется в \r\nзависимости от версии Internet Explorer). К счастью, Internet Explorer 7 обладает собственной поддержкой \r\nобъекта XMLHttpRequest. \r\n• Все остальные современные браузеры локализовали все возможности XMLHttpRequest в объекте под \r\nтем же названием. К их числу относятся Firefox, Opera и Safari. \r\nХорошо, что несмотря на отличия существующего в Internet Explorer метода создания объекта \r\nXMLHttpRequest от метода, используемого во всех остальных современных браузерах, у этого объекта такой же \r\nнабор полезных функциональных свойств. Объект XMLHttpRequest обладает рядом методов, используемых для \r\nустановки соединения и чтения данных с сервера. В листинге 10.1 показано, как послать на сервер основной GET-\r\nзапрос. \r\nЛистинг 10.1. Кроссбраузерное средство создания HTTP GET-запроса на сервер \r\n// Если используется IE, создание для объекта XMLHttpRequest программного \r\n// обрамления \r\nif ( typeof XMLHttpRequest == \"undefined\" ) \r\n    XMLHttpRequest = function(){ \r\n       // В Internet Explorer для создания нового объекта XMLHttpRequest \r\n       // используется ActiveXObject \r\n       return new ActiveXObject( \r\n           // IE 5 использует XMLHTTP объект, отличающийся от объекта, \r\n           // используемого в IE 6 \r\n           navigator.userAgent.indexOf(\"MSIE 5\") >= 0 ? \r\n           \"Microsoft.XMLHTTP\" : \"Msxml2.XMLHTTP\" \r\n","\r\n 204\r\n       ); \r\n    }; \r\n// Создание объекта запроса \r\nvar xml = new XMLHttpRequest(); \r\n  \r\n// Открытие сокета \r\nxml.open(\"GET\", \"/some/url.cgi\", true); \r\n  \r\n// Установка соединения с сервером и отправка любых дополнительных \r\n// данных \r\nxml.send(); \r\nКак видите, код, необходимый для установки соединения с сервером, совсем простой, и его создание не \r\nтребует практически никаких усилий. Сложности возникают, когда дело доходит до дополнительных \r\nвозможностей (например, до проверки истечения срока запроса или измененных данных); но эти детали мы \r\nрассмотрим в разделе «HTTP ответ». \r\nСамая важная особенность всей методологии Ajax состоит в передаче данных от клиента (например, веб-\r\nбраузера) к серверу. С учетом этого давайте рассмотрим детали, необходимые для упаковки данных и отправки \r\nих на сервер. \r\nПреобразование данных в последовательную форму \r\nПервой стадией отправки данных на сервер является приведение их к такому формату, который может \r\nбыть легко прочтен сервером; этот процесс называется преобразованием в последовательную форму \r\n(сериализацией). Существует два варианта сериализации, которые могут предоставить вам самый широкий \r\nдиапазон возможностей передачи: \r\n• Передача обычного объекта JavaScript, который может быть использован для хранения пар ключ-значение \r\n(где значения представлены либо числами, либо строками). \r\n• Передача значений из нескольких элементов ввода формы (этот вариант отличается от первого тем, что в \r\nнем имеет значение порядок передаваемых элементов, тогда как порядок значений, передаваемых в \r\nпервом случае, может быть абсолютно произвольным). \r\nДавайте посмотрим в листинге 10.2 несколько примеров типов данных, которые можно передать на \r\nсервер, а также на получившееся из них на выходе последовательное представление, воспринимаемое сервером. \r\nЛистинг 10.2. Примеры простых JavaScript-объектов, преобразованных в последовательную форму \r\n// Простой объект, хранящий пары ключ-значение \r\n{ \r\n    name: \"John\", \r\n    last: \"Resig\", \r\n    city: \"Cambridge\", \r\n    zip: 02140 \r\n} \r\n  \r\n// Последовательная форма \r\nname=John&last=Resig&city=Cambridge&zip=02140 \r\n  \r\n","\r\n 205\r\n// Другой набор данных, имеющий множество значений \r\n[ \r\n    { name: \"name\", value: \"John\" }, \r\n    { name: \"last\", value: \"Resig\" }, \r\n    { name: \"lang\", value: \"JavaScript\" }, \r\n    { name: \"lang\", value: \"Perl\" }, \r\n    { name: \"lang\", value: \"Java\" } \r\n] \r\n  \r\n// И последовательная форма этих данных \r\nname=John&last=Resig&lang=JavaScript&lang=Perl&lang=Java \r\n  \r\n// В завершение найдем несколько элементов ввода (используя метод \r\n// id(), который мы создали в главе, посвященной DOM) \r\n[ \r\n    id( \"name\" ), \r\n    id( \"last\" ), \r\n    id( \"username\" ), \r\n    id( \"password\" ) \r\n] \r\n// И превратим их в строку данных \r\nname=John&last=Resig&username=jeresig&password=test \r\nФормат, использованный для сериализации данных является стандартным форматом для передачи в HTTP-\r\nзапросе. Вы, наверное, их уже видели в стандартном HTTP GET-запросе, который выглядит следующим образом: \r\nhttp://someurl.com/?name=John&last=Resig  \r\nЭти данные также могут быть переданы в POST-запрос (и в намного большем количестве, чем в простое \r\nотправление). Мы рассмотрим эти отличия в будущем разделе. \r\nНа данный момент давайте создадим стандартные средства сериализации структур данных, \r\nпредставленных в листинге 10.2. Специальная функция, выполняющая эту задачу, показана в листинге 10.3. Она \r\nспособна преобразовать в последовательную форму большинство элементов ввода формы, за исключением \r\nэлементов, имеющих множественный выбор. \r\nЛистинг 10.3. Стандартная функция для сериализации структур данных в совместимую с HTTP схему \r\nпараметров \r\n// Сериализация набора данных. Может воспринимать два различных типа \r\n// объектов: \r\n// - массив элементов ввода \r\n// - хэш, составленный из пар ключ-значение \r\n// Функция возвращает последовательную строку данных \r\nfunction serialize(a) { \r\n    // Набор результатов сериализации \r\n    var s = []; \r\n  \r\n    // Если передан массив, предположение, что он является массивом \r\n    // элементов формы \r\n","\r\n 206\r\n    if ( a.constructor == Array ) { \r\n  \r\n       // Сериализация элементов формы \r\n       for ( var i = 0; i < a.length; i++ ) \r\n           s.push( a[i].name + \"=\" + encodeURIComponent( a[i].value ) ); \r\n    // Если нет, предположение, что это объект, состоящий \r\n    // из пар ключ-значение \r\n    } else { \r\n       \r\n       // Сериализация пар ключ-значение \r\n       for ( var j in a ) \r\n           s.push( j + \"=\" + encodeURIComponent( a[j] ) ); \r\n    } \r\n  \r\n    // возврат результатов сериализации \r\n    return s.join(\"&\"); \r\n} \r\nПолучив последовательную форму наших данных (в виде простой строки), мы может посмотреть, как \r\nотправить эти данные на сервер, используя GET- или POST-запрос. \r\nСоздание GET-запроса \r\nВернемся к созданию HTTP GET-запроса на сервер с использованием XMLHttpRequest, но на этот раз уже с \r\nотправкой дополнительных данных, преобразованных в последовательную форму. Простой пример такого запроса \r\nпоказан в листинге 10.4. \r\nЛистинг 10.4. Кроссбраузерное средство создания HTTP GET-запроса к серверу (не приспособленное для \r\nчтения ответных данных) \r\n// Создание объекта запроса \r\nvar xml = new XMLHttpRequest(); \r\n// Открытие асинхронного GET-запроса \r\nxml.open(\"GET\", \"/some/url.cgi?\" + serialize( data ), true); \r\n  \r\n// Установка соединения с сервером \r\nxml.send();  \r\nВажно отметить, что сериализованные данные добавляются к URL сервера (с использованием в качестве \r\nразделителя знака вопроса —  ?). Все веб-серверы и находящиеся на них веб-приложения знают, что данные, \r\nвключенные после знака вопроса являются последовательным набором пар ключ-значение. Вопрос обработки \r\nвозвращаемого сервером ответа (основанного на переданных ему данных) будет рассмотрен в разделе \r\n«Обработка ответных данных». \r\nСоздание POST-запроса \r\nДругая форма создания HTTP-запроса к серверу, с использованием XMLHttpRequest, относится к POST, и в \r\nней задействуются совершенно другие способы отправки данных на сервер. Прежде всего POST-запрос способен \r\nотправлять данные любого формата и любой длины (не ограничиваясь лишь сериализованной строкой данных). \r\n","\r\n 207\r\nПри передаче на сервер сериализованный формат, используемый для данных обычно снабжается типом \r\nсодержимого application/x-www-form-urlencoded. Это означает, что вы также можете посылать на сервер чистый \r\nXML (с типом контента text/xml или application/ xml) или даже объект JavaScript (используя тип контекста \r\napplication/json). \r\nВ листинге 10.5 показан простой пример создания запроса и отправки дополнительных сериализованных \r\nданных. \r\nЛистинг 10.5. Кроссбраузерное средство создания HTTP POST-запроса к серверу (не приспособленное для \r\nчтения ответных данных) \r\n// Создание объекта запроса \r\nvar xml = new XMLHttpRequest(); \r\n  \r\n// Открытие асинхронного POST-запроса \r\nxml.open(\"POST\", \"/some/url.cgi\", true); \r\n  \r\n// Отправка заготовка типа контекста (content-type), \r\n// позволяющего серверу узнать, как интерпретировать посланные данные \r\nxml.setRequestHeader( \r\n    \"Content-Type\", \"application/x-www-form-urlencoded\"); \r\n  \r\n// Обеспечение отправки правильной длины сериализованных данных — \r\n// браузеры, основанные на движке Mozilla иногда испытывают с этим \r\n// проблемы \r\nif ( xml.overrideMimeType ) \r\n    xml.setRequestHeader(\"Connection\", \"close\"); \r\n  \r\n// Установка соединения с сервером и отправка сериализованных \r\n//данных \r\nxml.send( serialize( data ) );  \r\nЧтобы более подробно рассмотреть предыдущее утверждение, обратимся к случаю отправки на сервер \r\nданных, не приведенных к сериализованному формату. Соответствующий пример показан в листинге 10.6. \r\nЛистинг 10.6. Пример отправки на сервер POST-запроса, содержащего данные в формате XML \r\n// Создание объекта запроса \r\nvar xml = new XMLHttpRequest(); \r\n  \r\n// Открытие асинхронного POST-запроса \r\nxml.open(\"POST\", \"/some/url.cgi\", true); \r\n  \r\n// Установка заголовка типа контекста, чтобы сервер знал, \r\n// как интерпретировать отправляемые XML-данные \r\nxml.setRequestHeader( \"Content-Type\", \"text/xml\"); \r\n  \r\n// Обеспечение отправки правильной длины данных — браузеры, \r\n// основанные на движке Mozilla иногда испытывают с этим проблемы \r\nif ( xml.overrideMimeType ) \r\n","\r\n 208\r\n    xml.setRequestHeader(\"Connection\", \"close\"); \r\n  \r\n// Установка соединения с сервером и отправка данных \r\nxml.send( \"<items><item id='one'/><item id='two'/></items>\" );  \r\nВесьма существенной является возможность посылать большое количество данных (в отличие от GET-\r\nзапроса, предел для которого, в зависимости от браузера, составляет всего пару килобайт, ограничений на \r\nколичество передаваемых данных нет). Это позволяет создавать реализации различных протоколов обмена \r\nданными, например, XML-RPC или SOAP. \r\nНо, чтобы не усложнять  материал, мы ограничимся наиболее распространенными и полезными форматами \r\nданных, которые делают доступным HTTP ответ. \r\nHTTP ответ \r\nАспектом создания и использования XMLHttpRequest, который ставит его выше всех остальных \r\nупрощенных форм односторонней связи, является возможность чтения различных текстовых форматов данных, \r\nпосылаемых сервером. Сюда включается и один из краеугольных камней Ajax: XML (хотя этим еще не \r\nутверждается, что при создании Ajax-приложений может быть использован только XML. Кстати, в разделе \r\n«Обработка ответных данных» показан ряд других альтернативных форматов). \r\nДля начала взглянем на листинг 10.7 с очень простым примером обработки данных ответа, полученного от \r\nсервера. \r\nЛистинг 10.7. Установка соединения с сервером и чтение результирующих данных \r\n// создание объекта запроса \r\nvar xml = new XMLHttpRequest(); \r\n  \r\n// Открытие асинхронного POST-запроса \r\nxml.open(\"GET\", \"/some/url.cgi\", true); \r\n  \r\n// Отслеживание момента обновления статуса документа \r\nxml.onreadystatechange = function(){ \r\n    // Ожидание, пока не завершится загрузка данных \r\n    if ( xml.readyState == 4 ) { \r\n  \r\n       // xml.responseXML содержит XML-документ (если таковой был \r\n       // возвращен) \r\n       // xml.responseText содержит текст ответа \r\n       // (если не был предоставлен XML-документ) \r\n  \r\n       // Подчистка для экономии пространства памяти \r\n       xml = null; \r\n    } \r\n}; \r\n  \r\n// Установка соединения с сервером \r\nxml.send(); \r\n","\r\n 209\r\nВ этом примере можно увидеть, как получать доступ к различным блокам данных, полученных в ответе \r\nHTTP. Каждое из двух свойств, responseXML и responseText, будет содержать данные, отформатированные \r\nсоответствующим образом. Например, если сервер возвращает XML-документ, то DOM-документ будет находиться \r\nв responseXML; любой другой ответ и его результаты будут находиться в responseText. \r\nПеред тем, как заняться обработкой, перемещением и управлением полученными данными, давайте \r\nпоработаем над более сложной версией функции onreadystatechange (из листинга 10.7), способной обрабатывать \r\nошибки сервера и истечение срока соединения. \r\nОбработка ошибок \r\nК сожалению, объект XMLHttpRequest не имеет какого-нибудь встроенного механизма обработки ошибок \r\nсервера, наличие которого сэкономило бы массу времени. Но вы можете без особого труда создать свой \r\nсобственный механизм. При отправке запроса бывают случаи, требующие отслеживания ситуации для \r\nопределения, столкнулся ли сервер с проблемами при его обработке: \r\n• Код ответа успешно обработанного запроса: Предполагаемый способ проверки на наличие ошибок \r\nзаключается в отслеживании кода состояния ответа HTTP, который включен в HTTP-спецификацию как \r\nсредство оповещения клиента о том, что делает сервер. Успешным считается такой запрос, чей код \r\nсостояния находится в диапазоне 200. \r\n• Ответ, не подвергшийся изменениям: Возвращенный сервером документ может иметь пометку «Not \r\nModified» (код состояния 304). Это означает, что данные, полученные с сервера, не подверглись \r\nизменениям, и были загружены не с него, а из персональной кэш-памяти браузера. Поскольку данные по-\r\nпрежнему могут быть считаны клиентом, важно не считать этот ответ за ошибку. \r\n• Локально размещенные файлы: Если Ajax-приложение запущено на вашем локальном компьютере (без \r\nучастия веб-сервера), код состояния возвращаться не будет, даже если запрос будет успешным. Значит, \r\nситуацию, при которой запрос не имеет кода состояния и осуществляется просмотр локального файла \r\nнужно рассматривать как успешный ответ. \r\n• Ответ, не подвергшийся изменениям и Safari: Если документ не подвергся изменениям со времени \r\nпоследнего запроса (и если вы не отправляли явным образом серверу заголовок IF-MODIFIED-SINCE). Этот \r\nвесьма странный случай может позже помешать процессу отладки. \r\nПомня об этом, рассмотрим листинг 10.8, в котором представлена реализация проверки ответа, которую я \r\nранее уже в общих чертах обрисовал. \r\nЛистинг 10.8. Функция, которая может быть использована для проверки состояния успешности \r\nполученного с сервера ответа HTTP \r\n// Проверка, имеет ли объект XMLHttpRequest состояние успешности. \r\n// Функция принимает один аргумент — объект XMLHttpRequest \r\nfunction httpSuccess(r) { \r\n    try { \r\n       // Если состояние сервера предоставлено не было, и мы фактически \r\n       // сделали запрос к локальному файлу, значит, он прошел успешно \r\n       return !r.status && location.protocol == \"file:\" || \r\n  \r\n           // Нас устраивает любой код состояния в диапазоне 200 \r\n           ( r.status >= 200 && r.status < 300 ) || \r\n  \r\n           // Запрос прошел успешно, если документ не подвергся изменениям \r\n           r.status == 304 || \r\n","\r\n 210\r\n  \r\n           // Если файл не подвергался изменениям, Safari возвращает пустое \r\n           // состояние \r\n           navigator.userAgent.indexOf(\"Safari\") >= 0 && \r\n               typeof r.status == \"undefined\"; \r\n    } catch(e){} \r\n  \r\n// Если проверка состояния не удалась, следует предположить, \r\n// что запрос тоже закончился неудачей \r\n    return false; \r\n}  \r\nПроверка состояния ответа HTTP — шаг очень важный; если его не сделать, можно получить какие-нибудь \r\nнеприятные и весьма непредсказуемые результаты (например, вместо XML-документа будет возвращена страница \r\nошибки HTML). \r\nВ разделе «Полноценный Ajax-пакет» мы встроим функцию в законченное Ajax-решение. \r\nПроверка истечения времени запроса \r\nЕще одной полезной технологией, не включенной в исходную реализацию XMLHttpRequest, является \r\nопределение момента когда время запроса к серверу истекло, и он уже потерял всякий смысл. \r\nРеализация этого свойства Implementing this feature isn’t as cut-and-dry, but determining the success state of \r\nthe request (as you did in the previous section) is possible with a little bit of work. \r\nListing 10-9 shows how you would go about checking for a request time-out in an application of your own. \r\nЛистинг 10.9. Пример проверки истечения времени запроса \r\n// Создание объекта запроса \r\nvar xml = new XMLHttpRequest(); \r\n  \r\n// Открытие асинхронного POST-запроса \r\nxml.open(\"GET\", \"/some/url.cgi\", true); \r\n  \r\n// Мы собираемся дать на ожидание ответа 5 секунд \r\nvar timeoutLength = 5000; \r\n  \r\n// Отслеживание успешного выполнения запроса \r\nvar requestDone = false; \r\n  \r\n// Инициализация функции обратного вызова, которая будет запущена через \r\n// 5 секунд, отменяя запрос (если он не будет к тому времени выполнен) \r\nsetTimeout(function(){ \r\n    requestDone = true; \r\n}, timeoutLength); \r\n  \r\n// Отслеживание обновления состояния документа \r\nxml.onreadystatechange = function(){ \r\n    // Ожидание, полной загрузки данных, \r\n","\r\n 211\r\n    // и проверка, не истекло ли время запроса \r\n    if ( xml.readyState == 4 && !requestDone ) { \r\n  \r\n       // xml.responseXML содержит XML-документ (если он был возвращен) \r\n       // xml.responseText содержит текст \r\n       // (если XML-документ не был предоставлен) \r\n  \r\n       // Подчистка для экономии пространства памяти \r\n       xml = null; \r\n    } \r\n}; \r\n  \r\n// Установка соединения с сервером \r\nxml.send(); \r\nКогда учтены все детали обмена данными с сервером, включая все множество возможных ошибок, \r\nнаступает время обратиться к подробностям обработки ответных данных, полученных с сервера. \r\nОбработка ответных данных \r\nВо всех ранее приводимых примерах место для ответных данных, полученных с сервера пустовало по той \r\nпростой причине, что существует поистине бесчисленное множество всевозможных форматов данных, которые \r\nмогут быть возвращены сервером. Но на самом деле XMLHttpRequest работает только с форматами данных, \r\nимеющими текстовую основу. Но даже при этом с некоторыми из них он работает лучше (с XML), чем с другими (с \r\nJSON). В этой главе мы собираемся рассмотреть три различных формата данных, которые могут быть возвращены \r\nсервером, а затем считаны и обработаны клиентом: \r\n• XML: Хорошо, что все современные браузеры изначально обеспечивают обработку XML-документов, \r\nавтоматически превращая их в полезные DOM-документы. \r\n• HTML: Этот формат отличается от XML-документа тем, что обычно представляет собой простую текстовую \r\nстроку, содержащую фрагмент HTML-кода. \r\n• JavaScript/JSON: Он охватывает два формата данных — простой, исполняемый код JavaScript, и \r\nпредставление объекта JavaScript — JSON (JavaScript Object Notation). \r\nУ каждого из этих форматов данных есть различные случаи применения, в которых они могут быть \r\nособенно полезны. К примеру, существует масса примеров, когда имеет больше смысла вместо XML-документа \r\nвозвращать фрагменты кода HTML. Важный аспект извлечения данных из ответа HTTP заключается в двух \r\nсвойствах объекта XMLHttpRequest: \r\n• responseXML: Это свойство будет содержать ссылку на заранее сгенерированный DOM-документ \r\n(представляющий документ XML) если с сервера был возвращен XML-документ. Это случается только если \r\nсервер явным образом указал в заголовке контента «Content-type: text/xml», или подобный этому тип \r\nданных XML. \r\n• responseText: Это свойство содержит ссылку на простую текстовую строку возвращенных сервером \r\nданных. На этот метод для доступа к своим данным полагаются два типа данных: HTML и JavaScript. \r\nИмея в распоряжении эти два свойства, можно без особого труда создать универсальную функцию для \r\nдетерминированного извлечения данных из ответа HTTP (и даже определить с чем вы имеете дело, с XML-ответом \r\nили с обычным текстом). В листинге 10.10 показана функция, которую можно использовать именно в этом \r\nкачестве. \r\n","\r\n 212\r\nЛистинг 10.10. Функция, предназначенная для извлечения правильных данных из ответа HTTP-сервера \r\n// Функция для извлечения данных из ответа HTTP \r\n// Она принимает два аргумента, объект XMLHttpRequest и \r\n// необязательный аргумент – тип данных, ожидаемых с сервера \r\n// Приемлемы следующие значения: xml, script, text или html — по \r\n// умолчанию — \"\", что устанавливает тип данных на основе заголовка \r\n// content-type \r\nfunction httpData(r, type) { \r\n    // Получение заголовка content-type \r\n    var ct = r.getResponseHeader(\"content-type\"); \r\n  \r\n    // Если не предоставлен тип по умолчанию, определение \r\n    // не возвращена ли с сервера какая-либо форма XML \r\n    var data = !type && ct && ct.indexOf(\"xml\") >= 0; \r\n  \r\n    // Получение объекта XML-документа, если сервер вернул XML, \r\n    // если нет — возвращение полученного с сервера текстового содержимого \r\n    data = type == \"xml\" || data ? r.responseXML : r.responseText; \r\n  \r\n    // Если указан тип \"script\", выполнение возвращенного текста, \r\n    // реагируя на него, как на JavaScript \r\n    if ( type == \"script\" ) \r\n       eval.call( window, data ); \r\n    \r\n    // Возвращение данных, полученных в ответе (или XML-документа, или \r\n    // текстовой строки) \r\n    return data; \r\n}  \r\nТеперь, располагая этой функцией извлечения данных, у нас имеются все компоненты, необходимые для \r\nпостроения законченной функции, создающей обычный Ajax-вызов данных с сервера. Полная реализация \r\nфункции показана в следующем разделе. \r\nПолноценный Ajax-пакет \r\nИспользуя все изученные до сих пор понятия, можно создать универсальную функцию для обработки всех \r\nAjax-запросов и связанных с ними ответов. В основном эта функция станет в будущих главах фундаментом для \r\nнашей Ajax-разработки, позволяющей осуществлять быстрые запросы к серверу для получения дополнительной \r\nинформации. \r\nЗаконченная Ajax-функция показана в листинге 10.11. \r\nЛистинг 10.11. Законченная функция, способная осуществлять необходимые задачи, связанные с \r\nиспользованием Ajax \r\n// Универсальная функция, предназначенная для осуществления Ajax-запросов \r\n// Она принимает один аргумент, представляющий собой объект, содержащий \r\n// набор параметров, каждый из которых имеет краткое описание в последующих \r\n// комментариях \r\nfunction ajax( options ) { \r\n","\r\n 213\r\n    \r\n    // Загрузка объекта параметров по умолчанию, если пользователем не \r\n    // представлено никаких значений \r\n    options = { \r\n       // Тип http-запроса \r\n       type: options.type || \"POST\", \r\n  \r\n       // URL на который должен быть послан запрос \r\n       url: options.url || \"\", \r\n  \r\n       // Время ожидания ответа на запрос \r\n       timeout: options.timeout || 5000, \r\n  \r\n       // Функция, вызываемая, когда запрос неудачен, успешен \r\n       // или завершен (успешно или нет) \r\n       onComplete: options.onComplete || function(){}, \r\n       onError: options.onError || function(){}, \r\n       onSuccess: options.onSuccess || function(){}, \r\n  \r\n       // Тип данных которые будут возвращены с сервера \r\n       // по умолчанию просто определить, какие данные были \r\n       // возвращены, и действовать соответственно. \r\n       data: options.data || \"\" \r\n    }; \r\n    \r\n    // Создание объекта запроса \r\n    var xml = new XMLHttpRequest(); \r\n  \r\n    // Открытие асинхронного запроса \r\n    xml.open(options.type, options.url, true); \r\n  \r\n    // Ожидание отклика на запрос в течение 5 секунд \r\n    // перед тем, как от него отказаться \r\n    var timeoutLength = options.timeout; \r\n  \r\n    // Отслеживание факта успешного завершения запроса \r\n    var requestDone = false; \r\n  \r\n    // Инициализация функции обратного вызова, которая будет запущена через \r\n    // 5 секунд, отменяя запрос (если он не будет к тому времени выполнен) \r\n    setTimeout(function(){ \r\n       requestDone = true; \r\n    }, timeoutLength); \r\n  \r\n    // Отслеживание обновления состояния документа \r\n    xml.onreadystatechange = function(){ \r\n       // Ожидание, полной загрузки данных, \r\n       // и проверка, не истекло ли время запроса      \r\n","\r\n 214\r\n       if ( xml.readyState == 4 && !requestDone ) { \r\n  \r\n           // Проверка успешности запроса \r\n            if ( httpSuccess( xml ) ) { \r\n  \r\n               // Выполнение в случае успеха функции обратного вызова \r\n               // с данными, возвращенными с сервера \r\n               options.onSuccess( httpData( xml, options.type ) ); \r\n  \r\n           // В противном случае произошла ошибка, поэтому нужно \r\n           // выполнить функцию обратного вызова для обработки ошибки \r\n           } else { \r\n               options.onError(); \r\n           } \r\n  \r\n           // Выполнение функции обратного вызова, связанной с завершением \r\n           // запроса \r\n           options.onComplete(); \r\n  \r\n           // Подчистка для экономии пространства памяти \r\n           xml = null; \r\n       } \r\n    }; \r\n  \r\n    // Установка соединения с сервером \r\n    xml.send(); \r\n  \r\n    // Определение успешности получения ответа HTTP \r\n    function httpSuccess(r) { \r\n       try { \r\n           // Если состояние сервера предоставлено не было, и мы \r\n           // фактически сделали запрос к локальному файлу, \r\n           //  значит, он прошел успешно \r\n           return !r.status && location.protocol == \"file:\" || \r\n  \r\n               // Нас устраивает любой код состояния в диапазоне 200 \r\n               ( r.status >= 200 && r.status < 300 ) || \r\n  \r\n               // Запрос прошел успешно, если документ не подвергся \r\n               // изменениям \r\n               r.status == 304 || \r\n  \r\n               // Если файл не подвергался изменениям, Safari возвращает \r\n               // пустое состояние          \r\n               navigator.userAgent.indexOf(\"Safari\") >= 0 \r\n                  && typeof r.status == \"undefined\"; \r\n       } catch(e){} \r\n  \r\n","\r\n 215\r\n       // Если проверка состояния не удалась, следует предположить, \r\n       // что запрос тоже закончился неудачей \r\n       return false; \r\n    } \r\n  \r\n    // Извлечение правильных данных из ответа HTTP \r\n    function httpData(r,type) { \r\n       // Получение заголовка content-type \r\n       var ct = r.getResponseHeader(\"content-type\"); \r\n  \r\n        // Если не предоставлен тип по умолчанию, определение \r\n       // не возвращена ли с сервера какая-либо форма XML \r\n       var data = !type && ct && ct.indexOf(\"xml\") >= 0; \r\n  \r\n       // Получение объекта XML-документа, если сервер вернул XML, \r\n       // если нет — возвращение полученного с сервера текстового \r\n       // содержимого \r\n       data = type == \"xml\" || data ? r.responseXML : r.responseText; \r\n  \r\n       // Если указан тип \"script\", выполнение возвращенного текста, \r\n        // реагируя на него, как на JavaScript \r\n       if ( type == \"script\" ) \r\n           eval.call( window, data ); \r\n  \r\n       // Возвращение данных, полученных в ответе (или XML-документа, или \r\n       // текстовой строки) \r\n       return data; \r\n    } \r\n}  \r\nВажно отметить, что запрос страниц, которые находятся не в том же домене, что и страница, с которой \r\nпроизводится запрос, невозможно. Это обусловлено ограничениями, налагаемыми из соображений безопасности \r\nвсеми современными браузерами (чтобы пресечь попытки кражи вашей персональной информации). Теперь, когда \r\nмы располагаем столь мощной функцией, настало время проработать несколько примеров, демонстрирующих \r\nновоприобретенную силу Ajax. \r\nПримеры различного использования данных \r\nПо сути ситуации создания простых Ajax-запросов мало отличаются друг от друга, но, что действительно \r\nизменяется, так это данные, которые сервер посылает в ответ. В зависимости от цели, которую вы пытаетесь \r\nдостичь, наличие различных форматов данных может сталь очень полезным обстоятельством. Именно по этому я и \r\nсобираюсь вам показать, как выполняются некоторые стандартные задачи с применением ряда различных \r\nформатов. \r\nRSS-поток, основанный на формате XML \r\nНесомненно наиболее популярным форматом для возвращаемых сервером данных является XML, и для \r\nэтой популярности есть весьма серьезные основания. Все современные браузеры обладают своей собственной \r\nподдержкой XML-документов, конвертируя их на лету в DOM-представление. Поскольку всю тяжелую работу по \r\nсинтаксическому разбору берет на себя браузер, все, что остается сделать — пройтись по нему, как по любому \r\n","\r\n 216\r\nдругому DOM-документу. При этом важно отметить, что перемещаться по восстановленному из удаленного \r\nисточника XML-документу с помощью функции getElementById в принципе невозможно. Просто потому, что \r\nобычные не-HTML XML-документы не имеют у себя предварительно запрограммированного уникального атрибута \r\nID. Но не смотря на сказанное, все же способ эффективного перемещения по XML-документам есть. \r\nВ листинге показан простой пример использования возвращенного XML для создания на веб-сайте \r\nэлемента отображения RSS-потока. \r\nЛистинг 10.12. Загрузка заголовков новостей, содержащихся в удаленном RSS-потоке, основанном на \r\nформате XML \r\n  \r\n<html> \r\n<head> \r\n    <title>Динамический элемент отображения RSS-потока</title> \r\n    <!—загрузка нашей универсальной Ajax-функции --> \r\n    <script src=\"ajax.js\"></script> \r\n    <script> \r\n       // Ожидание полной загрузки документа \r\n       window.onload = function(){ \r\n           // И загрузка RSS-потока с использованием Ajax \r\n           ajax({ \r\n           // URL RSS-потока \r\n           url: \"rss.xml\", \r\n  \r\n           // Это XML-документ \r\n               type: \"xml\", \r\n  \r\n               // Эта функция будет выполнена, когда запрос будет завершен \r\n               onSuccess: function( rss ) { \r\n                  // Все заголовки у которых id равны \"feed\", \r\n                  // мы собираемся поместить в теги <ol> \r\n                  var feed = document.getElementById(\"feed\"); \r\n  \r\n                  // Использование всех заголовков RSS XML-документа \r\n                  var titles = rss.getElementsByTagName(\"title\"); \r\n  \r\n                  // последовательный перебор всех соответствующих \r\n                  // заголовков новостей \r\n                  for ( var i = 0; i < titles.length; i++ ) { \r\n                      // Создание <li>-элемента для размещения заголовка \r\n                      // новости \r\n                      var li = document.createElement(\"li\"); \r\n  \r\n                      // Установка содержимого заголовка в элемент \r\n                      li.innerHTML = titles[i].firstChild.nodeValue; \r\n  \r\n                      // и добавление его в DOM, в <ol>-элемент \r\n                      feed.appendChild( li ); \r\n","\r\n 217\r\n                  } \r\n               } \r\n           }); \r\n       }; \r\n    </script> \r\n</head> \r\n<body> \r\n    <h1> Динамический элемент отображения RSS-потока</h1> \r\n    <p>Ознакомление с RSS-потоком:</p> \r\n    <!-- Именно сюда мы собираемся вставить RSS-поток --> \r\n    <ol id=\"feed\"></ol> \r\n</body> \r\n</html>  \r\nКак видите, после того, как все сложности, связанные с Ajax-процессом запроса-ответа перемещены в \r\nдругое место, для решения этой задачи особых усилий прикладывать не пришлось. Кроме того, поскольку \r\nбраузеры существенно упростили проход по XML-документу, этот способ действительно стал великолепным \r\nсредством быстрой передачи данных от сервера к клиенту. \r\nВставка HTML \r\nЕще одной технологией, которая может быть выполнена с использованием Ajax является загрузка в \r\nдокумент HTML-фрагментов. Эта технология отличается от только что рассмотренной методики работы с XML-\r\nдокументом тем, что для нее не требуется проводить синтаксический разбор или осуществлять проход по данным, \r\nполучаемым с сервера; она используется только для вставки этих данных в документ. Использование этого \r\nметода — действительно быстрый и впечатляющий способ простого и немедленного получения обновления вашей \r\nвеб-страницы. Пример использования этого метода показан в листинге 10.13. \r\nЛистинг 10.13. Загрузка HTML-фрагмента из удаленного файла и вставка его в текущую веб-страницу \r\n<html> \r\n<head> \r\n    <title> Спортивный счет в формате HTML, загруженный Ajax </title> \r\n    <!-- Загрузка нашей универсальной Ajax-функции --> \r\n    <script src=\"ajax.js\"></script> \r\n    <script> \r\n       // Ожидание полной загрузки документа \r\n       window.onload = function(){ \r\n           // Затем загрузка спортивного счета с использованием Ajax \r\n           ajax({ \r\n               // URL, где находятся спортивный счет в формате HTML \r\n               url: \"scores.html\", \r\n  \r\n               // Это HTML-документ \r\n               type: \"html\", \r\n  \r\n               // Эта функция будет выполнена, когда запрос будет завершен \r\n               onSuccess: function( html ) { \r\n                  // Мы собираемся вставить HTML в div-элемент, \r\n                  // значение id которого равно 'scores' \r\n","\r\n 218\r\n                  var scores = document.getElementById(\"scores\"); \r\n  \r\n                  // Вставка нового HTML в документ \r\n                  scores.innerHTML = html; \r\n               } \r\n           }); \r\n       }; \r\n    </script> \r\n</head> \r\n<body> \r\n    <h1> Спортивный счет в формате HTML, загруженный с помощью Ajax </h1> \r\n    <!-- Сюда будет вставлен спортивный счет --> \r\n    <div id=\"scores\"></div> \r\n</body> \r\n</html>  \r\nНаиболее важный аспект динамической HTML-технологии заключается в том, что вы по-прежнему можете \r\nхранить все шаблоны уровня приложения в коде на стороне сервера, что позволяет централизованно содержать и \r\nбез проблем обслуживать весь базовый код шаблонов. \r\nПростоту загрузки обычных HTML-файлов трудно переоценить, поскольку она предоставляет самый легкий \r\nспособ придать веб-приложению лучшую отзывчивость на действия пользователя. \r\nJSON и JavaScript: Удаленное выполнение \r\nВ заключение я собираюсь рассмотреть формат данных (один из тех, к которому мы еще вернемся в \r\nглаве 13, при изучении wiki), который относится к передаче строк данных JSON и простого кода JavaScript. \r\nПередача сериализированных JSON-данных может служить облегченной альтернативой передаче XML-документов \r\nот сервера к клиенту. Кроме того, предоставление сервером простого кода JavaScript служит превосходным \r\nспособом построения динамических многопользовательских приложений. Чтобы ничего не усложнять, давайте \r\nрассмотрим удаленную загрузку в приложение файла JavaScript, показанную в листинге 10.14. \r\nЛистинг 10.14. Динамическая загрузка и исполнение удаленного JavaScript-файла \r\n<html> \r\n<head> \r\n    <!-- Загрузка нашей универсальной Ajax-функции --> \r\n    <script src=\"ajax.js\"></script> \r\n    <script> \r\n       // Загрузка удаленного JavaScript-файла \r\n       ajax({ \r\n           // URL JavaScript-файла \r\n           url: \"myscript.js\", \r\n  \r\n           // Принуждение его к выполнению в качестве кода JavaScript \r\n           type: \"script\" \r\n       }); \r\n    </script> \r\n</head> \r\n<body></body> \r\n","\r\n 219\r\n</html>  \r\nВывод \r\nПри всей своей обманчивой простоте, концепция веб-приложений Ajax обладает большими \r\nвозможностями. Динамическая загрузка дополнительных информационных частей в уже запущенное приложение, \r\nиспользующее JavaScript, позволяет создавать более отзывчивый интерфейс, способный порадовать \r\nпользователей. \r\nВ этой главе мы на изучили основных концепций работы Ajax, включая особенности http-запроса и ответа, \r\nобработку ошибок, форматирование данных и их синтаксический разбор. В результате этого была разработана \r\nуниверсальная функция, которую можно многократно использовать для упрощения работы по приданию большей \r\nдинамичности любому веб-приложению. Эта функция будет использована в следующих трех главах для создания \r\nдинамичных элементов взаимодействия, основанных на технологии Ajax.  \r\n","\r\n 220\r\nГлава 11 Усовершенствование блогов с помощью Ajax \r\nОдной из возможностей, предоставляемой технологией Ajax, является предоставление дополнительных \r\nуровней взаимодействия с пользователями при работе со статическими веб-страницами. Это означает, что вы \r\nможете приступать к изменениям характера работы статической веб-страницы, не нарушая целостности \r\nпользовательского представления. \r\nОдна из областей, которую можно усовершенствовать — это сетевые журналы, или блоги. Если взглянуть \r\nна него с точки зрения данных, то блог — это ничто иное, как перечень статей, в котором есть текстовая статья, \r\nзаголовок и ссылка на полную версию статьи. Но средства просмотра старых статей и проверки наличия новых \r\nоставляют желать лучшего. \r\nВ этой главе мы рассмотрим два разных способа улучшения типичного блога за счет применения кода \r\nJavaScript, в котором используется технология Ajax. Один из них представляет собой средство простой прокрутки \r\nбольшого перечня статей без оставления текущей страницы, а другой — способ отслеживания новых статей блога \r\nбез непрерывной перезагрузки веб-страницы. \r\nБесконечный блог \r\nПервым усовершенствованием, которое мы собираемся применить к блогу — возможность осуществления \r\nобратной прокрутки архивов без каких-либо щелчков на ссылках переходов. Общей особенностью блогов, или \r\nиных веб-сайтов, содержимое которых имеет хронологический характер, является возможность перехода к более \r\nранним статьям. Зачастую она предоставляется за счет ссылок Следующая и (или) Предыдущая в нижней части \r\nстраницы, которые позволяют пользователю перемещаться по архивным статьям. \r\nМы будем исследовать способ, при котором весь этот процесс будет проведен с помощью Ajax. Чтобы \r\nсоздать утилиту, способную выполнить эту задачу, нужно сделать несколько допущений: \r\n• У нас есть веб-страница с серией публикаций, изложенных в хронологическом порядке. \r\n• Когда пользователь приближается к концу страницы, у него возникает желание прочитать предыдущие \r\nпубликации. \r\n• У нас есть источник данных, из которого можно брать публикации. В данном случае мы собираемся \r\nвоспользоваться WordPress, программным обеспечением для создания блогов (http://wordpress.org/), \r\nкоторое хорошо справляется с этой задачей. \r\nТогда замыслом нашего сценария будет автоматическая подгрузка дополнительных публикаций как только \r\nпользователь прокрутит изображение ближе к нижней части страницы, что позволит ему продолжить прокрутку и \r\nперемещаться по архиву, при этом возникнет иллюзия бесконечной веб-страницы. Этот сценарий будет создан с \r\nиспользованием функциональных возможностей программного обеспечения WordPress, предназначенного для \r\nсоздания блогов. У вас появится возможность включить этот сценарий и в свой собственный блог, построенный на \r\nоснове WordPress, придав ему дополнительные функциональные возможности. \r\nШаблон блога \r\nСначала мы собираемся воспользоваться основным шаблоном, предоставляемым по умолчанию при \r\nустановке WordPress. Обычно этот шаблон называется Kubrik, и пользуется немалой популярностью. На рис. 11.1 \r\nпоказан пример обычной страницы, использующей тему Kubrik. \r\n","\r\n 221\r\n \r\nРис. 11.1. Пример темы Kubrik, используемой в WordPress по умолчанию \r\nКак видно из иллюстрации, у страницы есть основной столбец, заголовок и боковая панель. Самой главной \r\nобластью является заголовок; именно в нем идет поиск публикаций и добавление новой информации. Рассмотрим \r\nприведенную в листинге 11.1 упрощенную версию HTML, используемую в качестве структуры этого блога. \r\nЛистинг 11.1. Упрощенная версия HTML, сгенерированного темой Kubrik и WordPress \r\n  \r\n<html> \r\n<head> \r\n    <title>Бесконечный Wordpress</title> \r\n    <script> \r\n       <!-- Сюда будет помещен наш сценарий --> \r\n    </script> \r\n</head> \r\n<body> \r\n    <div id=\"page\"> \r\n       <div id=\"header\"> \r\n           <!—Содержимое заголовка --> \r\n       </div> \r\n       <div id=\"content\"> \r\n  \r\n           <!-- Первая публикация --> \r\n           <div class=\"post\"> \r\n               <!-- Заголовок публикации --> \r\n","\r\n 222\r\n               <h2><a href=\" /test/?p=1\">Тестовая публикация</a></h2> \r\n               <small>24 октября 2006 года</small> \r\n  \r\n               <div class=\"entry\"> \r\n                  <!-- Содержимое публикации --> \r\n               </div> \r\n  \r\n               <p class=\"postmetadata\"> \r\n                   <a href=\"/test/?p=1#comments\">Комментарии</a></p> \r\n           </div> \r\n  \r\n           <!-- Другие публикации ... --> \r\n  \r\n       </div> \r\n    </div> \r\n</body> \r\n</html>  \r\nСледует заметить, что все публикации блога помещены в <div>-контейнеры с ID, значение которого равно \r\n«content». Кроме этого, каждая публикация обладает специфическим форматом, который придает ей \r\nопределенную структуру. С расчетом на это нужно создать простой набор DOM-функций, которые можно будет \r\nвыполнить для получения некоторых данных и внедрения их на страницу блога. В листинге 11.2 показаны DOM-\r\nоперации, необходимые для завершения страницы. \r\nЛистинг 11.2. Операции DOM для добавления HTML, необходимого для завершения страницы \r\n// Загрузка новых публикаций производится в <div>-контейнер с ID, значение \r\n// которого равно \"content\" \r\nvar content = document.getElementById(\"content\"); \r\n  \r\n// Мы собираемся осуществить последовательный перебор всех публикаций \r\n// в RSS-потоке \r\nvar items = rss.getElementsByTagName(\"item\"); \r\nfor ( var i = 0; i < items.length; i++ ) { \r\n  \r\n    // Извлечение ссылки, заголовка и описательных данных из каждого \r\n    // элемента потока, относящегося к публикации \r\n    var data = getData( items[i] ); \r\n  \r\n    // Создание нового <div>-контейнера для хранения публикации \r\n    var div = document.createElement(\"div\"); \r\n    div.className = \"post\"; \r\n  \r\n    // Создание заголовка публикации \r\n    var h2 = document.createElement(\"h2\"); \r\n  \r\n    // Здесь содержится заголовок элемента потока и имеется ссылка, \r\n    // указывающая на публикацию. \r\n    h2.innerHTML = \"<a href='\" + data.link + \"'>\" + data.title + \"</a>\"; \r\n","\r\n 223\r\n  \r\n    // Добавление этого содержимого к <div>-контейнеру публикации  \r\n    div.appendChild( h2 ); \r\n  \r\n    // Теперь создадим <div>, в котором будет содержаться публикация \r\n    var entry = document.createElement(\"div\"); \r\n    entry.className = \"entry\"; \r\n  \r\n    // Добавим в <div> содержимое публикации \r\n    entry.innerHTML = data.desc; \r\n    div.appendChild( entry ); \r\n  \r\n    // В завершение добавим нижнюю часть, содержащую ссылку возврата \r\n    var meta = document.createElement(\"p\"); \r\n    meta.className = \"postmetadata\"; \r\n  \r\n    var a = document.createElement(\"a\"); \r\n    a.href = data.link + \"#comments\"; \r\n    a.innerHTML = \"Комментарий\"; \r\n    meta.appendChild( a ); \r\n  \r\n    div.appendChild( meta ); \r\n  \r\n    // Помещение новой публикации в документ \r\n    content.appendChild( div ); \r\n  \r\n} \r\nНо все эти DOM-операции мало что значат, если вы не знаете, с какими данными имеете дело. В \r\nследующем разделе мы рассмотрим данные, которые будут переданы нам с сервера, и как их можно будет \r\nвставить в документ, используя DOM-операции. \r\nИсточник данных \r\nWordPress предоставляет простые средства доступа к данным публикаций. Все блоги WordPress включают \r\nисходный RSS-поток, который можно использовать для просмотра десяти наиболее свежих публикаций. Но только \r\nэтого одного будет не достаточно, нам нужен доступ ко всем публикациям, для чего следует вернуться к самому \r\nначалу веб-сайта. К счастью, именно для этого имеется одно скрытое свойство, которым можно воспользоваться. \r\nURL для RSS-потока обычно выглядит в WordPress следующим образом: /blog/ ?feed=rss; но если к нему \r\nдобавить дополнительный параметр, /blog/?feed=rss&paged=N, то можно углубиться в исторические данные блога \r\n(с N равным 1 отображаются десять самых последних публикаций, с 2 — десять предыдущих, и т. д.). В листинге \r\n11.2 показан пример того, как выглядит RSS-поток, содержащий данные публикаций. \r\nЛистинг 11.3. XML RSS-поток, возвращаемый WordPress, который содержит десять публикаций в четко \r\nотформатированной структуре \r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \r\n<rss version=\"2.0\"> \r\n  \r\n","\r\n 224\r\n<channel> \r\n    <title>Test Wordpress Web log</title> \r\n    <link>http://someurl.com/test/</link> \r\n    <description>Test Web log.</description> \r\n    <pubDate>Fri, 08 Oct 2006 02:50:23 +0000</pubDate> \r\n    <generator>http://wordpress.org/?v=2.0</generator> \r\n    <language>en</language> \r\n  \r\n    <item> \r\n       <title>Test Post</title> \r\n       <link>http://someurl.com/?p=9</link> \r\n       <pubDate>Thu, 07 Sep 2006 09:58:07 +0000</pubDate> \r\n       <dc:creator>John Resig</dc:creator> \r\n       <category>Uncategorized</category> \r\n       <description><![CDATA[Сюда помещается содержимое публикации...]]> \r\n                                                       </description> \r\n    </item> \r\n  \r\n    <!-- Множество других публикаций --> \r\n</channel> \r\n</rss> \r\nБлагодаря подключению к RSS-потоку вы получаете четко отформатированный XML-файл, с которым \r\nможно работать (и по которому очень удобно перемещаться с помощью JavaScript). В листинге 11.4показан код, \r\nнеобходимый для прохода по RSS XML-документу и извлечения из него всей важной информации. \r\nЛистинг 11.4. Извлечение информации о публикации из XML RSS-потока \r\n// Мы собираемся осуществить последовательный перебор всех публикаций, \r\n// имеющихся в RSS-потоке \r\nvar items = rss.getElementsByTagName(\"item\"); \r\n  \r\nfor ( var i = 0; i < items.length; i++ ) { \r\n  \r\n    // Извлечение из <item>-элемента RSS-потока заголовка, описания \r\n    // и ссылки    \r\n    var title = elem.getElementsByTagName(\"title\")[0].firstChild.nodeValue; \r\n    var desc = \r\n       elem.getElementsByTagName(\"description\")[0].firstChild.nodeValue; \r\n    var link = elem.getElementsByTagName(\"link\")[0].firstChild.nodeValue; \r\n}  \r\nТеперь, когда у нас есть цельный источник данных и четкая структура для вставки результатов в HTML-\r\nдокумент, настало время склеить все вместе с помощью Ajax-запроса и определения наступления некоторых \r\nосновных событий. \r\nОпределение наступления событий \r\n","\r\n 225\r\nОсновным действием, которое пользователь должен совершить для активации нашего сценария, будет \r\nпростая прокрутка ближе к концу страницы. При каждом смещении области просмотра браузера нам нужно \r\nпроверять, не приблизилось ли оно к нижней части страницы. \r\nСценарий управления этим процессом относительно прост; нужно лишь привязать отдельный обработчик \r\nсобытия к событию прокрутки окна. Тогда будет известно о каждом случае перемещения пользователем окна \r\nпросмотра по странице (что может происходить и возле нижней части окна). Все, что нужно будет сделать \r\nсводится к применению нескольких методов, показанных в главе 7 с целью определения, где именно находится \r\nпользовательская область просмотра относительно страницы: pageHeight (для определения высоты всей \r\nстраницы), scrollY (для определения текушего положения, до которого прокручена вершина области просмотра), и \r\nwindowHeight (для определения высоты области просмотра). Все они показаны в листинге 11.5. \r\nЛистинг 11.5. Определение положения пользовательской области просмотра \r\n// Мы собираемся определить, не пора ли подгружать дополнительное \r\n// содержимое в зависимости от того, где на странице находится \r\n// пользовательская область просмотра \r\nwindow.onscroll = function(){ \r\n    // Проверка положения области просмотра на странице \r\n    if ( curPage >= 1 && !loading && \r\n       pageHeight() -scrollY() -windowHeight() < windowHeight() ) { \r\n       // Запрос RSS XML-потока с использованием Ajax \r\n    } \r\n};  \r\nТеперь у нас есть все необходимые компоненты, осталось только добавить Ajax-запрос, чтобы извлечь \r\nданные, необходимые для того, чтобы все как следует заработало. \r\nЗапрос \r\nЯдро всего приложения связано с использованием Ajax-запросов для динамической загрузки новых блоков \r\nпубликаций, которые затем можно будет вставлять в страницу. Нужный нам запрос довольно прост: отправляем \r\nна определенный URL (указывающий на следующий блок публикаций) HTTP GET-запрос и извлекаем находящийся \r\nтам XML-документ. Именно это и делает код, показанный в листинге 11.6, в котором используется полноценная \r\nAjax-функция (из главы 10). \r\nЛистинг 11.6. Ajax-запрос для загрузки нового блока публикаций \r\n // Загрузка публикаций с использованием доступной нам функции ajax() \r\najax({ \r\n  \r\n    // Мы запрашиваем простую веб-страницу, поэтому используем GET \r\n    type: \"GET\", \r\n  \r\n    // Ожидается RSS-поток, представленный XML-файлом \r\n    data: \"xml\", \r\n  \r\n    // Получение RSS-потока N-ной страницы. При первоначальной загрузке \r\n    // нашей страницы мы находимся на странице '1', поэтому при переходе \r\n    // к предыдущему периоду времени мы начинаем со страницы 2 \r\n    url: \"./?feed=rss&paged=\" + ( ++curPage ), \r\n","\r\n 226\r\n  \r\n    // Отслеживание успешного завершения извлечения RSS-потока \r\n    onSuccess: function( rss ){ \r\n       // Проход по RSS XML-документу, используя его DOM \r\n    } \r\n});  \r\nТеперь после создания механизма составления запроса страницы, следует связать все вместе в единый \r\nпакет, который без особого труда можно будет поместить непосредственно в ваш WordPress-блог. \r\nРезультат \r\nОбъединение кода построения DOM с кодом прохода по RSS XML, наверное, самая простая часть этого \r\nприложения, но при объединении с определителем события прокрутки и Ajax-запросом, вы получаете все \r\nкомпоненты, необходимые для привлекательного дополнения вашего блога — возможность непрерывной \r\nпрокрутки по всем публикациям блога не покидая при этом страницу. В листинге 11.7 показан полный код, \r\nнеобходимый для усовершенствования блога WordPress путем добавления этих функциональных возможностей. \r\nЛистинг 11.7. Код JavaScript, необходимый для предоставления блогу WordPress возможностей \r\nбесконечной страницы \r\n// Отслеживание на какой \"странице\" содержимого мы находимся в данный момент \r\nvar curPage = 1; \r\n  \r\n// Предотвращение двойной загрузки страницы за один сеанс работы \r\nvar loading = false; \r\n  \r\n// Отслеживание необходимости загрузки дополнительного содержимого в \r\n// зависимости от того места страницы, которое просматривается \r\n// пользователем \r\nwindow.onscroll = function(){ \r\n    // Перед загрузкой дополнительного содержимого нужно проверить \r\n    // 1) Что мы не на последней странице содержимого. \r\n    // 2) Что мы только что уже не загружали каких-нибудь новых \r\n    //    публикаций. \r\n    // 3) Что мы собираемся загружать только новые для нас публикации, \r\n    //    прокрутка достигла нижней части страницы \r\n    if ( curPage >= 1 && !loading \r\n       && pageHeight() -scrollY() -windowHeight() < windowHeight() ) { \r\n  \r\n       // Запоминание того, что мы приступили к загрузке новых публикаций. \r\n       loading = true; \r\n  \r\n       // Загрузка публикаций, с использованием доступной нам \r\n       // функции ajax() \r\n       ajax({ \r\n  \r\n           // Мы запрашиваем простую веб-страницу, поэтому используем GET \r\n           type: \"GET\", \r\n  \r\n","\r\n 227\r\n           // Ожидается RSS-поток, представленный XML-файлом \r\n           data: \"xml\", \r\n  \r\n           // Получение RSS-потока N-ной страницы. При первоначальной \r\n           // загрузке нашей страницы мы находимся на странице '1', \r\n           // поэтому при переходе к предыдущему периоду времени мы \r\n           // начинаем со страницы 2 \r\n           url: \"./?feed=rss&paged=\" + ( ++curPage ), \r\n  \r\n           // Отслеживание успешного завершения извлечения RSS-потока \r\n           onSuccess: function( rss ){ \r\n  \r\n               // Загрузка новых публикаций в <div>, \r\n               // у которого ID имеет значение \"content\" \r\n               var content = document.getElementById(\"content\"); \r\n  \r\n               // Мы собираемся осуществить последовательный перебор \r\n               // всех публикаций, имеющихся в RSS-потоке           \r\n               var items = rss.getElementsByTagName(\"item\"); \r\n               for ( var i = 0; i < items.length; i++ ) { \r\n  \r\n                  // помещение новой публикации в документ \r\n                  content.appendChild( makePost( items[i] ) ); \r\n  \r\n               } \r\n  \r\n               // Если из XML-документа уже больше нечего извлекать, \r\n               // мы должны вернуться назад, насколько это возможно \r\n               if ( items.length == 0 ) { \r\n                  curPage = 0; \r\n               } \r\n           }, \r\n  \r\n           // Как только запрос будет завершен, можно будет \r\n           // снова осуществить попытку загрузки новых публикаций \r\n           onComplete: function(){ \r\n               loading = false; \r\n           } \r\n       }); \r\n    } \r\n}; \r\n  \r\n// Функция, предназначенная для создания полной DOM-структуры отдельной \r\n// публикации \r\nfunction makePost( elem ) { \r\n    // Извлечение из каждого элемента потока публикаций ссылки, заголовка \r\n    // и описания данных \r\n    var data = getData( elem ); \r\n","\r\n 228\r\n  \r\n    // Создание нового <div>-контейнера для содержимого публикации \r\n    var div = document.createElement(\"div\"); \r\n    div.className = \"post\"; \r\n  \r\n    // Создание заголовка публикации \r\n    var h2 = document.createElement(\"h2\"); \r\n  \r\n    // Здесь содержится заголовок элемента потока и имеется ссылка, \r\n    // указывающая на публикацию. \r\n    h2.innerHTML = \"<a href='\" + data.link + \"'>\" + data.title + \"</a>\"; \r\n  \r\n    // Добавление этого содержимого к <div>-контейнеру публикации  \r\n    div.appendChild( h2 ); \r\n  \r\n    // Теперь создадим <div>, в котором будет содержаться публикация \r\n    var entry = document.createElement(\"div\"); \r\n    entry.className = \"entry\"; \r\n  \r\n    // Добавим в <div> содержимое публикации \r\n    entry.innerHTML = data.desc; \r\n    div.appendChild( entry ); \r\n  \r\n    // В завершение добавим нижнюю часть, содержащую ссылку возврата \r\n    var meta = document.createElement(\"p\"); \r\n    meta.className = \"postmetadata\"; \r\n    meta.innerHTML = \"<a href='\" + data.link + \"#comments'>Комментарий</a>\"; \r\n    div.appendChild( meta ); \r\n  \r\n    return div; \r\n} \r\n  \r\n// Простая функция для извлечения данных из DOM-элемента \r\nfunction getData( elem ) { \r\n    // Мы собираемся вернуть данные в виде четко отформатированного объекта \r\n    return { \r\n       // Извлечение из элемента <item> RSS-потока заголовка, описания и \r\n       // ссылки \r\n       title: elem.getElementsByTagName(\"title\")[0].firstChild.nodeValue, \r\n       desc: \r\n       elem.getElementsByTagName(\"description\")[0].firstChild.nodeValue, \r\n       link: elem.getElementsByTagName(\"link\")[0].firstChild.nodeValue \r\n    }; \r\n}  \r\nБудет вполне достаточно добавить этот код в верхнюю часть заголовка вашего файла шаблона WordPress, \r\nчтобы получить результат, похожий на тот, что показан на рис. 11.2. Заметьте, что полоса прокрутки имеет \r\nдовольно небольшой запас (что может свидетельствовать о завершении динамической загрузки на страницу \r\nдополнительных публикаций). \r\n","\r\n 229\r\n \r\nРис. 11.2. Пример дополнительного содержимого, загруженного для просмотра в процессе дальнейшей \r\nпрокрутки страницы вниз \r\nДинамическая загрузка содержимого является обычным примером применения Ajax. Практически всегда \r\nэто ведет к облегчению для пользователя процесса просмотра страницы, и облегчению нагрузки на сервер. В \r\nлюбом случае количество приложений, где будет востребована вставка дополнительного содержимого не \r\nограничивается лишь одними блогами. Любые веб-приложения могут получить от этот технологии весьма \r\nсущественную выгоду, и мы более подробно рассмотрим этот аспект в следующей главе. \r\nА в следующем разделе мы рассмотрим еще один пример загрузки динамического содержимого, в котором \r\nиспользуется та же Ajax-технология, но на этот раз мы создадим для просмотрщиков вашего блога возможность \r\nнаблюдать за его ведением в режиме реального времени. \r\nНаблюдение за ведением блога в режиме реального времени \r\nТеперь, после того, как была проделана вся тяжелая работа по созданию динамического отображения \r\nпубликаций, извлечению опубликованных данных и их разбору, мы можем рассмотреть другое приложение, \r\nпольза от которого проявляется именно в блоге WordPress. \r\nОбычно в блогах отсутствует возможность немедленного отображения новостей и обновления. \r\nПользователям предоставляется статическая страница с перечнем самых последних публикаций блога, а если им \r\nпотребуются дополнительные обновления, они будут вынуждены перезагрузить страницу в своем браузере. Но \r\nсуществует масса примеров, когда блоггер захочет немедленно сообщить пользователю какую-нибудь \r\nинформацию, если тот все еще просматривает его страницу. Теоретически пользователь должен иметь \r\nвозможность загрузить страницу, оставить ее открытой, чуть позже вернуться к ее просмотру, и увидеть новую \r\nпубликацию. \r\n","\r\n 230\r\nИ в этом случае мы можем найти технологии Ajax весьма хорошее применение. Для загрузки нового \r\nсодержимого из вашего RSS-потока можно воспользоваться той же самой технологией, которая была \r\nиспользована в предыдущем разделе. Рассмотрим следующий порядок действий, необходимых для придания \r\nобычному блогу режима работы в реальном времени: \r\n• Извлечение перечня самых свежих публикаций блога за определенный промежуток времени (к примеру, \r\nза одну минуту). \r\n• Обнаружение еще не отображенных публикаций. \r\n• Добавление этих публикаций в начало страницы. \r\nРеализация этого замысла, показанная в листинге 11.8, также проста, как и вышеперечисленный порядок \r\nдействий. \r\nЛистинг 11.8. Реализация блога, обновляемого на лету из RSS-потока, основанного на формате XML \r\n// Мы собираемся совершать повторные попытки загрузить новое содержимое \r\n// страницы через определенный интервал времени \r\nsetInterval(function(){ \r\n  \r\n    // Загрузка публикации с использованием доступной нам функции ajax() \r\n    ajax({ \r\n  \r\n        // Мы запрашиваем простую веб-страницу, поэтому используем GET \r\n        type: \"GET\", \r\n  \r\n       // Ожидается RSS-поток, представленный XML-файлом \r\n        data: \"xml\", \r\n  \r\n       // Получение текущего RSS-потока (содержащего самые свежие \r\n       // публикации) \r\n       url: \"./?feed=rss&paged=1\", \r\n  \r\n       // Отслеживание успешного завершения извлечения RSS-потока \r\n        onSuccess: function( rss ){ \r\n  \r\n           // Загрузка новых публикаций в <div>, \r\n           // у которого ID имеет значение \"content\" \r\n           var content = document.getElementById(\"content\"); \r\n  \r\n           // Получение URL самой последней публикации (чтобы убедиться, \r\n           // что мы не работает с дубликатами публикаций) \r\n           var recentURL = \r\n               content.getElementsByTagName(\"h2\")[0].firstChild.href; \r\n  \r\n           // Мы собираемся осуществить последовательный перебор \r\n           // всех публикаций, имеющихся в RSS-потоке             \r\n           var items = rss.getElementsByTagName(\"item\"); \r\n  \r\n           // Мы собираемся поместить все новые публикации \r\n","\r\n 231\r\n           // в отдельный массив \r\n  \r\n           var newItems = []; \r\n  \r\n           // Проход по всем элементам \r\n           for ( var i = 0; i < items.length; i++ ) { \r\n  \r\n               // Принудительное прекращение цикла при \r\n               // \"старой\" публикации \r\n               if ( getData( items[i] ).link == recentURL ) \r\n                  break; \r\n               \r\n               // Добавление нового элемента к временному массиву \r\n               newItems.push( items[i] ); \r\n           } \r\n  \r\n           // Последовательный перебор всех новых публикаций \r\n           // в обратном порядке, чтобы обеспечить правильный порядок \r\n           // их размещения на веб-сайте \r\n           for ( var i = newItems.length -1; i >= 0; i--) { \r\n               // Помещение в документ новой публикации \r\n               content.insertBefore( makePost( newItems[i] ), \r\n                                            content.firstChild ); \r\n           } \r\n       } \r\n    }); \r\n// Загрузка нового содержимого страницы раз в минуту \r\n}, 60000 );  \r\nКогда этот сценарий будет добавлен в ваш шаблон WordPress (наряду с тем кодом, который был \r\nразработан в первой части главы при создании бесконечной страницы) вы получите результат, похожий на тот, \r\nчто изображен на рис. 11.3. \r\n","\r\n 232\r\n \r\nРис. 11.3. WordPress вставляет отдельную новую публикацию впереди других, более старых публикаций \r\nбез обновления страницы \r\nВоспользовавшись последним усовершенствованием, вы сможете превратить простой блог в платформу, \r\nработающую в режиме реального времени. Следующим в очереди на «оживление» может стать форум. Добавите \r\nэтот сценарий к вашему веб-сайту, и ваши читатели будут получать обновления по мере их публикации, без \r\nобновления страницы. \r\nВывод \r\nНаиболее важным из рассмотренных понятий, которое можно вынести из этой главы, является то, что \r\nсвязанные с Ajax технологии позволяют вам придумывать новые режимы работы обычных статических \r\nприложений. Поскольку обработка XML-документов и их преобразование в полезные фрагменты HTML \r\nсущественно упростились, вы имеете полную возможность их реализации в своих веб-приложениях. \r\nВ этой главе мы создали два дополнения к обычной блог-платформе на основе WordPress. Мы реально \r\nизбавились от необходимости перехода к более ранним публикациям по старомодным ссылкам и с разбиением \r\nсодержимого на разные страницы. Вместо этого мы загружаем блоки публикаций в динамическом режиме, по мере \r\nпросмотра страницы пользователем. Кроме этого, при появлении новой публикации в период просмотра страницы \r\nпользователем, она будет добавлена к странице, позволяя пользователю продолжать чтение, не покидая \r\nстраницу. Оба этих усовершенствования позволяют улучшить восприятие просмотра, делая его более динамичным \r\nи активным, и не разбивать публикации на несколько страниц. \r\nВ следующей главе мы создадим еще одно расширение за счет использования функциональных \r\nвозможностей Ajax: поиск с автозаполнением. \r\n","\r\n 233\r\nГлава 12 Поиск автозаполнения \r\nНаиболее важными функциональными преимуществами, предоставляемыми Ajax-технологией являются \r\nвозможности создания пользовательских интерфейсов с высокой степенью взаимодействия, многие из которых \r\nранее были недоступны. Примером одного из таких новых пользовательских элементов интерфейса может служить \r\nтак называемое поле поиска автозаполнения. Это поле во многом похоже на обычное текстовое поле, но оно \r\nавтоматически завершает условия поиска, как только вы начинаете их ввод. Это означает, что по мере набора \r\nпоискового запроса, клиент посылает запрос на сервер (в фоновом режиме), и пытается быстро предоставить вам \r\nнаиболее точные результаты.  \r\nВ этой главе мы рассмотрим все компоненты, необходимые для построения полноценного поиска \r\nавтозаполнения. Сначала мы рассмотрим, как построить и оформить страницу, потом узнаем, как отслеживать \r\nпользовательский ввод в текстовое поле, а затем свяжем все это с простым Ajax-запросом, обращающимся к \r\nпростой базе данных на стороне сервера.  \r\nПримеры поиска автозаполнения \r\nПоле поиска автозаполнения может проявлять себя несколькими разными способами. Например, в Google \r\nесть версия автозаполнения его поля поиска, называемая Google Suggest \r\n(http://www.google.com/webhp?complete=1). Когда вы начинаете набирать в поле запрос на поиск, эта система \r\nпоказывает вам другие запросы на поиски, наиболее часто проводившиеся другими пользователями, которые \r\nначинаются с тех же символов, что и только что набранные. Пример поиска автозаполнения показан на рис. 12.1.  \r\n \r\nРис. 12.1. Пример обычных результатов автозаполнения \r\nДругим весьма популярным примером является Instant Domain Search (http://instantdomainsearch.com/). \r\nЭто специализированное приложение по мере набора предоставляет сведения о доступности покупаемого \r\nдоменного имени. Этот вариант отличается от той реализации, которую представила компания Google тем, что он \r\nавтоматически завершает поиск, а не заполняет строку самого запроса. Это означает, что по мере набора \r\nискомого доменного имени сервер автоматически в фоновом режиме завершает ваш запрос, выдавая \r\nсоответствующие ему результаты. Пример работы этой системы показан на рис. 12.2. \r\n","\r\n 234\r\n \r\nРис. 12.2. Пример поиска автозаполнения в системе Instant Domain Search \r\nПоследний приводимый пример, который наиболее близок к тому, что мы будем создавать — это механизм \r\nавтозаполнения, предоставляемый Интернет-службой закладок del.icio.us (http://del.icio.us/). Эта служба \r\nпредоставляет средства, с помощью которых вы можете связать ссылки с определенными словами, позволяя \r\nпроизвести автозаполнение нескольких слов в единственном поле ввода текста. Пример работы этого механизма \r\nпоказан на рис. 12.3.  \r\n \r\nРис. 12.3. Пример работы автозаполнения del.icio.us, завершающего новый тег  \r\nТеперь мы вплотную приблизились к созданию собственного механизма поиска  автозаполнения. Это будет \r\nпростая форма для отправки сообщений группе друзей, расположенная на веб-сайте. Автозаполняемое поле будет \r\nвести себя очень похоже на поле в del.icio.us, в том, что это будет поле для ввода имен пользователей, которое \r\nпри помощи    Ajax может быть автоматически заполнено в фоновом режиме. У вас будет возможность \r\nавтозаполнения каждого из пользовательских имен ваших друзей, на основе тех имен, которые хранятся в \r\nцентральной базе данных, и помещения их в список пользовательских имен, разделенных запятой, используемый \r\nдля отправки им сообщений. Пример того эффекта, который мы собираемся получить, показан на рис. 12.4.  \r\n \r\n","\r\n 235\r\nРис. 12.4. Пример автозаполнения пользовательского имени после ввода одной буквы \r\nПостроение страницы \r\nПервым шагом к созданию нашего поля поиска автозаполнения станет построение формы, в которой будет \r\nразмещена полная установка. Эта страница по структуре будет напоминать простую форму для отправки \r\nсообщения группе пользователей веб-сайта. В дополнение к обычной форме отправки сообщений (состоящей из \r\nполя Кому и области сообщения) в эту страницу необходимо включить три важных аспекта:  \r\nПоле ввода текста: Нам нужно обеспечить, чтобы его свойство autocomplete было выключено. Тем самым \r\nмы отключим включенный по умолчанию механизм автозаполнения браузера (который использует для \r\nавтозаполнения все, что было ранее набрано в области ввода):  \r\n    <input type=\"text\" id=\"to\" name=\"to\" autocomplete=\"off\"/>  \r\nЗагружаемое изображение: Это небольшое, вращающееся изображение, накладываемое поверх поля \r\nввода текста, чтобы показать, когда с сервера загружаются новые данные:  \r\n    <img src=\"indicator.gif\" id=\"qloading\"/>  \r\nОбласть результатов: Все результаты, возвращаемые с сервера, будут помещаться в область результатов и \r\nотображены по требованию. Физические результаты будут возвращаться в виде набора <li>-элементов, в каждом \r\nиз которых будет содержаться информация об отдельном пользователе:  \r\n    <div id=\"results\"><div class=\"suggest\">Suggestions:</div><ul></ul></div>  \r\nИ индикатор загрузки, и область результатов будут включены в страницу с помощью JavaScript. Полный \r\nкод HTML для нашей страницы показан в листинге 12.1.  \r\nЛистинг 12.1. Полный код HTML для формы отправки сообщений пользователям  \r\n<html> \r\n<head> \r\n    <script src=\"dom.js\"></script> \r\n    <script src=\"delay.js\"></script> \r\n    <script src=\"script.js\"></script> \r\n    <link rel=\"stylesheet\" href=\"style.css\"/> \r\n</head> \r\n<body> \r\n    <form action=\"\" method=\"POST\" id=\"auto\"> \r\n       <div id=\"top\"> \r\n           <div id=\"mhead\"><strong>Send Message</strong></div> \r\n           <div class=\"light\"> \r\n               <label>From:</label> \r\n               <div class=\"rest from\"> \r\n                  <img src=\"icons/john_icon.jpg\"/> \r\n                  <strong>John Resig</strong> \r\n               </div> \r\n           </div> \r\n           <div class=\"query dark\"> \r\n               <label>To:</label> \r\n               <div class=\"rest\"> \r\n","\r\n 236\r\n                 <input type=\"text\" id=\"to\" name=\"to\" autocomplete=\"off\"/> \r\n               </div> \r\n           </div> \r\n           <div class=\"light\"><textarea></textarea></div> \r\n           <div class=\"submit\"><input type=\"submit\" value=\"&raquo; \r\n                                                       Send\"/></div> \r\n       </div> \r\n    </form> \r\n</body> \r\n</html>  \r\nНа рис. 12.5 представлена копия экрана с видом страницы, имеющей полное стилевое оформление.  \r\n \r\nРис. 12.5. Вид макета формы после простого стилевого оформления Результат нашего The result of your \r\nform mockup with some simple styling \r\nТеперь, когда у нас есть установленная и готовая к пользовательскому вводу форма, настало время \r\nприступить к следующему шагу — отслеживанию вводимой пользователем информации в поле ввода имени \r\nпользователя, и соответствующего на нее реагирования.  \r\nОтслеживание ввода с клавиатуры \r\nОдним из важных аспектов поиска автозаполнения является создание естественно воспринимаемого \r\nинтерфейса, с помощью которого пользователь сможет вводить данные и получать его расширенный вариант. Для \r\nбольшинства поисковых вводов основная часть интерфейса поиска обращается к отдельному полю ввода текста. \r\nВы будете и в дальнейшем использовать этот интерфейс, включая ваши собственные приложения.  \r\nПри конструировании этого механизма ввода нужно учесть некоторые моменты, чтобы быть уверенным, \r\nчто предоставленный уровень взаимодействия близок к идеалу:  \r\n• Нужно обеспечить включение поиска автозаполнения через подходящие интервалы времени, когда ответ \r\nдается достаточно быстро, чтобы пользователь сумел на него среагировать.  \r\n• Нужно обеспечить, чтобы поиск на сервере осуществлялся как можно медленнее. Чем быстрее \r\nосуществляется поиск, тем большая нагрузка ложится на сервер.  \r\n• Нужно обеспечить знание подходящего момента для осуществления нового поиска автозаполнения и \r\nоткрытия результатов; для отказа от поиска и открытия старых результатов; и для скрытия результатов.  \r\n","\r\n 237\r\nТеперь, изложив эти пункты, мы можем более точно определить взаимодействие с пользователем, которое \r\nхотим реализовать:  \r\n• Результаты автозаполнения должны отображаться на основе того, что пользователь набрал в поле ввода \r\nтекста. Кроме того, чтобы избежать слишком неоднозначных результатов поиска, пользователь должен \r\nпредоставить для него минимальное количество символов.  \r\n• Результаты поиска должны вызываться через строго определенные интервалы времени (чтобы защитить \r\nсервер от перегрузки от действий слишком быстро печатающих пользователей), но только при изменениях \r\nвведенного содержимого.  \r\n• Подборка результатов должна быть показана или скрыта в зависимости от того, имеет ли элемент ввода \r\nпользовательский фокус (к примеру, если пользователь убрал фокус с элемента ввода, результаты \r\nдолжны быть скрыты).  \r\nС учетом всех этих пунктов мы можем разработать отдельную функцию для привязки требуемого \r\nвзаимодействия к отдельному полю ввода текста. В листинге 12.2 показана функция, которая может быть \r\nиспользована для достижения желаемых результатов. Эта функция обрабатывает только случаи, при которых \r\nдолжен проводится поиск или при которых результаты должны быть показаны или скрыты, а не сам поиск или \r\nвизуальные результаты (мы добавим все это чуть позже).  \r\nЛистинг 12.2. Функция привязки поиска автозаполнения к полю ввода текста  \r\nfunction delayedInput(opt) { \r\n    // Количество времени ожидания до отслеживания нового пользовательского \r\n    // ввода \r\n    opt.time = opt.time || 400; \r\n  \r\n    // Минимальное количество символов, ожидаемых до запуска запроса \r\n    opt.chars = opt.chars != null ? opt.chars : 3; \r\n  \r\n    // Обратный вызов, запускаемый, когда должны быть показаны \r\n    // всплывающие результаты, и, возможно, когда должен быть сделан \r\n    // новый запрос \r\n    opt.open = opt.open || function(){}; \r\n  \r\n    // Обратный вызов, выполняемый, когда всплывающие результаты должны \r\n    // быть закрыты \r\n    opt.close = opt.close || function(){}; \r\n  \r\n    // Фокус поля должен быть принят во внимание для открытия \r\n    // (закрытия) всплывающих результатов \r\n    opt.focus = opt.focus !== null ? opt.focus : false; \r\n  \r\n    // Запоминание исходного значения, с которым мы начинаем \r\n    // работать \r\n    var old = opt.elem.value; \r\n  \r\n    // и текущего состояния открыто-закрыто всплывающего результата \r\n    var open = false; \r\n  \r\n    // Проверка изменений ввода в заданный интервал времени \r\n","\r\n 238\r\n    setInterval(function(){ \r\n       // Новое вводимое значение \r\n       var newValue = opt.elem.value; \r\n  \r\n       // Количество введенных символов \r\n       var len = s.length; \r\n  \r\n       // Быстрая проверка на изменения значения со времени последней \r\n       // проверки ввода \r\n       if ( old != newValue ) { \r\n  \r\n           // Если введено недостаточно символов, и всплывающие результаты \r\n           // в данный момент открыты \r\n           if ( v < opt.chars && open ) { \r\n  \r\n               // Закрыть отображение \r\n               opt.close(); \r\n  \r\n               // И запомнить, что оно закрыто \r\n               open = false; \r\n  \r\n           // В противном случае, если было введено минимальное \r\n           // количество символов пока оно больше одного символа \r\n           } else if ( v >= opt.chars && v > 0 ) { \r\n  \r\n               // открыть выплывающие результаты с текущим значением \r\n               opt.open( newValue, open ); \r\n  \r\n               // Запомнить, что всплывающие результаты на данный \r\n               // момент открыты \r\n               open = true; \r\n           } \r\n  \r\n           // Сохранение на будущее текущего значения \r\n           old = newValue; \r\n       } \r\n    }, opt.time ); \r\n  \r\n    // Отслеживание нажатия клавиши \r\n    opt.elem.onkeyup = function(){ \r\n       // Если в результате нажатия клавиши символов больше не осталось, \r\n       // закрыть всплывающие результаты \r\n       if ( this.value.length == 0 ) { \r\n           // Закрыть результаты \r\n           opt.close(); \r\n  \r\n           // Запомнить, что они закрыты \r\n           open = false; \r\n","\r\n 239\r\n       } \r\n    }; \r\n  \r\n    // Если мы также проверяем пользовательский фокус (для управления \r\n    // открытием-закрытием всплывающих результатов) \r\n    if ( opt.focus ) { \r\n       // Отслеживание перемещения пользователя за пределы элемента ввода \r\n       opt.elem.onblur = function(){ \r\n           // Если результаты открыты \r\n           if ( open) { \r\n               // закрыть их \r\n               opt.close(); \r\n  \r\n               // и запомнить, что они закрыты \r\n               open = false; \r\n           } \r\n       } \r\n  \r\n       // Отслеживание, когда пользовательский фокус вернется на элемент \r\n       // ввода \r\n       opt.elem.focus = function(){ \r\n           // если во всплывающих результатах есть какое-нибудь значение, \r\n           // и они в данный момент закрыты \r\n           if ( this.value.length != 0 && !open ) { \r\n               // повторное открытие всплывающих результатов, но с пустым \r\n               // значением \r\n               // (это позволит 'открывающей' функции узнать, что \r\n               // перезапрашивать новые результаты с сервера не нужно, \r\n               // нужно их просто заново открыть). \r\n               opt.open( '', open ); \r\n  \r\n               // И запомнить, что они открыты \r\n               open = true; \r\n           } \r\n       }; \r\n    } \r\n} \r\nВ листинге 12.3 показано, как в нашей реализации автозаполнения для отслеживания пользовательского \r\nввода использовать простую функцию delayedInput.  \r\nЛистинг 12.3. Использование универсальной функции delayedInput() в нашей реализации автозаполнения  \r\n// Инициализация задержки проверки ввода в поле \r\ndelayedInput({ \r\n    // Прикрепление к полю текстового ввода \r\n    elem: id(\"to\"), \r\n  \r\n    // Мы намереваемся приступить к поиску только после ввода \r\n","\r\n 240\r\n    // одного символа \r\n    chars: 1, \r\n  \r\n    // Когда текстовое поле теряет фокус, закрыть всплывающие результаты \r\n    focus: true, \r\n  \r\n    // Обработка момента открытия всплывающего результата \r\n    open: function(q,open){ \r\n       // Извлечение последнего слова из списка слов, разделенных \r\n       // запятыми \r\n       var w = trim( q.substr( q.lastIndexOf(',')+1, q.length ) ); \r\n  \r\n       // Обеспечение того, что мы работаем как минимум со словом \r\n       if ( w ) { \r\n           // Отображение анимации, свидетельствующей о загрузке \r\n           show( id(\"qloading\") ); \r\n  \r\n           // Загрузка и обработка результатов с сервера \r\n       } \r\n    }, \r\n  \r\n    // Когда нужно закрыть всплывающие результаты \r\n    close: function(){ \r\n       // Скрытие подборки результатов \r\n       hide( id(\"results\") ); \r\n    } \r\n}); \r\nТеперь, когда у нас есть универсальная функция для отслеживания пользовательского ввода, нужно \r\nрешить задачу ее привязки к сценарию на стороне сервера, который будет предоставлять данные о \r\nпользователях, которые можно загрузить на ваш веб-сайт.  \r\nИзвлечение результатов \r\nСледующим основным аспектом построения поиска автозаполнения является загрузка данных, которые \r\nбудут показаны пользователю. Для загрузки этих данных не требуется использование технологии Ajax (которую \r\nмы будем применять в этой конкретной реализации); вместо этого они могут быть написаны в виде структуры \r\nданных и загружены в страницу во время выполнения приложения.  \r\nНаша реализация автозаполнения требует в законченном виде только одного: пользователей. Их \r\nпользовательские имена будут отображены с сопутствующей информацией (включая полное имя пользователя и \r\nего значок). C расчетом на это намного легче будет просто вернуть с сервера HTML-фрагмент (в форме некоторого \r\nколичества <li>-элементов), содержащий всю необходимую информацию о соответствующих пользователях.  \r\nВ листинге 12.4 показан простой Ajax-вызов, необходимый для загрузки с сервера фрагмента HTML во \r\nвсплывающие результаты.  \r\nЛистинг 12.4.  AJAX-запрос для загрузки фрагмента HTML (содержащего информацию о пользователях)  в \r\nподборку результатов для автозаполнения  \r\n// Создание запроса новых данных \r\n","\r\n 241\r\najax({ \r\n    // Создание простого GET-запроса к CGI-сценарию, возвращающему \r\n    // HTML-блок, состоящий из элементов LI \r\n    type: \"GET\", \r\n    url: \"auto.cgi?to=\" + w, \r\n  \r\n    // Отслеживание возвращения HTML \r\n    onSuccess: function(html){ \r\n       // Вставка его в предназначенный для результатов UL-контейнер \r\n       results.innerHTML = html; \r\n  \r\n       // и скрытие анимации загрузки \r\n       hide( id(\"qloading\") ); \r\n  \r\n       // Обработка результатов... \r\n    } \r\n});  \r\nВы должны обратить внимание на то, что в листинге 12.4 мы загружаем HTML-результаты из приложения \r\nсерверной стороны под названием auto.cgi, которое воспринимает один аргумент — текущий текст, по которому \r\nведется поиск (скорее всего это будет часть имени пользователя). Сценарий auto.cgi, написанный с \r\nиспользованием языка Perl, показан в листинге 12.5. Он ведет поиск соответствий в небольшом наборе данных, \r\nвозвращая всех подходящих пользователей в длинный HTML-фрагмент.  \r\nЛистинг 12.5. Простой Perl-сценарий, отыскивающий подходящих пользователей  \r\n#!/usr/bin/perl \r\n  \r\nuse CGI; \r\n  \r\n# Извлечение из строки входящего запроса параметра 'q' \r\nmy $cgi = new CGI(); \r\nmy $q = $cgi->param('to'); \r\n  \r\n# Наша ограниченная \"база данных\" содержит пять пользователей, \r\n# их пользовательские и полные имена. \r\nmy @data = ( \r\n    { \r\n       user => \"bradley\", \r\n       name => \"Bradley S\" \r\n    }, \r\n    { \r\n       user => \"jason\", \r\n       name => \"Jason S\" \r\n    }, \r\n    { \r\n       user => \"john\", \r\n       name => \"John R\" \r\n    }, \r\n","\r\n 242\r\n    { \r\n       user => \"josh\", \r\n       name => \"Josh K\" \r\n    }, \r\n    { \r\n       user => \"julia\", \r\n       name => \"Julia W\" \r\n    } \r\n); \r\n  \r\n# Обеспечение выдачи правильного HTML-заголовка \r\nprint \"Content-type: text/html\\n\\n\"; \r\n  \r\n# \"Поиск\" по данным \r\nforeach my $row (@data) { \r\n    \r\n    # Поиск пользователей, соответствующих нашему аргументу \r\n    # поиска автозаполнения \r\n    if ( $row->{user} =~ /$q/i || $row->{name} =~ /$q/i ) { \r\n  \r\n       # Если пользователь соответствует условию, выдача \r\n       # необходимого HTML \r\n       print qq~<li id=\"$row->{user}\"> \r\n           <img src=\"icons/$row->{user}_icon.jpg\"/> \r\n           <div> \r\n               <strong>$row->{user}</strong> ($row->{name}) \r\n           </div> \r\n       </li>~; \r\n    } \r\n}  \r\n  \r\nРезультат, возвращаемый CGI-сценарием ничто иное, как HTML-фрагмент, содержащий <li>-элементы, \r\nсоответствующие каждому подходящему пользователю. В листинге 12.6 показан результат поиска для буквы j.  \r\nЛистинг 12.6. Фрагмент HTML, возвращенный с сервера, представляющий несколько различных \r\nпользователей  \r\n<li id=\"jason\"> \r\n    <img src=\"icons/jason_icon.jpg\"/> \r\n    <div> \r\n       <strong>jason</strong> (Jason S) \r\n    </div> \r\n</li><li id=\"john\"> \r\n    <img src=\"icons/john_icon.jpg\"/> \r\n    <div> \r\n       <strong>john</strong> (John R) \r\n    </div> \r\n</li><li id=\"josh\"> \r\n","\r\n 243\r\n    <img src=\"icons/josh_icon.jpg\"/> \r\n    <div> \r\n       <strong>josh</strong> (Josh K) \r\n    </div> \r\n</li><li id=\"julia\"> \r\n    <img src=\"icons/julia_icon.jpg\"/> \r\n    <div> \r\n       <strong>julia</strong> (Julia W) \r\n    </div> \r\n</li>  \r\nТеперь, когда у нас есть небольшой набор данных, возвращенный HTML-фрагмент, и HTML, вводимый в \r\nвеб-сайт, следующим логичным шагом будет добавление способов перехода пользователя по результатам.  \r\nПереход по списку результатов \r\nТеперь, когда пользователь ввел какой-то текст в поле ввода, и с сервера были загружены некоторые \r\nрезультаты, настало время добавить способ перемещения пользователя по возвращенному набору результатов. В \r\nнашей реализации поиска автозаполнения мы собираемся предложить два различных способа перемещения по \r\nрезультатам: с помощью клавиатуры и с помощью мыши.  \r\nПеремещения с помощью клавиатуры \r\nПеремещение по результатам с помощью клавиатуры по всей вероятности является наиболее важным \r\nаспектом реализации. Поскольку пользователь находится в процессе набора имени пользователя, он дает ему \r\nвозможность если это необходимо  завершить автозаполнение, оставляя руки на клавиатуре.  \r\nНам нужна поддержка клавиши табуляции, чтобы завершить работу с текущим выбранным пользователем, \r\nи клавиш со стрелками вверх и вниз, для выбора различных пользователей из списка результатов. В \r\nлистинге 12.7 показано, как этого можно будет достичь.  \r\nЛистинг 12.7. Обработчик события нажатия клавиш перемещений  \r\n// Отслеживание ввода информации в поле \r\nid(\"to\").onkeypress = function(e){ \r\n    // Получение всех пользователей из списка результатов \r\n    var li = id(\"results\").getElementsByTagName(\"li\"); \r\n  \r\n    // Когда нажата клавиша [TAB] или клавиша [Enter] \r\n    if ( e.keyCode == 9 || e.keyCode == 13 ) { \r\n       // Добавление пользователя к полю ввода текста \r\n  \r\n    // Если нажата клавиша вверх \r\n    } else if ( e.keyCode == 38 ) \r\n       // Выбор предыдущего пользователя, или последнего пользователя \r\n       // если мы находимся в начале списка) \r\n       return updatePos( curPos.previousSibling || li[ li.length - 1 ] ); \r\n  \r\n    // Если нажата клавиша вниз \r\n    else if ( e.keyCode == 40 ) \r\n       // Выбор следующего пользователя, или первого пользователя (если мы \r\n","\r\n 244\r\n       // находимся в конце списка) \r\n       return updatePos( curPos.nextSibling || li[0] ); \r\n};  \r\nПеремещение с помощью мыши \r\nВ отличие от перемещений с помощью клавиатуры, все перемещения, осуществляемые с помощью мыши \r\nдолжны иметь динамическую привязку при каждом возвращении с сервера нового набора результатов. Замысел \r\nперемещений с помощью мыши состоит в том, что при каждом прохождении указателя мыши над одним из <li>-\r\nэлементов, это элемент становится текущим «выбранным», и если на нем щелкнуть кнопкой, связанное с <li> имя \r\nпользователя должно быть добавлено в поле ввода текста. В листинге 12.8 показан пример кода, с помощью \r\nкоторого можно реализовать этот замысел.  \r\nЛистинг 12.8. Привязка события перемещения указателя мыши к <li>-элементу  \r\n// При каждом прохождении указателя мыши над li, \r\n// он становится текущим выбором пользователя \r\nli[i].onmouseover = function(){ \r\n    updatePos( this ); \r\n}; \r\n  \r\n// Если пользователь произвел щелчок, \r\nli[i].onclick = function(){ \r\n    // добавить имя пользователя к полю ввода \r\n    addUser( this ); \r\n  \r\n    // и вернуть фокус на это поле \r\n    id(\"to\").focus(); \r\n};  \r\nТеперь, когда реализованы все перемещения, нужно завершить работу над основными компонентами \r\nпоиска автозаполнения. Окончательный результат нашей работы показан в следующем разделе.  \r\nОкончательный результат \r\nМы завершили создание всех компонентов, необходимых для поиска автозаполнения: отслеживания \r\nпользовательского ввода, связь с сервером, и перемещение по результатам. Настало время связать все это \r\nвоедино и поместить на страницу. В листинге 12.9 показан окончательный код JavaScript для полноценного \r\nпоиска автозаполнения.  \r\nЛистинг 12.9. Полный код JavaScript для поиска автозаполнения  \r\ndomReady(function(){ \r\n    // Обеспечение скрытия всплывающих результатов в начале работы \r\n    hide( id(\"results\") ); \r\n  \r\n    // Отслеживание уже введенных имен пользователей \r\n    var doneUsers = {}; \r\n  \r\n    // Отслеживание выбранного на данный момент пользователя \r\n    var curPos; \r\n","\r\n 245\r\n  \r\n    // Создание изображения индикации загрузки \r\n    var img = document.createElement(\"img\"); \r\n    img.src = \"indicator.gif\"; \r\n    img.id = \"qloading\"; \r\n  \r\n    // и добавление его к документу сразу за полем ввода \r\n    id(\"to\").parentNode.insertBefore( img, id(\"to\") ); \r\n  \r\n    // Создание области отображения результатов \r\n    var div = document.createElement(\"div\"); \r\n    div.id = \"results\"; \r\n    div.innerHTML = \"<div class='suggest'>Suggestions:</div><ul></ul>\"; \r\n  \r\n    // и добавление ее за полем ввода \r\n    id(\"to\").parentNode.appendChild( div ); \r\n  \r\n    // Отслеживание ввода в поле \r\n    id(\"to\").onkeypress = function(e){ \r\n       // Получение всех пользователей из набора результатов \r\n       var li = id(\"results\").getElementsByTagName(\"li\"); \r\n  \r\n       // Если нажата клавиша [TAB] или [Enter] \r\n       if ( e.keyCode == 9 || e.keyCode == 13 ) { \r\n           // Перезапуск списка текущих пользователей \r\n           loadDone(); \r\n  \r\n           // Если текущий выбранный пользователь отсутствует в списке \r\n           // выбранных, добавление его к полю ввода \r\n           if ( !doneUsers[ curPos.id ] ) \r\n               addUser( curPos ); \r\n  \r\n           // Отключение обычной реакции на нажатие клавиши \r\n           e.preventDefault(); \r\n           return false; \r\n  \r\n       // Если нажата клавиша вверх \r\n       } else if ( e.keyCode == 38 ) \r\n           // Выбор предыдущего пользователя, или последнего пользователя \r\n           // если мы находимся в начале списка) \r\n           return updatePos( curPos.previousSibling || \r\n                                            li[ li.length - 1 ] ); \r\n  \r\n       // Если нажата клавиша вниз \r\n       else if ( e.keyCode == 40 ) \r\n           // Выбор предыдущего пользователя, или последнего пользователя \r\n           // если мы находимся в начале списка) \r\n           return updatePos( curPos.nextSibling || li[0] ); \r\n","\r\n 246\r\n       }; \r\n  \r\n       // Инициализация задержки проверки ввода в поле \r\n       delayedInput({ \r\n           // Прикрепление к полю текстового ввода \r\n           elem: id(\"to\"), \r\n  \r\n           // Мы намереваемся приступить к поиску только после ввода \r\n           // одного символа \r\n           chars: 1, \r\n  \r\n           // Когда текстовое поле теряет фокус, закрыть всплывающие \r\n           // результаты \r\n           focus: true, \r\n  \r\n           // Обработка момента открытия всплывающего результата \r\n           open: function(q,open){ \r\n               // Извлечение последнего слова из списка слов, разделенных \r\n               // запятыми \r\n               var w = trim( q.substr( q.lastIndexOf(',')+1, q.length ) ); \r\n  \r\n               // Обеспечение того, что мы работаем как минимум со словом \r\n               if ( w ) { \r\n                   // Отображение анимации, свидетельствующей о загрузке \r\n                  show( id(\"qloading\") ); \r\n  \r\n                  // Обеспечение, что ни один пользователь пока не \r\nвыбран                           curPos = null; \r\n  \r\n                  // Получение UL, предназначенного для хранения всех \r\n                  // результатов \r\n                  var results = id(\"results\").lastChild; \r\n  \r\n                  // и его очистка \r\n                  results.innerHTML = \"\"; \r\n  \r\n                  // Создание запроса новых данных \r\n                  ajax({ \r\n                      // Создание простого GET-запроса к \r\n                      // CGI-сценарию, возвращающему \r\n                      // HTML-блок с LI-элементами \r\n                      type: \"GET\", \r\n                      url: \"auto.cgi?q=\" + w, \r\n  \r\n                      // Отслеживание поступления HTML \r\n                      onSuccess: function(html){ \r\n                          // Его вставка в UL результатов \r\n                          results.innerHTML = html; \r\n","\r\n 247\r\n  \r\n                          // И скрытие загрузочной анимации \r\n                          hide( id(\"qloading\") ); \r\n  \r\n                          // Повторная инициализация списка получаемых \r\n                          // имен пользователей \r\n                          loadDone(); \r\n  \r\n                          // Последовательный перебор каждого \r\n                          // возвращенного имени пользователя \r\n                          var li = results.getElementsByTagName( \"li\" ); \r\n                          for ( var i = 0; i < li.length; i++ ) { \r\n  \r\n                             // Если мы уже добавили пользователя, \r\n                             // удаление связанного с ним элемента LI            \r\n                                   if ( doneUsers [ li[i].id ] ) \r\n                                 results.removeChild( li[i--] ); \r\n                             \r\n                             // Иначе привязка события к li с именем \r\n                             // пользователя   \r\n                             else { \r\n                                 // Как только указатель мыши \r\n                                 // пользователя проходит над li, \r\n                                 // установка связанного с ним имени \r\n                                 // текущим именем пользователя \r\n                                 li[i].onmouseover = function(){ \r\n                                     updatePos( this ); \r\n                                 }; \r\n  \r\n                                 // При щелчке на имени пользователя \r\n                                 li[i].onclick = function(){ \r\n                                     // Добавление имени в поле ввода \r\n                                     addUser( this ); \r\n  \r\n                                     // и возврат фокуса на поле ввода \r\n                                     id(\"q\").focus(); \r\n                                 }; \r\n                             } \r\n                          } \r\n  \r\n                          // Проход по списку имен пользователей \r\n                          li = results.getElementsByTagName( \"li\" ); \r\n  \r\n                          // Если имен не осталось (они все уже добавлены) \r\n                          if ( li.length == 0 ) \r\n                             // скрытие результатов \r\n                             hide( id(\"results\") ); \r\n  \r\n","\r\n 248\r\n                          else { \r\n  \r\n                             // Добавление к каждому оставшемуся \r\n                             // элементу имен пользователей классов \r\n                             // 'odd', чтобы придать списку \r\n                             // «полосатый» вид \r\n                             for ( var i = 1; i < li.length; i += 2 ) \r\n                                 addClass( li[i], \"odd\" ); \r\n  \r\n                             // Установка текущего выбранного имени \r\n                             // пользователя на первый элемент списка \r\n                             updatePos( li[0] ); \r\n  \r\n                             // и отображение результатов \r\n                              show( id(\"results\") ); \r\n                          } \r\n                      } \r\n                  }); \r\n               } \r\n           }, \r\n  \r\n           // Теперь всплывающие результаты должны быть скрыты \r\n           close: function(){ \r\n               // Скрытие набора результатов \r\n               hide( id(\"results\") ); \r\n           } \r\n       }); \r\n  \r\n       function trim(s) { \r\n           return s.replace(/^\\s+/,\"\").replace(/\\s+$/, \"\"); \r\n       } \r\n  \r\n       // Изменение подсветки текущего выбранного имени пользователя \r\n       function updatePos( elem ) { \r\n           // Обновление позиции текущего выбранного элемента \r\n           curPos = elem; \r\n  \r\n           // Получение всех li-элементов с именами пользователей \r\n           var li = id(\"results\").getElementsByTagName(\"li\"); \r\n  \r\n           // Удаления класса 'cur' из текущего выбранного элемента \r\n           for ( var i = 0; i < li.length; i++ ) \r\n               removeClass( li[i], \"cur\" ); \r\n  \r\n           // И добавление подсветки на текущий элемент имени \r\n           // пользователя \r\n           addClass( curPos, \"cur\" ); \r\n  \r\n","\r\n 249\r\n           return false; \r\n  \r\n       } \r\n  \r\n       // Повторная инициализация списка имен пользователей, который уже \r\n       // добавлен пользователем в поле ввода \r\n  \r\n       function loadDone() { \r\n           doneUsers = {}; \r\n  \r\n       // Проход по списку имен пользователей (разделенных запятыми) \r\n       var users = id(\"q\").value.split(','); \r\n       for ( var i = 0; i < users.length; i++ ) { \r\n  \r\n           // Сохранение имени пользователя (в качестве ключа) в \r\n           // хэш-объекте \r\n           doneUsers[ trim( users[i].toLowerCase() ) ] = true; \r\n       } \r\n    } \r\n  \r\n    // Добавление имени пользователя к полю ввода текста \r\n    function addUser( elem ) { \r\n       // Текстовое значение из поля ввода текста \r\n       var v = id(\"to\").value; \r\n  \r\n       // Добавление имени пользователя в конец содержимого поля ввода, \r\n       // обеспечение его отделения знаком запятой \r\n       id(\"to\").value = \r\n        ( v.indexOf(',') >= 0 ? v.substr(0, v.lastIndexOf(',') + 2 ) : '' ) \r\n        + elem.id + \", \"; \r\n  \r\n       // Добавление имени пользователя к основному списку \r\n       // (избавляющего от необходимости полной перезагрузки списка) \r\n       doneUsers[ elem.id ] = true; \r\n  \r\n       // Удаление li-элемента с именем пользователя \r\n       elem.parentNode.removeChild( elem ); \r\n  \r\n       // и скрытие списка результатов \r\n       hide( id(\"results\") ); \r\n    } \r\n});  \r\nНа рис. 12.6 показано, как выглядит окончательный результат.  \r\n","\r\n 250\r\n \r\nРис. 12.6. Копия экрана  поиска автозаполнения в действии при завершении выбора второго имени \r\nпользователя \r\nОкончательный результат выглядит впечатляющим и весьма полезным в применении. Основные концепции \r\nпоиска автозаполнения не отличаются особой сложностью или трудностью реализации, но собранные воедино они \r\nдают очень хороший интерактивный результат.  \r\nВывод \r\nПоиск автозаполнения создан в качестве хорошего дополнения практически к любому приложению. При \r\nэтом появляется возможность помочь пользователю с вводом данных при работе почти с каждым текстовым полем.  \r\nВ этой главе я охватил все аспекты создания поиска автозаполнения для ввода пользовательских имен в \r\nпростую форму. Отдельно было рассмотрено, как захватить ввод текста пользователем, послать запрос сценарию \r\nна стороне сервера, забрать  назад соответствующие данные и дать возможность пользователю осуществлять \r\nпереход по результатам. Использование концепций, представленных в этой главе, и их адаптация к вашему \r\nконкретному случаю, принесет вашим пользователям весьма ощутимые выгоды.  \r\nРабочая демонстрация этого примера, а также подробные инструкции по настройке оборудования на \r\nстороне сервера доступны на веб-сайте этой книги http://www.jspro.org/. Исходный код как всегда доступен в \r\nразделе Source Code/Download веб-сайта Apress http://www.apress.com. \r\n","\r\n 251\r\nГлава  13 Ajax Wiki \r\nПоявление на переднем крае веб-разработки различных исполнительных сред, основанных на концепции \r\nмодель-представление-контроллер — MVC (к примеру Ruby on Rails и Django), навело меня на мысль, что настало \r\nвремя рассмотреть некоторые альтернативные языки программирования, используемые для разработки веб-\r\nприложений. В качестве примера, исследуемого в этой главе я выбрал простую  браузерную wiki.  \r\nЧто такое Wiki? \r\nВ соответствии с Wikipedia.org (бесспорно, самым популярным веб-сайтом, основанным на wiki-\r\nтехнологии), wiki — это разновидность веб-сайта, позволяющая любому посетителю быстро и просто добавлять, \r\nудалять, или же редактировать все содержимое, причем для этого иногда не требуется даже регистрации. \r\nПростота взаимодействия и работы превращает wiki в весьма эффективный инструмент для совместного создания \r\nписьменного материала.  \r\nКроме этого для пользовательской настройки wiki-записей предоставляется целая подборка средств \r\nформатирования. На рис. 13.1 показана главная страница wiki после нескольких правок, внесенных различными \r\nпользователями.  \r\nУникальность этого конкретного примера заключается в том, что логика движка wiki целиком написана на \r\nJavaScript, именно код JavaScript посылает запросы к базе данных непосредственно на сервер. Этот учебный \r\nпример демонстрирует ряд основных концепций, необходимых для разработки современных веб-приложений, \r\nдаже при том, что на сервере отсутствует обычная логика приложения.  \r\nСамо приложение разбивается на три части: клиентскую, серверную и базу данных (как и в случаях с \r\nбольшинством Ajax-приложений), каждая из которых будет подробно рассмотрена. Клиентская часть отвечает за \r\nвзаимодействие с пользователем и за управление интерфейсом. Серверная часть отвечает за управление связью \r\nмежду клиентской частью и источником данных.  \r\nЧтобы стало понятным, для чего конкретно предназначено это приложение, на что оно способно, и как \r\nработает, я собираюсь провести вас по каждой его особенности, и объяснить, как код этого приложения можно \r\nбудет использовать в своих собственных разработках.  \r\n","\r\n 252\r\n \r\nРис. 13.1. Копия экрана, демонстрирующая wiki в действии \r\nОбращение к базе данных \r\nКаждая страница wiki должна быть кем-то создана и отредактирована. Это означает, что нам нужно где-то \r\nхранить все предоставленное пользователем содержимое, чтобы в дальнейшем получить к нему доступ. Наверное, \r\nнаиболее правильным решением будет создание простой базы данных, в которой можно будет хранить все свои \r\nданные. Чтобы дать возможность клиентской стороне, написанной на JavaScript, обращаться к базе данных, нам \r\nнужно иметь на серверной стороне какой-нибудь код, занимающий место между клиентским кодом и базой данных \r\nwiki. На рис. 13.2 показано, как выглядит прохождение каждого запроса к базе данных. Этот процесс является \r\nобщим для всех форм выполняемых операций (например, SELECT, INSERT и т.д.).  \r\nСвязь клиентской стороны с базой данных нужна будет в двух случаях. Во-первых, для  запроса к базе \r\nданных и извлечения всех правок конкретной страницы. Во-вторых, когда мы вставляем в базу данные новой \r\nправки. Порядок прохождения обоих этих запросов фактически один и тот же, что облегчает создание общего, \r\nупрощенного уровня связи, который может быть использован и в других JavaScript-приложениях. Еще одной \r\nприятной особенностью общего уровня связи является возможность легко пройти по всей технологической \r\nцепочке связи (показанной на рис. 13.2) и посмотреть, как JavaScript может связываться с базой данных.  \r\n","\r\n 253\r\n \r\nРис. 13.2. Технологический процесс, используемый в приложении для выполнения запроса от клиента \r\nВНИМАНИЕ \r\nВажно понимать, что отправлять обычные SQL-запросы от клиента к серверу не следует; подобные \r\nдействия открывают путь для злоумышленников, атакующих сервер и базу данных. Именно из-за этого в нашем \r\nприложении все SQL-запросы отображены ключевыми словами, которые превращаются в действующие запросы на \r\nсерверной стороне. Таким образом мы получаем большую гибкость на стороне клиента, уберегая базу данных от \r\nатак.  \r\nЧтобы понять, как работает эта технологическая цепочка, мы пройдем по всему процессу  создания \r\nзапроса от JavaScript клиента к серверу и базе данных.  \r\nAjax-запрос \r\nAjax-запрос осуществляется при необходимости связи с базой данных (и, соответственно, с сервером). К \r\nпримеру, Ajax-запрос осуществляется, если нужно сохранить правку, внесенную в wiki. Правка состоит из четырех \r\nинформационных частей:  \r\nЗаголовка wiki-страницы: Общее соглашение об наименовании wiki-страниц использует так называемую \r\nсхему CamelCase (двугорбого верблюда), которая заключается в соединении воедино слов, начинающихся с \r\nбольшой буквы. Например, главная страница нашего wiki именуется HomePage. \r\nИмени автора правки: Пользователи вносящие правки, могут указать свое  имя. Но, если они захотят, то \r\nмогут сохранить анонимность (столь популярную во многих wiki-проектах).  \r\nСамого текста правки: Это потенциально объемный текст, вводимый пользователем. Содержимое \r\nотформатировано с помощью распространенной системы форматирования текста Textile.  \r\nТочного времени внесения правки: Оно генерируется на стороне клиента и (будем надеяться) \r\nиспользуется в качестве уникального идентификатора. Поскольку время дается с точностью до миллисекунд, для \r\nнашего приложения этого будет вполне достаточно.  \r\nТеперь, используя все эти части данных, мы можем построить запрос, посылаемый к базе данных. \r\nУпрощенная версия кода, необходимого для сохранения правки показана в листинге 13.1.  \r\nЛистинг 13.1. Код, необходимый для сохранения данных, полученных от клиента, в базе данных на \r\nстороне сервера  \r\n// Вставка правки в базу данных \r\nsqlExec( \r\n    // Оператор запроса, действующий код которого хранится на сервере \r\n","\r\n 254\r\n    \"insert\", \r\n    [ \r\n       document.title, // Заголовок записи \r\n       $(\"#author\").val(), // Имя автора, предоставленное пользователем \r\n       $(\"#text\").val(), // Текст правки \r\n       (new Date()).getTime() // Точное время правки \r\n    ], \r\n    // После выполнения запроса — перезагрузка списка правок \r\n    reload \r\n); \r\nВслед за функцией sqlExec происходит подготовка SQL-запроса (который затем превращается в строку \r\nCGI-запроса), построение URL для запроса, и создание Ajax-запроса. Для объединения всего этого в единое целое \r\nмы воспользуемся возможностями Ajax-библиотеки jQuery, которая может обрабатывать HTTP POST-запросы \r\n(POST-запрос необходим для отправки длинного текста правки). Окончательный вариант Ajax-запроса мы увидим \r\nв разделе «Обработка JSON-ответа».  \r\nОтправив запрос на сервер, нужно посмотреть, как запрос к базе данных обрабатывается на стороне \r\nсервера.  \r\nКод на стороне сервера \r\nСерверная часть приложения имеет очень простую и легко воспроизводимую логику. Общая задача \r\nсостоит в получении от клиента SQL-запроса, выполнении его в базе данных SQL и возвращении результатов в \r\nвиде JSON-строки. Чтобы воплотить это приложение в жизнь, я решил усовершенствовать его логику и \r\nразработать дубликаты рабочих версий на всех популярных языках сценариев: Perl, PHP, Python и Ruby. Я \r\nпредполагаю, что вам приходилось иметь дело по крайней мере с одним из этих языков; а если нет, то у вас будет \r\nпрекрасная возможность ознакомиться с ними на нашем примере.  \r\nОбработка запроса \r\nКлиентская часть только что инициировала связь с серверной частью приложения,  требуя выполнения \r\nSQL-запроса к базе данных. Доступ к этому запросу и к имени базы данных, на которой он должен быть \r\nвыполнен, можно получить через обращение к CGI-параметрам, переданным приложению. В предыдущем разделе \r\nмы видели, что сценарию на серверной стороне передаются два параметра: имя базы данных и текст SQL-\r\nзапроса. Чтобы понять, как извлекаются параметры, в листинге 13.2 показано, как это делается в версии кода на \r\nстороне сервера, написанном на языке Ruby.  \r\nЛистинг 13.2. Извлечение CGI-параметров, переданных серверной части приложения, написанной на Ruby \r\n# Импорт CGI-библиотеки \r\nrequire 'cgi' \r\n  \r\n# Создание нового CGI-объекта, который проведет разбор \r\n# входящих CGI-параметров \r\ncgi = CGI.new \r\n  \r\n# Захват параметров запроса \r\nsql = cgi['sql'] \r\n  \r\n# Получение от пользователя имени базы данных, \r\n","\r\n 255\r\n# и обеспечение отсутствия в них злонамеренно \r\n# вставленных символов \r\nd = cgi['db'].gsub(/[^a-zA-Z0-9_-]/, \"\")  \r\nТеперь, используя извлеченные имя базы данных и запрос, нужно подключиться к базе данных, и тут \r\nвозникает вопрос, каким типом базы данных воспользоваться. Я уже решил использовать базу данных на основе \r\nSQL (поскольку это уже стало распространенным стандартом при разработке веб-приложений). Для нашего \r\nприложения я решил воспользоваться базой данных SQL под названием SQLite.  \r\nSQLite является весьма перспективной реализацией базы данных SQL, обладающей невероятной \r\nлегковесностью и быстротой работы. Ради простоты и скорости работы в ней пришлось пожертвовать такими \r\nпонятиями, как пользователи, роли и полномочия доступа. Для нашего приложения она подходит как нельзя \r\nлучше. SQLite работает, запускаясь из одного файла на вашей системе, поэтому у вас может быть столько баз \r\nданных, сколько имеется файлов. Кроме быстроты работы, SQLite служит быстрым и простым способом установки \r\nбазы данных для простых приложений или проведения тестирования. SQLite даст все, что нужно, избавляя от \r\nнеобходимости устанавливать большие базы данных (такие как MySQL, PostgreSQL или Oracle).  \r\nВсе исследованные мной языки (Perl, PHP, Python и Ruby) тем или иным способом поддерживали SQLite:  \r\n• В Perl имеется модуль DBD::SQLite. Этот модуль особенно примечателен, поскольку разработчики решили \r\nполностью реализовать спецификацию SQLite внутри самого модуля, а это значит, что для доступа к базе \r\nданных и ее запуска не требуется никаких дополнительных загрузок.  \r\n• PHP 5 имеет встроенную поддержку SQLite. К сожалению этот язык поддерживает только SQLite 2 (который \r\nвполне подойдет для некоторых приложений), но чтобы получить полную совместимость между \r\nразличными кодовыми основами, вместо этого нужно установить библиотеку  PHP SQLite 3.  \r\n• И Python и Ruby имеют библиотеки SQLite, которые становятся доступными при официальной установке \r\nSQLite. У Python 2.5 есть поддержка SQLite, встроенная прямо в язык (но я не решился ее использовать из-\r\nза ее относительной новизны).  \r\nЯ настоятельно рекомендую, чтобы в каком-нибудь из своих небольших проектов вы исследовали \r\nприменение SQLite. Это будет отличным способом его подготовки и запуска, если вам не нужны издержки \r\nустановки большой базы данных.  \r\nСпособ подключения к базе данных SQLite во всех языках практически одинаков. Все они требуют для \r\nэтого выполнить два шага: во-первых, включить в код библиотеку SQLite (предоставляющую универсальные \r\nфункции подключения), и во-вторых, подключиться к базе данных и запомнить это подключение для дальнейшего \r\nиспользования.  \r\nВ листинге 13.3 показано, как это делается в Ruby.  \r\nЛистинг 13.3. Импорт внешней библиотеки SQLite и подключение к базе данных в Ruby-версии серверного \r\nкода  \r\n# Импорт внешней SQLite-библиотеки \r\nrequire 'rubygems' \r\nrequire_gem 'sqlite3-ruby' \r\n  \r\n# Далее в программе ...; \r\n  \r\n# 'd' нужно очистить, чтобы гарантировать отсутствие зловредных символов, \r\n# предоставленных вместе с именем файла базы данных \r\n","\r\n 256\r\nd = cgi['db'].gsub(/[^a-zA-Z0-9_-]/, \"\") \r\n  \r\n# Подключение к базе данных SQLite, которая является простым файлом \r\n# 'd' содержит имя базы данных — 'wiki' \r\ndb = SQLite3::Database.new('../../data/' + d + '.db') \r\nТеперь, имея открытое подключение к базе данных SQLite, мы можем выполнить запрос, отправленный со \r\nстороны клиента, и получить результаты.  \r\nВыполнение и форматирование SQL \r\nПосле того, как подключение к базе данных открыто, мы можем выполнить SQL-запрос. Конечная цель \r\nзаключается в возможности поместить результаты запроса в форму, которая может быть легко преобразована в \r\nJSON-строку и возвращена клиенту. Наипростейшей удобной формой для SQL-результатов является массив хэшей, \r\nкоторый выглядит подобно коду, представленному в листинге 13.4. Каждый хэш представляет соответствующую \r\nстроку базы данных. Каждая пара хеша ключ-значение представляет имя столбца и его значение в строке.  \r\nЛистинг 13.4. Пример JSON-структуры, возвращенной с сервера  \r\n[ \r\n    { \r\n       title: \"HomePage\", \r\n       author: \"John\", \r\n       content: \"Welcome to my wonderful wiki!\", \r\n       date: \"20060324122514\" \r\n    }, \r\n  \r\n    { \r\n       title: \"Test\", \r\n       author: \"Anonymous\", \r\n       content: \"Lorem ipsum dolem...;\", \r\n       date: \"20060321101345\" \r\n    }, \r\n    . . . \r\n]  \r\nСложность помещения SQL-результатов в желаемую структуру варьируется в зависимости от выбранного \r\nвами языка. Но в большинстве случаев SQL-библиотека возвращает две вещи: массив имен столбцов, и массив \r\nмассивов, содержащий все данные строки (см. листинг 13.5).  \r\nЛистинг 13.5. Структура данных, возвращенная в результате выполнения SQL-запроса информации о \r\nправке, внесенной в Wiki, выраженная на языке Ruby \r\nrows.columns = [\"title\",\"author\",\"content\",\"date\"] \r\n  \r\nrows = [ \r\n    [\"HomePage\",\"John\",\"Welcome to my wonderful wiki!\",\"20060324122514\"], \r\n    [\"Test\",\"Anonymous\",\"Lorem ipsum dolem...;\",\"20060321101345\"], \r\n    . . . \r\n] \r\n","\r\n 257\r\nПроцесс преобразования SQL-результатов, представленный в листинге 13.5, чтобы они больше походили \r\nна структуру данных, показанную в листинге 13.4, может быть более интересным. По существу, нам нужно \r\nосуществить последовательный перебор всех соответствующих строк, создать временный хэш, заполнить его \r\nвсеми данными столбцов, а затем добавить новый хэш в глобальный массив. В листинге 13.6 показано, как это \r\nделается в Ruby.  \r\nЛистинг 13.6. Как в Ruby выполняется SQL-оператор, и результаты его работы помещаются в \r\nокончательную структуру данных (названную r)  \r\n# Если в sql есть возвращаемые строки (например, выполнялся оператор SELECT) \r\ndb.query( sql ) do |rows| \r\n    # Проход по всем возвращенным строкам \r\n    rows.each do |row| \r\n       # Создание временного хэша \r\n       tmp = {} \r\n  \r\n       # Вывод столбцов массива в пары хэша ключ-значение \r\n       for i in 0 .. rows.columns.length-1 \r\n           tmp[rows.columns[i]] = row[i] \r\n       end \r\n  \r\n       # Добавление строки хэша к массиву найденных строк \r\n       r.push tmp \r\n    end \r\nend  \r\nТеперь, после того как у нас есть удобная конечная структура данных, мы можем приступить к ее \r\nпреобразованию в строку JSON. По своей сути, JSON является способом представления значений (строк и чисел), \r\nмассивов значений и хэшей (пар ключ-значение), использующим JavaScript-совместимую объектную запись. \r\nПоскольку мы позаботились о гарантии отсутствия в структуре данных всего, кроме массивов, хэшей и строк, все \r\nэто можно легко преобразовать в строку JSON-формата.  \r\nВсе языки сценариев, используемые нами для этого приложения, имеют реализацию JSON-сериализации \r\n(которая воспринимает исходную структуру данных и конвертирует ее в JSON-строку), что нам, собственно, и \r\nнужно. Кроме того, поскольку вывод очень легок, как и большинстве случаев, связанных с данными формата \r\nJSON, его очень просто вывести на браузер. Кстати, реализации на разных языках в конечном счете очень похожи \r\nдруг на друга, что значительно упрощает процесс перехода с одного языка на другой:  \r\n• Каждая реализация доступна в форме библиотеки или модуля.  \r\n• Каждая реализация способна транслировать исходные объекты языка (например, строки, массивы и хэши).  \r\n• Каждая реализация облегчает получение строки объекта формата JSON.  \r\nНо все же в Ruby реализация JSON-сериализации сделана особенно элегантно. Вот как выглядит пример \r\nпреобразования объекта в JSON-строку (после загрузки библиотеки JSON) и возвращения ее клиенту:  \r\n# Преобразование объекта (r) в JSON-строку, и ее вывод \r\nprint r.to_json  \r\nЯ настоятельно рекомендую просмотреть код серверной реализации на вашем любимом языке, и \r\nразобраться, как он обрабатывает SQL-запросы и проводит JSON-сериализацию. Я думаю, что вы будете приятно \r\nудивлены тому, насколько все это просто.  \r\n","\r\n 258\r\nОбработка JSON-ответа \r\nТеперь у нас есть ответ, полученный с сервера, который содержит отформатированную JSON-строку. \r\nВозвращаясь к листингу 13.2 теперь можно написать код, необходимый для обработки и выполнения этого JSON-\r\nкода. Чем хорош JSON, так это простотой выполнения и перемещения по его элементам. Здесь не нужен \r\nполнофункциональный парсер (как при работе с XML); все, что нужно вместо этого — функция eval() (которая \r\nвыполняет код JavaScript, чем, собственно, и является JSON-строка). В листинге 13.7 показано, что библиотека \r\njQuery, полностью берет все это на себя. Все, что для этого нужно сделать — это определить тип данных \r\n(названный dataType) как «json», и вы немедленно получите JSON-данные с сервера.  \r\nЛистинг 13.7. Получение результатов с сервера и отправка структуры данных JavaScript функции \r\nобратного вызова  \r\n// Отправка запроса на сервер \r\n$.ajax({ \r\n    // POST к API URL \r\n    type: \"POST\", \r\n    url: apiURL, \r\n  \r\n    // Сериализация массива данных \r\n    data: $.param(p), \r\n  \r\n    // Ожидается возвращение данных в формате JSON \r\n    dataType: \"json\", \r\n  \r\n    // Ожидание успешного завершения запроса \r\n    // Если пользователь определил функцию обратного вызова, \r\n    // отправить ей данные \r\n    success: callback \r\n}); \r\nЕсли вы заметили, последним совершаемым действием в листинге 13.7 было выполнение функции под \r\nназванием callback (которая указывает на ту функцию обратного вызова, которая предоставлена функции \r\nsqlExec). Единственным аргументом, передаваемым этой функции является полная структура данных, так \r\nтщательно выстроенная на сервере и выставленная клиенту. Чтобы понять, как работает полный технологический \r\nпроцесс sqlExec-Ajax-ответ, посмотрите на показанную в листинге 13.8 упрощенную версию всего, что реально \r\nпроисходит в wiki. Логика состоит в том, что если для страницы есть правка, то должна быть показан ее самый \r\nпоследний вариант. А если правки не существует, форма должна быть отображена так, чтобы пользователь мог \r\nсоздать новую правку. \r\nЛистинг 13.8. Упрощенная форма кода, используемого на стороне клиента для извлечения правки с \r\nсервера  и отображения ее на веб-сайте  \r\n// Запрос всех правок для текущей wiki-страницы \r\n// После загрузки возвращение данных функции 'loaded' \r\nsqlExec(\"select\", [$s], loaded); \r\n  \r\n// Обработка SQL-результатов, возвращенных с сервера \r\nfunction loaded(sql) { \r\n    // Если для этой wiki правка существует \r\n    if ( sql.length > 0 ) { \r\n","\r\n 259\r\n       // Показать wiki-страницу \r\n       showContent(); \r\n       // Представление правки с использованием textile \r\n       $(\"#content\").html(textile(sql[0].content)); \r\n       // Включение возможности редактирования содержимого правки \r\n       $(\"textarea\").val( sql[0].content ); \r\n       // А если правки не существует, показать форму 'create me' \r\n    } else { \r\n       // Отображение исходной формы для редактирования \r\n       showForm(); \r\n    } \r\n}  \r\nВажной частью кода, показанного в листинге 13.8, является краткий фрагмент textile(sql[0].content), \r\nкоторый выхватывает wiki-правку из структуры данных и запускает для его обработки систему форматирования \r\nTextile. Многое в HTML зависит от  оформления содержимого, чем как раз и занимается Textile. Это очень простое \r\nсредство, предоставляющее базовое, вполне понятное форматирование для любых случаев. Пример Textile-\r\nформатирования показан на рис. 13.3.  \r\n \r\nРис. 13.3. Wiki-правка, использующая Textile-форматирование \r\nНо одной из привлекательных сторон Textile является то, что кто-то уже выполнил всю трудную работу, и \r\nсоздал библиотеку Textile JavaScript, которая способна превращать отформатированный Textile текст в итоговый, \r\nпрезентабельный HTML. Более подробная информация о Textile может быть найдена на следующих веб-сайтах:  \r\n• Обзор Textile: http://www.textism.com/tools/textile/  \r\n• JavaScript-реализация Textile (использованная в этом проекте): http://jrm.cc/extras/live-textile-preview.php \r\nТеперь, когда данные вернулись с сервера отформатированными и вставленными в документ, у вас есть \r\nвсе необходимое для полноценной wiki-системы. С этого момента я рекомендую вам установить свою собственную \r\nкопию wiki-кода и посмотреть его в работе. Он подробно откомментирован, поэтому с ним можно будет легко \r\nсправиться, не испытывая каких-либо стрессов.  \r\nДополнительный учебный пример: JavaScript блог \r\nЕсли вы интересуетесь тем, что еще может быть сделано с помощью этой связки клиент-сервер-SQLite, то я \r\nсоздал еще одну демонстрационную программу, которую вы можете совершенно свободно изучить. Это \r\nприложение представляет собой простой, персональный браузерный блог. Тем не менее он очень удобен; при \r\nпосещении страницы вы получаете свой собственный персональный блог, который вы можете просматривать и \r\nвести. Кроме этого, в нем есть настоящий предварительный просмотр публикации и небольшая SQL-консоль, с \r\n","\r\n 260\r\nкоторой будет интересно познакомиться. Код вместе с демонстрационным блог-приложением находится на веб-\r\nсайте книги (http://jspro.org/). Копия экрана работающего блога показана на рис. 13.4.  \r\n \r\nРис. 13.4. Копия экрана браузерного блога и SQL-консоли \r\nКод приложения \r\nОбучающий пример, представленный в этой главе намного сложнее, чем только что \r\nпродемонстрированный. В этом разделе приводится подробный исходный код, необходимый для запуска нашего \r\nприложения (который имеет непосредственное отношение ко всему, что рассматривается в этой главе).  \r\nТеперь посмотрим на список файлов, необходимых для приведения в действие нашего wiki-приложения. \r\nОн представляет собой  сборник кода клиентской и серверной сторон, рассмотренного в этой главе, дополненный \r\nразличными библиотеками и файлами стилей, которые в ней напрямую не упоминались:  \r\n• index.html: Главная страница приложения, в которой собран воедино весь код клиентской стороны.  \r\n• install.html: Главный установочный файл, который запускается перед первым использованием \r\nприложения.  \r\n• css/style.css: Стилевое CSS-оформление для клиентской стороны приложения.  \r\n• js/wiki.js (см. листинг 13.9): Основной код JavaScript, отвечающий за привязку событий и запуск SQL-\r\nзапросов.  \r\n• js/sql.js (см. листинг 13.10): Код, отвечающий за связь с сервером, извлекающий JSON-данные, \r\nвозвращаемые SQL-запросами.  \r\n• js/textile.js: Копия библиотеки JavaScript Textile (для преобразования текста в HTML): \r\nhttp://jrm.cc/extras/live-textile-preview.php.  \r\n","\r\n 261\r\n• js/jquery.js: Копия текущей версии jQuery: http://jquery.com/.  \r\n• api/: Основной серверный код, отвечающий за преобразование результатов SQL-запроса в JSON и \r\nвозвращения их клиенту. Этот каталог содержит все версии когда: на Perl, PHP, Python и Ruby. Я уже \r\nвключил копию Ruby-версии кода в листинг 13.11.  \r\n• data/wiki.db: База данных SQLite, в которой хранится wiki.  \r\nПолный код файлов этой главы приведен в следующих листингах.  \r\nОсновной код JavaScript \r\nВ листинге 13.9 показан wiki.js, основной код JavaScript, отвечающий за привязку событий и \r\nвзаимодействие с пользователем.  \r\nЛистинг 13.9. js/wiki.js  \r\n// Получение имени текущей страницы \r\nvar $s = window.location.search; \r\n$s = $s.substr(1,$s.length); \r\n  \r\n// Определение, предоставлен ли номер правки, и если \r\n// предоставлен, то запомнить его ID \r\nvar $r = false; \r\n  \r\n// Правки предоставляются в формате \r\n// ?Title&RevisionID \r\nvar tmp = $s.split(\"&\"); \r\nif ( tmp.length > 1 ) { \r\n    $s = tmp[0]; \r\n    $r = tmp[1]; \r\n} \r\n  \r\n// Если страница не предоставлена, переход на начальную страницу \r\nif (!$s) window.location = \"?HomePage\"; \r\n  \r\n// Установка имени базы данных \r\nvar db = \"wiki\"; \r\n  \r\n// Нужно дождаться окончания загрузки DOM \r\n$(document).ready(function(){ \r\n  \r\n    // Установка заголовка страницы \r\n    document.title = $s; \r\n    $(\"h1\").html($s); \r\n  \r\n    // Загрузка всех wiki-правок \r\n    reload(); \r\n  \r\n    // Если произведен щелчок на ссылке \r\n    // 'edit page' (редактировать страницу) \r\n    $(\"#edit\").click(showForm); \r\n","\r\n 262\r\n  \r\n    // Когда пользователь отправляет новую правку \r\n    $(\"#post form\").submit(function(){ \r\n       // Получение имени автора \r\n       var author = $(\"#author\").val(); \r\n  \r\n       // Получение текста \r\n       var text = $(\"#text\").val(); \r\n  \r\n       // Отображение содержимого \r\n       $(\"#content\").html(textile(text)); \r\n  \r\n       // Предоставление времени текущей правки \r\n       // (которое поможет ее выделению) \r\n       $r = (new Date()).getTime(); \r\n  \r\n       // Вставка правки в базу данных \r\n       sqlExec(\"insert\", [$s,author,text,$r], reload); \r\n  \r\n       return false; \r\n    }); \r\n  \r\n    // Если пользователь щелкнул на ссылке 'cancel' (Отмена) \r\n    // внутри области редактирования \r\n    $(\"#cancel\").click(showContent); \r\n}); \r\n  \r\n// Отображение текущей версии правки \r\nfunction showContent() { \r\n    // Отображение ссылки на редактирование \r\n    $(\"#edit,#cancel\").css(\"display\",\"inline\"); \r\n  \r\n    // Скрытие область редактирования \r\n    $(\"#post\").hide(); \r\n  \r\n    // Отображение содержимого \r\n    $(\"#content\").show(); \r\n    return false; \r\n} \r\n  \r\n// Отображение формы редактирования текущего варианта правки \r\nfunction showForm() { \r\n    // Скрытие ссылки на редактирование \r\n    $(\"#edit\").hide(); \r\n  \r\n    // Отображение области редактирования \r\n    $(\"#post\").show(); \r\n  \r\n","\r\n 263\r\n    // Скрытие содержимого \r\n    $(\"#content\").hide(); \r\nreturn false; \r\n} \r\n  \r\n// Загрузка всех правок из базы данных \r\nfunction reload(t) { \r\n    // Запрос всех правок \r\n    sqlExec(\"select\", [$s], function(sql) { \r\n       // Если для этой wiki-страницы существуют правки \r\n       if ( sql.length > 0 ) { \r\n           if ( !$r ) $r = sql[0].date; \r\n  \r\n           // Отображение wiki-страницы \r\n           showContent(); \r\n  \r\n           // Отображение всех правок \r\n           $(\"#side ul\").html(''); \r\n  \r\n           // Проход по всем правкам \r\n           for ( var i = 0; i < sql.length; i++ ) { \r\n  \r\n               // Если эта правка является текущей отображаемой правкой \r\n               if ( sql[i].date == $r ) { \r\n  \r\n                  // Отображение правки \r\n                  $(\"#content\").html(textile(sql[i].content)); \r\n  \r\n                  // Включение возможности редактирования \r\n                  // содержимого правки \r\n                  $(\"textarea\").val( sql[i].content ); \r\n               \r\n               } \r\n  \r\n               // Получение реального объекта данных \r\n               var d = new Date( parseInt(sql[i].date) ); \r\n  \r\n               // Определение, была ли правка сделана в течение \r\n               // последних суток, или нет \r\n               if ( d.getTime() > (new Date()).getTime() - (3600 * 24000) ) \r\n  \r\n                  // Если да, формирование приемлемого отображения \r\n                  // времени создания в формате am/pm \r\n                  d = d.getHours() >= 12 ? \r\n                      (d.getHours() != 12 ? d.getHours() - 12 : 12 ) \r\n                      + \" pm\" : \r\n                      d.getHours() + \" am\"; \r\n  \r\n","\r\n 264\r\n               // В противном случае отображение месяца и дня \r\n               // правки \r\n               else { \r\n                  var a = d.toUTCString().split(\" \"); \r\n                  d = a[2] + \" \" + d.getDate(); \r\n               } \r\n  \r\n               // Добавление правки в список правок \r\n               $(\"#side ul\").append(\"<li class='\" + \r\n                                     ( $r == sql[i].date ? \"cur\" : \"\" ) \r\n                   + \"'><a href='?\" + $s + ( i > 0 ? \"&\" \r\n                                                   + sql[i].date : \"\" ) \r\n                   + \"'>\" + d + \"</a> by \" + sql[i].author + \"</li>\"); \r\n           } \r\n  \r\n       // В противном случае эта страница правке никогда не подвергалась \r\n       } else { \r\n           // Отображение этого обстоятельства на панели правки \r\n           $(\"#rev\").html(\"<li>No Revisions.</li>\"); \r\n    \r\n           // Скрытие элементов управления редактированием \r\n           $(\"#edit,#cancel\").hide(); \r\n  \r\n           // Отображение исходной формы редактирования \r\n           showForm(); \r\n       } \r\n    }); \r\n}  \r\nJavaScript SQL-библиотека \r\nВ листинге 13.10 показан файл sql.js, в котором содержится код, отвечающий за связь с сервером и \r\nизвлечение JSON-данных, полученных на основе SQL-запросов.  \r\nЛистинг 13.10. js/sql.js  \r\n// ЭТА ПЕРЕМЕННАЯ ТРЕБУЕТ ОБНОВЛЕНИЯ \r\n// URL, по которому находится сценарий на стороне сервера \r\nvar apiURL = \"api/ruby/\"; \r\n  \r\n// Некоторые заданные по умолчания глобальные переменные \r\nvar sqlLoaded = function(){} \r\n  \r\n// Обработка больших SQL-отправлений \r\n// Эта функция способна отправлять большие объемы данных \r\n// (например, большие вставки — INSERT), но она может \r\n// отправлять данные только на тот же сервер, с которым работает клиент \r\nfunction sqlExec(q, p, callback) { \r\n  \r\n    // Загрузка всех параметров в структурированный массив \r\n","\r\n 265\r\n    for ( var i = 0; i < p.length; i++ ) { \r\n       p[i] = { name: \"arg\", value: p[i] }; \r\n    } \r\n  \r\n    // Включение имени базы данных \r\n    p.push({ name: \"db\", value: db }); \r\n  \r\n    // и названия SQL-запроса, который нужно выполнить \r\n    p.push({ name: \"sql\", value: q }); \r\n  \r\n    // Отправка запроса на сервер \r\n    $.ajax({ \r\n       // POST к API URL \r\n       type: \"POST\", \r\n       url: apiURL, \r\n  \r\n       // Сериализация массива данных \r\n       data: $.param(p), \r\n  \r\n       // Ожидается возвращение данных в формате JSON \r\n       dataType: \"json\", \r\n  \r\n        // Ожидание успешного завершения запроса \r\n        // Если пользователь определил функцию обратного вызова, \r\n        // отправить ей данные \r\n       success: callback \r\n    }); \r\n}  \r\nRuby-код на стороне сервера \r\nСледующий код, показанный в листинге 13.11, представляет серверную часть Ajax-кода wiki-приложения. \r\nЭтот код целиком написан на языке программирования Ruby. Примеры такого же кода, но написанного на PHP, \r\nPerl или Python, можно найти на веб-сайте http://jspro.org/.  \r\nЛистинг 13.11. Серверная часть кода wiki-приложения, написанная на языке Ruby \r\n#!/usr/bin/env ruby \r\n  \r\n# Импорт всех внешних библиотек \r\nrequire 'cgi' \r\nrequire 'rubygems' \r\nrequire_gem 'sqlite3-ruby' \r\nrequire 'json/objects' \r\n  \r\n# Отображение заголовка Javascript \r\nprint \"Content-type: text/javascript\\n\\n\" \r\n  \r\n# Инициализация переменных приложения \r\nerr = \"\" \r\n","\r\n 266\r\nr = [] \r\ncgi = CGI.new \r\n  \r\n# Перехват параметров, переданных пользователем \r\ncall = cgi['callback'] \r\nsql = cgi['sql'] \r\n  \r\n# Получение от пользователя имени базы данных, \r\n# и обеспечение отсутствия в них злонамеренно \r\n# вставленных символов \r\nd = cgi['db'].gsub(/[^a-zA-Z0-9_-]/, \"\") \r\n  \r\n# Если имя базы данных не предоставлено, использовать имя 'test' \r\nif d == '' then \r\n    d = \"test\" \r\nend \r\n  \r\n# Получение списка параметров, помещаемых в \r\n# SQL-запрос \r\nargs = cgi.params['arg'] \r\n  \r\n# Воспринимаются только два различных SQL-запроса \r\n  \r\n# Вставка новой wiki-правки в базу данных \r\nif sql == \"insert\" then \r\n    sql = \"INSERT INTO wiki VALUES(?,?,?,?);\" \r\n  \r\n# Получение всех правок wiki-записи \r\nelsif sql == \"select\" then \r\n    sql = \"SELECT * FROM wiki WHERE title=? ORDER BY date DESC;\" \r\n  \r\n# В противном случае, отказать в запросе \r\nelse \r\n    sql = \"\" \r\nend \r\n  \r\n# Если запрос был предоставлен \r\nif sql != '' then \r\n  \r\n    # Проход по всем предоставленным параметрам \r\n    for i in 0 .. args.length-1 \r\n    # Замена всех одиночных кавычек на '' (что эквивалентно их \r\n    # дезактивации в SQLite), и дезактивация всех знаков ? \r\n    args[i] = args[i].gsub(/'/, \"''\").gsub(/\\?/, \"\\\\?\") \r\n  \r\n    # Затем проход по SQL-запросу и замена первого соответствующего \r\n    # знака вопроса данными параметров \r\n    sql = sql.sub(/([^\\\\])\\?/, \"\\\\1'\" + args[i] + \"'\") \r\n","\r\n 267\r\nend \r\n  \r\n# После того, как все сделано, снятие дезактивации со знака вопроса \r\nsql = sql.gsub(/\\\\\\?/, \"?\") \r\n  \r\n# Обеспечение захвата всех выдаваемых ошибок базы дынных \r\nbegin \r\n    # Подключение к базе данных SQLite, представляющей \r\n    # собой простой файл \r\n    db = SQLite3::Database.new('../../data/' + d + '.db') \r\n  \r\n    # Если в sql есть возвращаемые строки \r\n    # (например, выполнялся оператор SELECT) \r\n    db.query( sql ) do |rows| \r\n       # Проход по всем возвращенным строкам \r\n       rows.each do |row| \r\n           # Создание временного хэша \r\n           tmp = {} \r\n  \r\n           # Вывод столбцов массива \r\n           # в пары хэша ключ-значение \r\n           for i in 0 .. rows.columns.length-1 \r\n               tmp[rows.columns[i]] = row[i] \r\n           end \r\n  \r\n           # Добавление строки хэша к массиву найденных строк \r\n           r.push tmp \r\n       end \r\n    end \r\n  \r\n    rescue Exception => e \r\n       # Если произошла ошибка, запоминание сообщения \r\n       # для использования в будущем \r\n       err = e \r\n    end \r\nelse \r\n    # Если SQL-запрос предоставлен не был, отображение ошибки \r\n    err = \"Запрос не предоставлен.\" \r\nend \r\n  \r\n# Если произошла ошибка, возвращение хэша, содержащего \r\n# ключ error и значение, содержащее сообщение об ошибке \r\nif err != '' then \r\n    r = { \"error\" => err } \r\nend \r\n  \r\n# Преобразование возвращенного объекта в JSON-строку \r\njout = r.to_json \r\n","\r\n 268\r\n  \r\n# Если предоставлена функция обратного вызова \r\nif call != '' then \r\n    # Помещение возвращаемого объекта в строку обратного вызова \r\n    print call + \"(\" + jout + \")\" \r\nelse \r\n    # В противном случае простой вывод JSON-строки \r\n    print jout \r\nend  \r\nВывод \r\nЯ надеюсь, что при изучении нашего приложения вам удалось усвоить ряд полезных вещей. Во-первых, \r\nчто JSON является мощной и жизнеспособной альтернативой использованию XML в веб-приложениях. Во-вторых, \r\nсохраняя насколько это возможно простоту кода на серверной стороне, вы можете дать программе \r\nпользовательского интерфейса больше возможностей управления пользовательскими данными (и это надо делать \r\nумеренно, сохраняя в скрытом состоянии наиболее важную часть логики действия). И наконец, что все \r\nсовременные языки сценариев, используемые на стороне сервера могут вести себя весьма похожим образом \r\n(поскольку обладают многими сходными чертами) и с их помощью сравнительно легко осуществлять загрузку и \r\nизвлечение информации (поэтому я и написал идентичные версии  кода серверной стороны на четырех наиболее \r\nпопулярных языках сценариев).  \r\nВесь код основного приложения может быть найден в разделе «Код приложения» этой главы. Полная \r\nустановочная версия приложения может быть найдена на веб-сайте этой книги http://jspro.org/, или на веб-сайте \r\nhttp://www.apress.com/, дополненном подробной инструкцией по установке. Работоспособная демонстрационная \r\nверсия может быть найдена по адресу: http://jspro.org/demo/wiki/.  \r\nЭтот веб-сайт включает полноценные инструкции по использованию кода. Кроме этого, там же \r\nорганизован форум для обсуждения любых проблем, с которыми вы можете столкнуться при попытке создать свою \r\nсобственную установку. \r\n","\r\n 269\r\nГлава 14 В каком направлении движется JavaScript? \r\nЗа последнюю пару лет с многих направлений появилось огромное количество разработок на языке \r\nJavaScript. Mozilla Foundation значительно продвинулась в повышении качества языка JavaScript, согласовав его с \r\nECMAScript 4 (языком, на котором основан JavaScript). С другого направления действовала рабочая группа WHAT-\r\nWG, объединившая усилия производителей веб-браузеров, желающих разрабатывать новые технологии, \r\nпозволяющие создавать и развертывать приложения всемирной паутины, которая разработала спецификацию для \r\nследующего поколения приложений, основанных на использовании браузеров. И наконец, авторы библиотек и \r\nкорпорации работали над укреплением технологий потоковых браузерных приложений в средство под названием \r\nComet. Все эти новинки представляют будущее языка JavaScript и браузерных приложений.  \r\nВ этой главе мы собираемся рассмотреть усовершенствования, появившиеся в JavaScript 1.6 и 1.7, которые \r\nприближают выпуск JavaScript 2.0. Затем мы рассмотрим одно из усовершенствований, созданных в рамках \r\nспецификации Web Applications 1.0: возможность рисования с использованием JavaScript. В заключение мы \r\nрассмотрим накоротке замысел, положенный в основу Comet и потоковых веб-приложений.  \r\nJavaScript 1.6 и 1.7 \r\nС начала текущего десятилетия язык JavaScript медленно продвигался вперед, добавляя в свой арсенал \r\nфункциональные усовершенствования. Хотя многие современные браузеры поддерживают JavaScript 1.5 (или его \r\nэквивалент), они крайне слабо продвигают этот язык вперед.  \r\nБрендан Эйч (Brendan Eich) и другие специалисты Mozilla Foundation, усердно работали над продвижением \r\nязыка во взаимодействии с ECMAScript 4. Более подробная информация о работе Mozilla могут быть найдены в \r\nследующих источниках:  \r\n• Работа Mozilla над JavaScript: http://www.mozilla.org/js/language/ \r\n• Предложения Mozilla по JavaScript 2.0: http://www.mozilla.org/js/language/js20/ \r\n• Предложения Mozilla по ECMAScript 4: http://www.mozilla.org/js/language/es4/ \r\nНе дожидаясь завершения JavaScript 2.0, Mozilla посягнула на выпуск JavaScript версий 1.6 и 1.7, в \r\nкоторые включен ряд возможностей, намеченных для конечной, пересмотренной версии языка. Многие \r\nдобавленные возможности носят весьма существенный характер, и в этом разделе мы проведем их краткий обзор.  \r\nJavaScript 1.6 \r\nПервый выпуск обновленного языка JavaScript появился в виде JavaScript 1.6. Он был выпущен вместе с \r\nбраузером Firefox 1.5, созданным Mozilla Foundation. Краткий обзор изменений, внесенных в JavaScript 1.6 можно \r\nнайти на веб-сайте Mozilla: http://developer.mozilla.org/en/docs/New_in_JavaScript_1.6. \r\nВ этом выпуске появились две важные свойства: E4X (ECMAScript для XML) и набор дополнительных \r\nфункций для работы с массивами. На данный момент ни одна из этих функций не реализована ни в одном другом \r\nбраузере, но вполне возможно, что Opera и Safari будут следующими, кто окажется запрыгнет на борт этого судна. \r\nЯ покажу вам те преимущества которые имеются  у каждого из этих свойств.  \r\nECMAScript для XML (E4X) \r\nE4X добавила к языку JavaScript набор новых синтаксических элементов, дающих возможности записывать \r\nвстроенный XML прямо внутри кода JavaScript. Результат получился довольно интересный, но все же весьма \r\nсложный. Более подробную информацию о E4X можно найти в его спецификации на веб-сайте Mozilla:  \r\n• Спецификация ECMAScript для XML: http://www.ecma-international.org/publications/standards/Ecma-357.htm \r\n","\r\n 270\r\n• Краткий обзор E4X: http://developer.mozilla.org/presentations/xtech2005/e4x/ \r\nВ общем, спецификация позволяет вам использовать при написании кода JavaScript-подобный синтаксис, \r\nрезультаты которого выражаются в XML DOM. Например, если написать writing var img = <img/> + <hr/>, то \r\nпосле элемента изображения появится горизонтальная линия, а получившийся DOM-элемент будет сохранен в \r\nпеременной, которой позже можно будет воспользоваться. Более сложный пример приведен в листинге 14.1. \r\nПолучившийся XML-документ показан в листинге 14.2.  \r\nЛистинг 14.1. Построение HTML-документа с использованием E4X, взятое из презентации Брендана Эйча \r\n<script type=\"text/javascript;e4x=1\"> \r\n    // Создание HTML-элемента и сохранение его в переменной \r\n    var html = <html/>; \r\n  \r\n    // Присвоение содержимому элемента title текстовой строки \r\n    // E4X автоматически создает все пропущенные элементы и \r\n    // берет на себя создание соответствующих текстовых узлов \r\n    html.head.title = \"Заголовок моей страницы\"; \r\n  \r\n    // Установка свойства цвета фона для элемента body, \r\n    // который создается автоматически \r\n    html.body.@bgcolor = \"#e4e4e4\"; \r\n  \r\n    // И некоторых свойств к элементу form внутри элемента body \r\n    html.body.form.@name = \"myform\"; \r\n    html.body.form.@action = \"someurl.cgi\"; \r\n    html.body.form.@method = \"post\"; \r\n    html.body.form.@onclick = \"return somejs();\"; \r\n  \r\n    // Создание пустого элемента input с определенным именем \r\n    html.body.form.input[0] = \"\"; \r\n    html.body.form.input[0].@name = \"test\"; \r\n</script> \r\nЛистинг 14.2. HTML-документ, сгенерированный вызовом E4X-кода из листинга 14.1  \r\n<html> \r\n    <head> \r\n       <title>Заголовок моей страницы</title> \r\n    </head> \r\n    <body bgcolor=\"#e4e4e4\"> \r\n       <form name=\"myform\" action=\"someurl.jss\" \r\n               method=\"post\" onclick=\"return somejs();\"> \r\n           <input name=\"test\"></input> \r\n       </form> \r\n    </body> \r\n</html>  \r\n","\r\n 271\r\nХотя синтаксис для E4X довольно сильно отступает от нормального стиля   JavaScript — что может быть \r\nдостаточным, чтобы отпугнуть новичков — результат мог бы принести существенную пользу, позволяя сократить \r\nколичество повторяющихся DOM-операций.  \r\nДополнительные возможности по работе с массивами \r\nСамые важные новые свойства, добавленные в JavaScript 1.6, относятся к работе с массивами. Теперь в \r\nверсии 1.6 массивы приобрели несколько дополнительных методов, которые могут использоваться в обычных \r\nдействиях:  \r\n• Два действия, indexOf() и lastIndexOf(), похожи на одноименные методы, существующие для строковых \r\nобъектов. Они дают возможность найти позицию объекта внутри массива, возвращая соответствующий \r\nиндекс, или -1, если объект в массиве отсутствует.  \r\n• Три новых метода, forEach(), some() и many(), предназначены для упрощения общепринятых итераций, и \r\nпозволяют выполнять функцию над содержимым массива, над каждым его объектом.  \r\n• Новые функции filter() и map() позволяют проводить встроенные преобразования массива, аналогичные \r\nоперациям map и grep, существующим в других языках (например, в Perl).  \r\nПримеры использования всех новых функций JavaScript 1.6 по работе с массивами показаны в \r\nлистинге 14.3.  \r\nЛистинг 14.3. Примеры использования новых функций JavaScript 1.6, работающих с массивами  \r\n  \r\n// Простой массив чисел \r\nvar tmp = [ 1, 2, 3, 4, 5, 3 ]; \r\n  \r\n// indexOf( Объект ) \r\n// Определяет индекс объекта внутри массива объектов \r\ntmp.indexOf( 3 ) == 2 \r\ntmp.indexOf( 8 ) == -1 \r\n  \r\n// lastIndexOf( Объект ) \r\n// Определяет последний объект внутри массива объектов \r\ntmp.lastIndexOf( 3 ) == 5 \r\n  \r\n// forEach( Функция ) \r\n// Вызывает функцию для каждого имеющегося в массиве объекта. \r\n// Функции передаются три аргумента: объект, его индекс и ссылка на массив \r\ntmp.forEach( alert ); \r\n  \r\n// every( Функция ) \r\n// Вызывает функцию для каждого имеющегося в массиве объекта, если для \r\n// каждого из них будет возвращено значение true, возвращает true \r\ntmp.every(function(num){ \r\n    return num < 6; \r\n}) // true \r\n  \r\n// some( Функция ) \r\n","\r\n 272\r\n// Вызывает функцию для каждого имеющегося в массиве объекта. \r\n// Если для какого-нибудь объекта будет возвращено значение true, \r\n// возвращает true \r\ntmp.some(function(num){ \r\n    return num > 6; \r\n}) // false \r\n  \r\n// filter( Функция ) \r\n// Урезает массив до тех элементов, которые соответствуют определенным \r\n// критериям. Объект сохраняется, если функция возвращает 'true'. \r\ntmp.filter(function(num){ \r\n    return num > 3; \r\n}) // [ 4, 5 ] \r\n  \r\n// map( Функция ) \r\n// Преобразует массив объектов в другой набор объектов. Результат, \r\n// возвращенный определенной функцией, преобразует объект к его новому \r\n// значению \r\ntmp.map(function(num) { \r\n    return num + 2; \r\n}) // [ 3, 4, 5, 6, 7, 5 ]  \r\nКроме этих простых примеров, эти новые методы придают работе с массивами в JavaScript столь \r\nнеобходимую скорость и функциональность. Я конечно с нетерпением жду того дня, когда эти методы получат \r\nподдержку на всех браузерах.  \r\nJavaScript 1.7 \r\nЭтот новый выпуск языка JavaScript привнес в него много новых функциональных возможностей, добавив \r\nряд свойств, которые приблизили его к другим полнофункциональным языкам. Кроме всего прочего, новый \r\nвыпуск JavaScript 1.7, обладает еще большими усовершенствованиями, чем выпущенное ранее обновление \r\nJavaScript 1.6, в него добавлен ряд новых особенностей, изменяющих сам способ его работы. Подробности \r\nнекоторых новых свойств, доступных в         JavaScript 1.7, приведены на веб-сайте \r\nhttp://developer.mozilla.org/en/docs/New_in_JavaScript_1.7.  \r\nЭто обновление языка JavaScript было выпущено вместе с новой версией браузера Mozilla Firefox 2.0. В \r\nэтот браузер включена полная реализация всего, что будет рассмотрено в этом разделе, и только он обладает \r\nстоль значительными, современными обновлениями языка JavaScript.  \r\nВключения в массив \r\nОдно очень интересное добавление позволяет весьма стильно и ловко писать код, относящийся к \r\nгенерации массива. Раньше, чтобы заполнить массив списком элементов, нужно было последовательно перебрать \r\nнабор и поместить его элементы в конечный массив. Теперь вместо этого можно воспользоваться включением в \r\nмассив, и сделать все одним простым приемом, который поясняется на примере, показанном, в листинге 14.4.  \r\nЛистинг 14.4. Включения в массив в JavaScript 1.7  \r\n<script type=\"application/javascript;version=1.7\"> \r\n    // Старый способ помещения ряда номеров в массив \r\n    var array = []; \r\n","\r\n 273\r\n    for ( var i = 0; i < 10; i++ ) { \r\n       array.push( i ); \r\n    } \r\n  \r\n    // Новый способ \r\n    var array = [ i for ( i = 0; i < 10; i++ ) ]; \r\n  \r\n    // старый способ помещения ключей объектов в массив \r\n    var array = [] \r\n    for ( var key in obj ) { \r\n       array.push( key ); \r\n    } \r\n  \r\n    // Новый способ \r\n    var array = [ key for ( key in obj ) ]; \r\n</script>  \r\nЭта специфическая особенность языка некоторое время присутствовала в других языках (таких как \r\nPython), и приятно видеть, что она добралась и до JavaScript. \r\nУправление областью видимости переменных (Let Scoping) \r\nLet Scoping — фантастическое нововведение, которое, скорее всего, получит наиболее широкое \r\nприменение и признание. До сих пор в JavaScript не было никакой области видимости на уровне блоков (что уже \r\nрассматривалось в главе 2). С добавлением новых let-оператора, выражения и определения теперь появилась \r\nвозможность определения различных областей видимости на нескольких различных уровнях. В листинге 14.5 \r\nпоказано несколько примеров того, что можно сделать с помощью let scoping.  \r\nЛистинг 14.5. Примеры  Let Scoping в JavaScript 1.7  \r\n<script type=\"application/javascript;version=1.7\"> \r\n    // Оператор let \r\n    var test = 10; \r\n    let( test = 20 ) { \r\n       alert( test ); // выводится 20 \r\n    } \r\n    alert( test ); // выводится 10 \r\n  \r\n    // Выражение let \r\n    var test = 10; \r\n    alert( let( test = 20 ) test ); // выводится 20 \r\n    alert( test ); // выводится 10 \r\n  \r\n    // Определение let \r\n    var test = 10; \r\n    if ( test == 10 ) { \r\n       let newTest = 20; \r\n       test += newTest; \r\n    } \r\n    alert( test ); // выводится 30 \r\n","\r\n 274\r\n    alert( newTest ); // сбой, переменная newText за пределами \r\n                    //    оператора не определена \r\n  \r\n    // Использование let в блоке for \r\n    for ( let i = 0; i < 10; i++ ) { \r\n       alert( i ); \r\n    } \r\n    alert( i ); // сбой, переменная i за пределами оператора for \r\n               // не определена \r\n</script> \r\nИспользуя это простое дополнение вы можете сделать свой код понятнее, работать более эффективно и \r\nизбежать ряда общих конфликтных ситуаций, связанных с пространством имен (большая часть всего этого будет \r\nработать до введения классов и пространств имен в JavaScript 2.0).  \r\nДеструктуризация \r\nЗаключительной серьезным понятием, введенным в JavaScript 1.7, является деструктуризация \r\n(destructuring). Это понятие позаимствовано из функциональных языков программирования (в частности, в Lisp), и \r\nпозволяет иметь сложные структуры данных слева от операнда, заполненные определенными значениями.  \r\nБолее подробная информация о деструктуризации в ECMAScript 4 размещена на веб-сайте Mozilla: http:// \r\ndeveloper.mozilla.org/es4/proposals/destructuring_assignment.html.  \r\nХотя понятие деструктуризации не отличается простотой, но на то чтобы с ним разобраться безусловно \r\nстоит потратить некоторое время. В листинге 14.6 показано несколько примеров работы деструктуризации в \r\nJavaScript 1.7.  \r\nЛистинг 14.6. Примеры деструктуризации в 1.7  \r\n<script type=\"application/javascript;version=1.7\"> \r\n    // Пример использования деструктуризации для обмена значений \r\n    // двух переменных \r\n    [ b, a ] = [ a, b ] \r\n  \r\n    // Простая функция, возвращающая массив строк \r\n    function test() { \r\n       return [ \"Джон\", \"октябрь\" ]; \r\n    } \r\n  \r\n    // Мы можем деструктурировать возвращенные данные в две новые \r\n    // переменные – name и month \r\n    var [ name, month ] = test(); \r\n  \r\n    // Пример деструктуризации с использованием объекта \r\n    var { name: myName } = { name: \"Джон\" }; \r\n    // Теперь myName == \"Джон\" \r\n  \r\n    // Простая структура данных \r\n    var users = [ \r\n       { name: \"Джон\", month: \"октябрь\" }, \r\n","\r\n 275\r\n       { name: \"Боб\", month: \"декабрь\" }, \r\n       { name: \"Джейн\", month: \"май\" } \r\n    ]; \r\n  \r\n    // Деструктуризация внутри цикла \r\n    for ( let { name: name, month: month } in users ) { \r\n       // Вывод всех уведомлений для Джона, Боба и Джейн \r\n       alert( name + \" месяц рождения \" + month ); \r\n    } \r\n</script>  \r\nВ целом язык JavaScript развивается в нескольких весьма позитивных направлениях, как правило \r\nвпитывая в себя полезные качества других языков (среди которых Python и Lisp). Но большинство появляющихся \r\nв нем полезных усовершенствований зависят от тех усилий по их реализации, которые различные поставщики \r\nбраузеров вкладывают в язык. Наряду с тем, что Mozilla Foundation проявляет настойчивость в реализации новых \r\nвозможностей,  в других браузерах они развиваются довольно слабо. Хотя до начала использования JavaScript 1.6 \r\nили 1.7 в кроссбраузернах веб-приложениях должно еще пройти некоторое время, у вас есть возможность \r\nприступить к их использованию уже сейчас, разрабатывая расширения для браузеров на движке Mozilla (по \r\nкрайней мере до тех пор, пока не появится более распространенная реализация языка).  \r\nWeb Applications 1.0 \r\nВторая спецификация, продвигающая вперед JavaScript-разработку — это Web Applications 1.0, которая \r\nпринадлежит рабочей группе WHAT-WG (Web Hypertext Application Technology Working Group). Эта спецификация \r\nраспространяется на несколько различных направлений, добавляя ряд нововведений к HTML, DOM и JavaScript в \r\nцелом. Многие считают, что работа над этой спецификацией должна превратиться в HTML 5. К счастью, в отличие \r\nот новых версий JavaScript, реализации этой спецификации (или их части) заполучить намного проще.  \r\nХотя вся спецификация достаточно обширна, я все же настоятельно рекомендую вам ее прочитать и \r\nпосмотреть на новые технологии, которые уже на подходе. В этом разделе я обращу ваше внимание только на \r\nодну конкретную особенность этой новой спецификации: на элемент <canvas>. Этот новый элемент дает \r\nвозможность программным путем создавать двумерные изображения, используя JavaScript. Внедрение этой \r\nтехнологии идет очень интенсивно, облегчая ее изучение и тестирование. Дополнительная информация по Web \r\nApplications 1.0 и элементу <canvas> может быть найдена в следующих источниках:  \r\n• Полная спецификация Web Applications 1.0: http://whatwg.org/specs/web-apps/ current-work/  \r\n• Подраздел спецификации, относящийся конкретно к элементу <canvas>: http://whatwg.org/specs/web-\r\napps/current-work/#the-2d \r\n• Ряд примеров использования нового элемента <canvas>: http://developer.mozilla. \r\norg/en/docs/Canvas_tutorial:Basic_animations \r\nЭлемент <canvas> удовлетворяет запросы многих разработчиков веб-приложений, позволяя им вращать \r\nизображения, рисовать линии и создавать графические формы. Только одно это нововведение может добавить \r\nвеб-приложению совершенно новый уровень интерактивности.  \r\nПолезный эффект от возможности рисовать произвольные формы подстегнула команды, поддерживающие \r\nбраузеры, к быстрому включению Canvas API в последние выпуски их продуктов. На данный момент уже все \r\nсовременные браузеры, за исключением Internet Explorer, поддерживают Canvas API, но Google нашел подход и к \r\nэтому браузеру, и реализовал полноценный Canvas API в IE, используя исконно присущую ему поддержку VML. \r\nБолее подробная информация о ExplorerCanvas, разработанной Google реализации Canvas в Internet Explorer \r\nнаходится по адресу: http://code.google.com/p/explorercanvas/.  \r\n","\r\n 276\r\nА теперь я собираюсь провести углубленное рассмотрение двух примеров, предоставленных  в основном \r\nруководстве Mozilla по <canvas>.  \r\nСоздание часов \r\nПервый пример заключается в создании простых часов. Мы собираемся использовать Canvas 2D API для \r\nрисования всех элементов часов; в этот процессе не будут использоваться какие-нибудь изображения или \r\nпосторонние HTML-элементы. На рис. 14.1 показан пример часов, которые мы собираемся нарисовать.  \r\n \r\nРис. 14.1. Анимированные часы, нарисованные с помощью Canvas API \r\nЭлемент <canvas> работает подобно настоящему холсту художника. Вы можете нарисовать единственный \r\nстатический кадр анимированных часов, но чтобы нарисовать новый кадр, нужно полностью очистить свой холст и \r\nнарисовать все заново. Если у вас есть опыт работы с OpenGL API, то вы почувствуете себя как дома и в среде \r\nCanvas API.  \r\nПри работе с Canvas API, вам понадобится часто вращать изображение, но это может привести к большой \r\nпутанице, поскольку вы можете не знать,  на какой угол вы в настоящий момент указываете, или где в данный \r\nмомент находится ваша «кисть». По этой причине работа Canvas API во многом похожа на стек: сначала вы \r\nсохраняете старую позицию и вращаете холст, вносите какие-то изменения во внешний облик текущего \r\nизображения, а затем возвращаетесь назад к первоначальному изображению и продолжаете рисовать.  \r\nВ листинге 14.7 приводится код, необходимый для создания анимированных часов с использованием \r\nCanvas; обратите внимание, что для облегчения рисования в этом коде широко используется стек-система Canvas.  \r\nЛистинг 14.7. Рисование анимированных часов с использованием Canvas API \r\n<html> \r\n<head> \r\n    <title>Демонстрация часов Canvas </title> \r\n<script> \r\n// Ожидание загрузки в браузер \r\nwindow.onload = function() { \r\n    // Рисование часов \r\n    clock(); \r\n  \r\n    // и перерисовка часов по прошествии каждой секунды \r\n    setInterval(clock, 1000); \r\n}; \r\n  \r\nfunction clock() { \r\n    // Получение текущей даты и времени \r\n    var now = new Date(); \r\n    var sec = now.getSeconds(); \r\n","\r\n 277\r\n    var min = now.getMinutes(); \r\n    var hr = now.getHours(); \r\n    hr = hr >= 12 ? hr - 12 : hr; \r\n  \r\n    // Получение контекста элемента <canvas> \r\n    var ctx = document.getElementById('canvas').getContext('2d'); \r\n  \r\n    ctx.save(); \r\n       // Инициализация холста для рисования \r\n       ctx.clearRect(0,0,150,150); \r\n  \r\n       // Когда мы рисуем в 0,0, мы фактически рисуем в 75,75 \r\n       ctx.translate(75,75); \r\n  \r\n       // При рисовании линии 100px, фактически рисуется линия в 40px \r\n       ctx.scale(0.4,0.4); \r\n  \r\n       // Начало вращения курсора с 12:00 \r\n       ctx.rotate(-Math.PI/2); \r\n  \r\n       // Инициализация свойств рисунка \r\n       ctx.strokeStyle = \"black\"; \r\n       ctx.fillStyle = \"black\"; \r\n       ctx.lineWidth = 8; \r\n       ctx.lineCap = \"round\"; \r\n  \r\n       // Часовые метки \r\n       ctx.save(); \r\n           ctx.beginPath(); \r\n               // Для каждого часа \r\n               for ( var i = 0; i < 12; i++ ) { \r\n                  // Вращение холста на 1/12 пути \r\n                  // (помните: длина окружности = 2 * PI) \r\n                  ctx.rotate(Math.PI/6); \r\n  \r\n                  // Перемещение курсора почти к краю холста \r\n                  ctx.moveTo(100,0); \r\n  \r\n                  // и рисование короткой черточки (20px) \r\n                  ctx.lineTo(120,0); \r\n               } \r\n           ctx.stroke(); \r\n       ctx.restore(); \r\n  \r\n       // Минутные метки \r\n        ctx.save(); \r\n           // Эти черточки будут меньше часовых \r\n           ctx.lineWidth = 5; \r\n","\r\n 278\r\n  \r\n           ctx.beginPath(); \r\n               // Для каждой минуты \r\n               for ( var i = 0; i < 60; i++ ) { \r\n                  // кроме тех, что совпадают с часами \r\n                  if ( i % 5 != 0 ) { \r\n                      // Перемещение курсора чуть дальше \r\n                      ctx.moveTo(117,0); \r\n  \r\n                      // И рисование короткой линии (3px) \r\n                      ctx.lineTo(120,0); \r\n                  } \r\n  \r\n                  // Вращение холста 1/60 пути по кругу \r\n                  ctx.rotate(Math.PI/30); \r\n               } \r\n           ctx.stroke(); \r\n       ctx.restore(); \r\n  \r\n       // Рисование часовой стрелки \r\n       ctx.save(); \r\n           // Вращение холста на текущую позицию \r\n           ctx.rotate( (Math.PI/6) * hr + (Math.PI/360) * min \r\n                                     + (Math.PI/21600) * sec ) \r\n  \r\n           // Эта линия должна быть шире \r\n           ctx.lineWidth = 14; \r\n  \r\n           ctx.beginPath(); \r\n               // Начало рисования с выходом за пределы центра (чтобы \r\n               // было похоже на часовую стрелку) \r\n               ctx.moveTo(-20,0); \r\n  \r\n               // и рисование почти до часовых черточек \r\n               ctx.lineTo(80,0); \r\n           ctx.stroke(); \r\n       ctx.restore(); \r\n  \r\n       // Рисование минутной стрелки \r\n       ctx.save(); \r\n           // Вращение холста на текущую минутную позицию \r\n           ctx.rotate( (Math.PI/30) * min + (Math.PI/1800) * sec ) \r\n  \r\n           // Эта линия будет тоньше, чем часовая стрелка \r\n           ctx.lineWidth = 10; \r\n  \r\n           ctx.beginPath(); \r\n               // Но она также и длиннее, поэтому ее нужно установить чуть \r\n","\r\n 279\r\n               // назад \r\n               ctx.moveTo(-28,0); \r\n  \r\n               // и нарисовать чуть длиннее \r\n               ctx.lineTo(112,0); \r\n           ctx.stroke(); \r\n        ctx.restore(); \r\n  \r\n        // Рисование секундной стрелки \r\n        ctx.save(); \r\n           // Вращение холста на текущую секундную позицию \r\n           ctx.rotate(sec * Math.PI/30); \r\n  \r\n            // Эта линия должна быть красноватой \r\n           ctx.strokeStyle = \"#D40000\"; \r\n           ctx.fillStyle = \"#D40000\"; \r\n  \r\n            // и более тонкой, чем другие стрелки \r\n           ctx.lineWidth = 6; \r\n  \r\n           ctx.beginPath(); \r\n               // А также больше выступать назад \r\n               ctx.moveTo(-30,0); \r\n  \r\n               // но быть короче \r\n               ctx.lineTo(83,0); \r\n            ctx.stroke(); \r\n       ctx.restore(); \r\n  \r\n       // Внешняя синяя окружность \r\n       ctx.save(); \r\n           // Обрамление будет широким \r\n           ctx.lineWidth = 14; \r\n  \r\n           // и синеватым \r\n           ctx.strokeStyle = '#325FA2'; \r\n  \r\n           ctx.beginPath(); \r\n               // Рисование полной окружности, отступающей от центра \r\n               // на 142px \r\n               ctx.arc(0,0,142,0,Math.PI*2,true); \r\n           ctx.stroke(); \r\n       ctx.restore(); \r\n  \r\n    ctx.restore(); \r\n} \r\n</script> \r\n</head> \r\n","\r\n 280\r\n<body> \r\n    <canvas id=\"canvas\" height=\"150\" width=\"150\"></canvas> \r\n</body> \r\n</html> \r\nКак только вы проработаете все подробности и математические особенности (которые различаются в \r\nзависимости от сложности объекта, который вы пытаетесь нарисовать), Canvas 2D API станет очень полезным \r\nинструментом.  \r\nПростая модель планет \r\nВ нашем втором примере мы собираемся рассмотреть вращение изображений в противоположность \r\nобычному рисованию форм. Начнем с трех базовых изображений: одного для Солнца, второго для Земли и \r\nтретьего для Луны. Затем создадим простую модель (которая выглядит хорошо, но точностью не отличается), \r\nпоказывающую вращение Земли вокруг Солнца, и вращение Луны вокруг Земли. Кроме этого будет примерно \r\nпоказано, какая сторона Земли будет темной во время ее вращения вокруг Солнца. На рис. 14.2 показан пример, \r\nкак будет выглядеть конечный результат действующей модели.  \r\n \r\nРис. 14.2. Вращение Земли вокруг Солнца,  и Луны вокруг Земли в простой планетной модели, \r\nвыполненной с помощью Canvas \r\nВ коде этого примера, конечно, найдется много похожего на код предыдущего примера (а именно, \r\nсохранение и восстановление позиций холста), но важно отметить, как именно происходит обработка рисунка и \r\nвращение отдельных изображений. В листинге 14.8 показан полный код для планетной модели, выполненной с \r\nпомощью Canvas.  \r\nЛистинг 14.8. Модель вращения Земли вокруг Солнца, созданная с помощью Canvas 2D API  \r\n<html> \r\n<head> \r\n<title>Демонстрация части солнечной системы с помощью Canvas</title> \r\n<script> \r\n// Инициализация списка используемых изображений \r\nvar imgs = { sun: null, moon: null, earth: null }; \r\n  \r\n// Ожидание полной загрузки окна \r\n","\r\n 281\r\nwindow.onload = function() { \r\n    // Загрузка всех изображений из документа \r\n    for ( var i in imgs ) \r\n       imgs[i] = document.getElementById(i); \r\n  \r\n    // Запуск рисования 10 раз в секунду \r\n    setInterval( draw, 100 ); \r\n}; \r\nfunction draw() { \r\n    // Получение необходимых интервалов времени \r\n    var time = new Date(); \r\n    var s = ( (2 * Math.PI) / 6) * time.getSeconds(); \r\n    var m = ( (2 * Math.PI) / 6000 ) * time.getMilliseconds(); \r\n  \r\n    // Получение контекста элемента <canvas> \r\n    var ctx = document.getElementById('canvas').getContext('2d'); \r\n  \r\n    // Очистка холста \r\n    ctx.clearRect(0,0,300,300); \r\n  \r\n    // Новые элементы всегда рисуются под старыми (используется для тени) \r\n    // Дополнительная информация: \r\n    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Compositing \r\n    ctx.globalCompositeOperation = 'destination-over'; \r\n  \r\n    ctx.save(); \r\n        // Рисование  в 0,0 = рисованию в 150,150 \r\n       ctx.translate(150,150); \r\n  \r\n       // Вращение холста к позиции Земли \r\n       ctx.rotate( (s + m) / 10 ); \r\n  \r\n       // Перемещение на 105 пикселов \r\n       ctx.translate(105,0); \r\n  \r\n       // Заполнение для тени (которая будет наплывать, \r\n       // и мы сможем видеть сквозь нее) \r\n       ctx.fillStyle = 'rgba(0,0,0,0.4)'; \r\n       ctx.strokeStyle = 'rgba(0,153,255,0.4)'; \r\n  \r\n       // Рисование прямоугольника тени (не совсем \r\n       // безупречного, но близкого к нужному) \r\n       ctx.fillRect(0,-12,50,24); \r\n  \r\n       // Рисование Земли \r\n       ctx.drawImage(imgs.earth,-12,-12); \r\n  \r\n       ctx.save(); \r\n","\r\n 282\r\n           // Вращение холста, относительно вращения Земли \r\n           ctx.rotate( s + m ); \r\n  \r\n           // Вращение Луны 'по орбите' \r\n           ctx.translate(0,28.5); \r\n  \r\n           // Рисование изображения Луны \r\n           ctx.drawImage(imgs.moon,-3.5,-3.5); \r\n       ctx.restore(); \r\n  \r\n       ctx.restore(); \r\n  \r\n       // Рисование орбиты Земли \r\n       ctx.beginPath(); \r\n           ctx.arc(150,150,105,0,Math.PI*2,false); \r\n       ctx.stroke(); \r\n  \r\n       // Рисование неподвижного Солнца \r\n       ctx.drawImage(imgs.sun,0,0); \r\n} \r\n</script> \r\n</head> \r\n<body style=\"background:#000;\"> \r\n    <canvas id=\"canvas\" height=\"300\" width=\"300\"></canvas> \r\n    <!-- Предварительная загрузка исходных изображений --> \r\n    <div style=\"display:none;\"> \r\n       <img src=\"sun.png\" id=\"sun\"/> \r\n       <img src=\"moon.png\" id=\"moon\"/> \r\n       <img src=\"earth.png\" id=\"earth\"/> \r\n    </div> \r\n</body> \r\n</html> \r\nЭлемент <canvas> и соответствующий API в последнее время нашли широкое применение; они \r\nиспользуются как в инструментальной панели Apple, так и в области графических элементов управления Opera. \r\nЭто одна из частей «будущего» JavaScript которая доступна во всем своем практическом воплощении уже сейчас, \r\nи вы должны всерьез рассматривать ее использование в ваших приложениях.  \r\nComet \r\nПоследняя новая концепция, которую мы собираемся рассмотреть, недавно подверглась \r\nусовершенствованию и находится в процессе превращения в новый стандарт. Хотя концепция Ajax является \r\nдостаточно простой и понятной (наличие единственного асинхронного подключения), она не рассчитана на \r\nформирование пакета с каким-нибудь потоковым содержимым. Концепцию, способную обеспечить поток \r\nобновлений, приходящих в ваше веб-приложение, сейчас часто называют Comet (название выдумал Алекс Рассел \r\n(Alex Russell) из Dojo). Возможность потокового обновления внутри веб-приложения предоставляет вам \r\nсовершенно новую степень свободы, позволяя создавать сверхотзывчивые приложения (например, чаты).  \r\nАналогично Ajax, Comet, по существу, тоже не содержит новой технологии. Но многие разработчики \r\nвзялись за усовершенствование общих потоковых концепций, ориентированных на веб-приложения в конечный \r\n","\r\n 283\r\nстандарт, называемый Cometd. Дополнительная информация о планируемом стандарте Cometd и сама концепция \r\nComet могут быть найдены в следующих источниках:  \r\n• Первоначальная статья Алекса Рассела (Alex Russell), уточняющая концепцию, лежащую в основе Comet: \r\nhttp://alex.dojotoolkit.org/?p=545 \r\n• Определение спецификации Comet: http://cometd.com/ \r\nComet улучшает текущие Ajax-приложения за счет наличия долговременных подключений, которые \r\nобеспечивают непрерывный поток новой информации с центрального сервера. Центральному серверу отводится \r\nроль равномерного распределения подключений на соответствующие каналы. На рис. 14.3 показан пример, как \r\nработает Comet по сравнению с традиционным Ajax-приложением.  \r\nОрганизация Dojo Foundation несет ответственность за основной объем работы, ведущей к \r\nстандартеризации Comet и превращению этой концепции в готовый продукт, которым мог бы воспользоваться \r\nобычный веб-разработчик. В листинге 14.9 показан пример использования библиотеки Dojo для запуска Comet-\r\nподключения к ресурсам на стороне сервера (который работает с использованием сервера Cometd).  \r\nЛистинг 14.9. Использование Dojo и ее библиотеки Cometd для подключения к потоковому серверу и \r\nпрослеживания различных каналов передачи  \r\n  \r\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \r\n    \"http://www.w3.org/TR/html4/strict.dtd\"> \r\n<html> \r\n    <head> \r\n    <title>Тестовая страница клиент-серверной системы Cometd</title> \r\n    <script type=\"text/javascript\"> \r\n       // Мы собираемся регистрировать все взаимодействие на \r\n       // панели отладки \r\n       djConfig = { isDebug: true }; \r\n    </script> \r\n    <script type=\"text/javascript\" src=\"../dojo/dojo.js\"></script> \r\n    <script type=\"text/javascript\"> \r\n       dojo.require(\"dojo.io.cometd\"); \r\n       dojo.addOnLoad(function(){ \r\n           // Установка базового URL для всего взаимодействия с cometd \r\n           cometd.init({}, \"/cometd\"); \r\n  \r\n           // Подписка на отдельный пункт передачи \r\n           // Будет отслеживаться весь выходящий поток, поступающий именно \r\n           // из этой службы и регистрироваться на панели отладки \r\n           cometd.subscribe(\"/foo/bar/baz\", false, dojo, \"debugShallow\"); \r\n  \r\n           // Распространение двух сообщений двум различным службам \r\n           cometd.publish(\"/foo/bar/baz\", { thud: \"thonk!\"}); \r\n           cometd.publish(\"/foo/bar/baz/xyzzy\", \r\n                             { foo: \"A simple message\" }); \r\n       }); \r\n    </script> \r\n","\r\n 284\r\n    </head> \r\n    <body></body> \r\n</html>  \r\nХотя количество приложений, использующих Comet (или подобную Comet технологию) пока еще не очень \r\nвелико, это количество обязательно увеличится по мере того, как все большее количество людей начнет \r\nпонимать, насколько полезна именно эта часть технологии для создания высокопроизводительных веб-\r\nприложений.  \r\n","\r\n 285\r\n \r\nРис. 14.3. Сравнение традиционной модели Ajax и новой модели веб-приложения, использующего \r\nметодику Comet \r\nВывод \r\n","\r\n 286\r\nТехнология, представленная в этой главе, относится к широкому диапазону, в нее входит все, начиная со \r\nсложной и отдаленной перспективы (как деструктуризация в JavaScript 1.7), и до текущих и широко используемых \r\nвещей (например, элемента <canvas>). Надеюсь, мне удалось дать вам хорошее представление о том \r\nнаправлении, в котором в ближайшем будущем будет двигаться веб-разработка, основанная на использовании \r\nбраузеров. \r\n","\r\n 287\r\nПриложение А Справочник по DOM \r\nЭто приложение служит справочником по функциональным возможностям, предоставляемым объектной \r\nмоделью документа, рассмотренной в главе 5.  \r\nResources \r\nФункциональные возможности DOM сформировались из множества разновидностей, начиная с исходной \r\nпредварительной спецификации DOM Level 0, и развиваясь до  вполне определенных DOM Levels 1 и 2. Поскольку \r\nвсе современные браузеры практически полностью поддерживают разработанные W3C спецификации DOM Levels \r\n1 и 2, веб-сайт W3C случит превосходным справочным пособием для изучения порядка работы DOM:  \r\n• DOM Level 1: http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html \r\n• HTML DOM Level 1: http://www.w3.org/TR/REC-DOM-Level-1/level-one-html.html \r\n• DOM Level 2: http://www.w3.org/TR/DOM-Level-2-Core/ \r\n• HTML DOM Level 2: http://www.w3.org/TR/DOM-Level-2-HTML/ \r\nКроме этого существует ряд отличных справочных руководств для изучения функционирования DOM, но \r\nлучшими все же являются источники, находящиеся на  Quirksmode.org, веб-сайте, запущенном Питером-Паулем \r\nКохом (Peter-Paul Koch). Он провел всесторонние исследования каждого доступного DOM-метода и сравнил свои \r\nрезультаты на всех современных браузерах (и не только на них). Это бесценный источник для определения того, \r\nчто возможно, а что невозможно на тех браузерах, для которых вы ведете разработку:  \r\n• W3C DOM Core Levels 1 and 2 reference: http://www.quirksmode.org/dom/w3c_core.html \r\n• W3C DOM HTML Levels 1 and 2 reference: http://www.quirksmode.org/dom/w3c_html.html \r\nТерминология \r\nВ главе 5, посвященной объектной модели документа, и в этом приложении, я использую общепринятую \r\nXML и DOM терминологию для описания различных аспектов DOM-представления XML-документа. Следующие \r\nслова и фразы представляют терминологию, которая относиться к объектной модели документа и, в общем, к \r\nдокументу XML. Все терминологические примеры будут относиться к образцовому HTML-документу, показанному в \r\nлистинге A.1.  \r\nЛистинг A.1. Пример, на который мы будем ссылаться при рассмотрении DOM и XML терминологии  \r\n  \r\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \r\n\"http://www.w3.org/TR/html4/strict.dtd\"> \r\n<html> \r\n<head> \r\n    <title>Introduction to the DOM</title> \r\n</head> \r\n<body> \r\n    <h1>Introduction to the DOM</h1> \r\n    <p class=\"test\">There are a number of reasons why the DOM is awesome, \r\n       here are some:</p> \r\n    <ul> \r\n       <li id=\"everywhere\">It can be found everywhere.</li> \r\n       <li class=\"test\">It's easy to use.</li> \r\n","\r\n 288\r\n       <li class=\"test\">It can help you to find what you want, really \r\n                                                    quickly.</li> \r\n    </ul> \r\n</body> \r\n</html>  \r\nПредок \r\nТермин, очень похожий на генеалогический, ссылается на родителя текущего элемента, а также на \r\nродителя этого родителя, и на родителя этого родителя и т.д. В листинге А.1 родительскими для элемента <ul> \r\nявляются элемент <body> и элемент <html>.  \r\nАтрибут \r\nАтрибуты являются свойствами элементов, в которых содержится принадлежащая им дополнительная \r\nинформация. В листинге А.1 у элемента <p> есть атрибут class, в котором содержится значение test.  \r\nДочерний элемент \r\nЛюбой элемент может содержать любое количество узлов (каждый из которых рассматривается в качестве \r\nдочернего по отношению к родительскому элементу). В листинге А.1 элемент <ul> содержит семь дочерних узлов; \r\nтри дочерних узла являются  элементами <li>, а остальные четыре — конечными строками, находящимися внутри \r\nкаждого элемента (содержащихся в пределах текстовых узлов).  \r\nЭлемент Document \r\nКаждый XML-документ состоит из одного элемента (так называемого корневого узла или элемента \r\ndocument), который содержит все остальные аспекты документа. В листинге А.1 элементом document является \r\n<html>, в котором содержится весь остальной документ.  \r\nПотомки \r\nПотомки элементов содержат его дочерние узлы, детей его детей, детей их детей и т.д. В листинге А.1 \r\nпотомки элемента <body> включают <h1>, <p>, <ul> и <li>-элементы, а также все текстовые узлы, которые \r\nсодержатся во всех этих элементах.  \r\nЭлемент \r\nЭлемент является контейнером, в котором содержатся атрибуты и другие узлы. Первичными и наиболее \r\nпримечательными компонентами любого HTML-документа являются его элементы. В листинге А.1 присутствует \r\nмножество элементов; все теги — <html>, <head>, <title>, <body>, <h1>, <p>, <ul> и <li> —  являются \r\nэлементами.  \r\nУзел \r\nУзел является основной составной частью DOM-представления. Элементы, атрибуты, комментарии, \r\nдокументы и текстовые узлы — все являются узлами, и поэтому обладают стандартными свойствами узлов (к \r\nпримеру, nodeType, nodeName и nodeValue имеются в каждом узле).  \r\nРодитель \r\nТермин «родитель» используется для ссылки на элемент, в котором содержится текущий узел. Родитель \r\nесть у всех узлов, кроме корневого. В листинге А.1 родителем для элемента <p> является элемент <body>.  \r\n","\r\n 289\r\nСестры \r\nСестринский узел является дочерним узлом того же самого родительского узла. Обычно этот термин \r\nиспользуется в контексте previousSibling и nextSibling, двух свойств, имеющихся у всех DOM-узлов. В листинге А.1 \r\nсестринскими для элемента <p> являются элементы <h1> и  <ul> (вместе с несколькими пустыми текстовыми \r\nузлами).  \r\nТекстовые узлы \r\nТекстовым называется особенный узел, который содержит только текст; сюда включается видимый текст и \r\nвсе виды пустых пространств. Если вы видите текст внутри элемента (например, <b>hello world!</b>), значит, \r\nвнутри элемента <b> фактически находится отдельный текстовый узел, содержащий текст «hello world!». Текст \r\n«It’s easy to use» в листинге А.1, который находится внутри второго элемента <li>, содержится внутри текстового \r\nузла.  \r\nГлобальные переменные \r\nГлобальные переменные существуют в пределах глобальной области видимости вашего кода, и \r\nсуществуют для того чтобы помочь вам работать с общими DOM-операциями.  \r\ndocument \r\nЭта переменная содержит активный HTML DOM-документ, который просматривается в браузере. Но сам \r\nфакт существования этой переменной и наличия в ней какого-нибудь значения еще не означает, что ее \r\nсодержимое было полностью загружено и прошло синтаксический анализ. Более подробные сведения об \r\nожидании загрузки DOM приведены в главе 5. В листинге А.2 показан ряд примеров использования переменной \r\ndocument, которая содержит представление HTML DOM для обращения к элементам документа.  \r\nЛистинг A.2. Использование переменной document для доступа к элементам документа  \r\n  \r\n// Обнаружение элемента, ID которого имеет значение 'body' \r\ndocument.getElementById(\"body\") \r\n  \r\n// Обнаружение всех элементов, имеющих имена тегов <div>. \r\ndocument.getElementsByTagName(\"div\") \r\nHTMLElement \r\nЭта переменная является надклассовым объектом для всех HTML DOM-элементов. Продолжение прототипа \r\nэтого элемента распространяется на все HTML DOM-элементы. Этот суперкласс доступен по умолчанию во всех \r\nбраузерах на движке Mozilla и в браузере Opera. Используя методы, описанные в главе 5, его также можно \r\nдобавить к Internet Explorer и Safari. В листинге А.3 показан пример привязки новых функций к глобальному \r\nсуперклассу HTMLElement. Присоединение функции hasClass дает возможность увидеть, имеет ли элемент \r\nопределенный класс.  \r\nЛистинг A.3. Привязка новых функций к глобальному суперклассу HTMLElement \r\n  \r\n// Добавление ко всем HTML DOM-элементам нового метода, \r\n// который может быть использован, чтобы увидеть \r\n// имеется ли у элемента определенный класс или нет. \r\nHTMLElement.prototype.hasClass = function( class ) { \r\n","\r\n 290\r\n    return new RegExp(\"(^|\\\\s)\" + class + \"(\\\\s|$)\").test( this.className ); \r\n};  \r\nПеремещение по DOM \r\nСледующие свойства являются составной частью всех DOM-элементов и могут быть использованы для \r\nперемещения по DOM-документам.  \r\nbody \r\nЭто свойство глобального HTML DOM-документа (переменной document) непосредственно указывает на \r\nHTML-элемент <body> (который должен быть только один). Это свойство относится к тем, которые были \r\nперенесены еще из времен DOM 0 JavaScript. В листинге А.4 показано несколько примеров обращения к элементу \r\n<body> из HTML DOM-документа.  \r\nЛистинг A.4. Обращение к элементу <body> внутри HTML DOM-документа  \r\n  \r\n// Изменение полей <body> \r\ndocument.body.style.margin = \"0px\"; \r\n  \r\n// document.body эквивалентно следующему выражению: \r\ndocument.getElementsByTagName(\"body\")[0] \r\nchildNodes \r\nЭто свойство имеется у всех DOM-элементов и содержит массив всех дочерних узлов (включая элементы, \r\nтекстовые узлы, комментарии и т.д.). Оно предназначено только для чтения. В листинге А.5 показано, как нужно \r\nиспользовать свойство childNodes для добавления стилевой установки ко все дочерним элементам данного \r\nродителя.  \r\nЛистинг A.5. Добавление красного обрамления вокруг дочерних элементов, принадлежащих элементу \r\n<body> с использованием свойства childNodes \r\n  \r\n// Добавление обрамления ко всем, имеющимся у  <body> дочерним элементам \r\nvar c = document.body.childNodes; \r\nfor ( var i = 0; i < c.length; i++ ) { \r\n    // Нужно убедиться, что этот узел является элементом \r\n    if ( c[i].nodeType == 1 ) \r\n       c[i].style.border = \"1px solid red\"; \r\n}  \r\ndocumentElement \r\nЭто свойство, которое имеется у всех DOM-узлов, действует в качестве ссылки на корневой элемент \r\nдокумента (в случае с HTML-документами, он всегда будет указывать на элемент <html>). В листинге А.6 показан \r\nпример использования documentElement для поиска DOM-элемента.  \r\nЛистинг A.6. Пример обнаружения корневого элемента из любого DOM-узла  \r\n  \r\n// Обнаружение documentElement для поиска элемента по его ID \r\n","\r\n 291\r\nнекийПроизвольныйУзел.documentElement.getElementById(\"body\")  \r\nfirstChild \r\nЭто свойство, имеющееся у всех DOM-элементов, указывает на первый дочерний узел данного элемента. \r\nЕсли у элемента нет дочерних узлов, firstChild будет равен нулю. В листинге А.7 показан пример использования \r\nсвойства firstChild для удаления всех дочерних узлов данного элемента.  \r\nЛистинг A.7. Удаление из элемента всех дочерних узлов  \r\n  \r\n// Удаление из элемента всех дочерних узлов \r\nvar e = document.getElementById(\"body\"); \r\nwhile ( e.firstChild ) \r\n    e.removeChild( e.firstChild );  \r\ngetElementById( элемID ) \r\nЭто весьма эффективная функция, которая обнаруживает в документе один из элементов, имеющий \r\nопределенный ID. Функция доступна только элементу document. Кроме этого, функция может не работать, если \r\nбудет применена к DOM-документам, не имеющим отношения к HTML; как правило, при работе XML DOM-\r\nдокументами нужно точно указать атрибут ID в DTD (определении типа документа — Document Type Definition) \r\nили в схеме.  \r\nКак показано в листинге А.8, эта функция принимает единственный аргумент: имя искомого ID.  \r\nЛистинг A.8. Два примера обнаружения HTML-элементов по именам их ID-атрибутов  \r\n  \r\n// Обнаружение элемента по значению ID, равному body \r\ndocument.getElementById(\"body\") \r\n  \r\n// Скрытие элемента, у которого значение ID равно notice \r\ndocument.getElementById(\"notice\").style.display = 'none'; \r\ngetElementsByTagName( имяТега ) \r\nЭто свойство отыскивает все элементы-потомки, которые имеют определенное имя тега, начиная с \r\nтекущего элемента. Эта функция одинаково хорошо работает как XML DOM, так и в HTML DOM-документах.  \r\nВо всех современных браузерах можно задать в качестве имени тега знак звездочки (*) и найти все \r\nэлементы-потомки, и это получится намного быстрее, чем при использовании рекурсивной функции, написанной \r\nна чистом JavaScript.  \r\nЭта функция принимает единственный аргумент: имя тега искомых элементов. В листинге А.9 показан \r\nпример использования getElementsByTagName. Первый блок добавляет класс highlight всем <div>-элементам \r\nдокумента. Второй блок находит все элементы внутри элемента, у которого значение ID равно body, и прячет те \r\nиз них, которые имеют класс highlight.  \r\nЛистинг A.9. Два блока кода, в которых демонстрируется использование getElementsByTagName \r\n  \r\n","\r\n 292\r\n// Обнаружение всех элементов <div> в текущем HTML-документе \r\n// и установка значения их атрибута class в 'highlight' \r\nvar d = document.getElementsByTagName(\"div\"); \r\nfor ( var i = 0; i < d.length; i++ ) { \r\n    d[i].className = 'hilite'; \r\n} \r\n  \r\n// Проход по всем элементам-потомкам элемента, у которого значение \r\n// ID равно body. Затем обнаружение всех элементов, у которых значение \r\n// аргумента class равно 'hilite'. После чего скрытие всех элементов, \r\n// соответствующих этому условию. \r\nvar all = document.getElementById(\"body\").getElementsByTagName(\"*\"); \r\nfor ( var i = 0; i < all.length; i++ ) { \r\n    if ( all[i].className == 'hilite' ) \r\n       all[i].style.display = 'none'; \r\n} \r\nlastChild \r\nЭта ссылка, доступная во всех DOM-элементах, указывает на последний дочерний узел этого элемента. \r\nЕсли дочерних узлов нет, значение lastChild будет равно нулю (null). В листинге А.10 показан пример \r\nиспользования  свойства lastChild для вставки элемента в документ.  \r\nЛистинг A.10. Создание нового <div>-элемента и вставка его перед последним элементом в <body>  \r\n  \r\n// Вставка нового элемента непосредственно перед последним элементом в \r\n// <body> \r\nvar n = document.createElement(\"div\"); \r\nn.innerHTML = \"Спасибо за визит!\"; \r\n  \r\ndocument.body.insertBefore( n, document.body.lastChild ); \r\nnextSibling \r\nЭта ссылка, доступная во всех DOM-узлах, указывает на последний сестринский узел. Если узел является \r\nпоследним сестринским, значение nextSibling будет равно нулю (null). Важно помнить о том, что свойство \r\nnextSibling может указывать на DOM-элемент, комментарий или даже на текстовый узел; поэтому оно не служит \r\nисключительным способом перемещения по DOM-элементам. В листинге А.11 показан пример использования \r\nсвойства nextSibling для создания интерактивного списка определений.  \r\nЛистинг A.11. Принуждение всех элементов <dt> по щелчку раскрывать свои сестринские элементы <dd>  \r\n  \r\n// Обнаружение всех элементов <dt> (Defintion Term — определяемый термин) \r\nvar dt = document.getElementsByTagName(\"dt\"); \r\nfor ( var i = 0; i < dt.length; i++ ) { \r\n    // Отслеживание щелчка на термине \r\n    dt[i].onclick = function() { \r\n","\r\n 293\r\n       // Поскольку каждый термин имеет прикрепленный к нему \r\n       // элемент <dd> (Definition — определение), \r\n       // мы можем его отобразить по щелчку \r\n       // ПРИМЕЧАНИЕ: Работает при условии, что между элементами <dd> \r\n       // отсутствуют пустые пространства \r\n       this.nextSibling.style.display = 'block'; \r\n    }; \r\n} \r\nparentNode \r\nЭто свойство есть у всех DOM-узлов. Свойство parentNode каждого DOM-узла указывает на элемент, \r\nкоторые его содержит, за исключением элемента document, который указывает на null (поскольку ничто не \r\nсодержит корневой элемент). В листинге А.12 показан пример использования свойства parentNode для создания \r\nсобственного сценария взаимодействия. Щелчок на кнопке Cancel (Отмена) приводит к скрытию родительского \r\nэлемента.  \r\nЛистинг A.12. Использование свойства parentNode для создания собственного сценария взаимодействия  \r\n  \r\n// Отслеживание щелчка на кнопке (например, Cancel) \r\n// и скрытие родительского элемента \r\ndocument.getElementById(\"cancel\").onclick = function(){ \r\n    this.parentNode.style.display = 'none'; \r\n};  \r\npreviousSibling \r\nЭта ссылка, доступная во всех DOM-узлах, указывает на предыдущий сестринский узел. Если узел \r\nявляется первым сестринским, значение previousSibling будет равно нулю (null). Важно помнить о том, что \r\nсвойство previousSibling может указывать на DOM-элемент, комментарий или даже на текстовый узел; поэтому оно \r\nне служит исключительным способом перемещения по DOM-элементам. В листинге А.13 показан пример \r\nиспользования свойства previousSibling для скрытия элементов. \r\nЛистинг A.13. Скрытие всех элементов перед текущим элементом  \r\n  \r\n// Обнаружение всех элементов перед текущим, и их скрытие \r\nvar cur = this.previousSibling; \r\nwhile ( cur != null ) { \r\ncur.style.display = 'none'; \r\ncur = this.previousSibling; \r\n} \r\nИнформация об узле \r\nЭти свойства имеются у большинства DOM-элементов с целью предоставления простого доступа к общей \r\nинформации об элементе.  \r\ninnerText \r\n","\r\n 294\r\nЭто свойство есть у всех DOM-элементов (которые существуют только в тех браузерах, которые не \r\nработают на движках Mozilla, поскольку оно не является частью стандарта W3C). Оно возвращает строку, \r\nсодержащую весь текст, находящийся внутри текущего элемента. Поскольку это свойство не поддерживается \r\nбраузерами на движках Mozilla, вы можете воспользоваться обходным путем, подобным одному их описанных в \r\nглаве 5 (где мы использовали функцию для сбора значений текстовых узлов-потомков). В листинге А.14 показан \r\nпример использования свойства innerText и функции text() из главы 5.  \r\nЛистинг A.14. Использование свойства innerText для извлечения из элемента текстовой информации  \r\n  \r\n// Предположим, что у нас есть элемент <li> похожий на этот, \r\n// сохраненный в переменной 'li': \r\n// <li>Пожалуйста, посетите <a href=\"http://mysite.com/\"> \r\n                                     мой веб-сайт </a>.</li> \r\n  \r\n// Использование свойства innerText \r\nli.innerText \r\n  \r\n// или функции text(), рассмотренной в главе 5 \r\ntext( li ) \r\n  \r\n// Результат использования свойства или функции будет следующим: \r\n\"Пожалуйста, посетите мой веб-сайт.\"  \r\nnodeName \r\nЭто свойство доступно для всех DOM-элементов, содержащих версию имени элемента в верхнем регистре. \r\nНапример, если у вас имеется элемент <li>, и вы обращаетесь к его свойству nodeName, он вернет LI. В листинге \r\nА.15 показан пример использования свойства nodeName для модификации имен классов родительских элементов.  \r\nЛистинг A.15. Обнаружение всех родительских элементов <li> и установка значение их класса в current \r\n  \r\n// Обнаружение всех родителей данного узла, являющихся элементом <li> \r\nvar cur = this.parentNode; \r\nwhile ( cur != null ) { \r\n    // Как только элемент найден и его имя проверено, добавить класс \r\n    if ( cur.nodeName == 'LI' ) \r\n       cur.className += \" current\"; \r\n       cur = this.parentNode; \r\n}  \r\nnodeType \r\nЭто общее свойство всех DOM-узлов, содержащее номер, соответствующий типу данного узла. Существует \r\nтри наиболее широко распространенных типа узлов, используемых в HTML-документах:  \r\n• Узел элемента (имеет значение 1 или document.ELEMENT_NODE)  \r\n• Текстовый узел (имеет значение 3 или document.TEXT_NODE)  \r\n• Узел документа (имеет значение 9 или document.DOCUMENT_NODE)  \r\n","\r\n 295\r\nИспользование свойства nodeType является надежным способом убедиться в том, что узел, к которому вы \r\nпытаетесь получить доступ, обладает всеми ожидаемыми свойствами (к примеру, свойство nodeName может \r\nиспользоваться только для DOM-элементаt; поэтому перед обращением к нему можно воспользоваться nodeType, \r\nчтобы убедиться, что это свойство равно 1). В листинге А.16 показан пример использования свойства nodeType \r\nдля добавления класса многим элементам.  \r\nЛистинг A.16. Обнаружение первого элемента в HTML <body> и использование для него класса header \r\n  \r\n// Обнаружение в <body> первого элемента \r\nvar cur = document.body.firstChild; \r\nwhile ( cur != null ) { \r\n    // Если элемент был найден, добавить к нему класс header \r\n    if ( cur.nodeType == 1 ) { \r\n       cur.className += \" header\"; \r\n       cur = null; \r\n  \r\n    // В противном случае продолжить проход по дочерним узлам \r\n    } else { \r\n       cur = cur.nextSibling; \r\n    } \r\n}  \r\nnodeValue \r\nЭто полезное свойство текстовых узлов, оно может быть использовано для доступа и работы с текстом, \r\nкоторый в них содержится. Хорошим примером его использования может послужить функция text, представленная \r\nв главе 5, которая используется для извлечения текстового содержимого элемента. В листинге А.17 показан \r\nпример использования свойства nodeValue для создания простой функции извлечения текстового значения.  \r\nЛистинг A.17. Функция, принимающая элемент и возвращающая текстовое содержимое этого элемента и \r\nего элементов-потомков  \r\n  \r\nfunction text(e) { \r\n    var t = \"\"; \r\n  \r\n    // Если элемент передан, обнаружение его дочерних элементов, \r\n    // если нет, предположение, что это массив \r\n    e = e.childNodes || e; \r\n  \r\n    // просмотр всех дочерних узлов \r\n    for ( var j = 0; j < e.length; j++ ) { \r\n       // Если это не элемент, добавление его текстового значения, \r\n       // в противном случае рекурсивное обращение ко всем его дочерним \r\n       // элементам  \r\n       t += e[j].nodeType != 1 ? \r\n           e[j].nodeValue : text(e[j].childNodes); \r\n    } \r\n  \r\n","\r\n 296\r\n    // Возвращение соответствующего текста \r\n    return t; \r\n}  \r\nАтрибуты \r\nБольшинство атрибутов доступно в виде свойств своих элементов. Например, атрибут ID может быть \r\nполучен с использованием простого выражения element.id. Эта особенность осталась со времен DOM 0, и скорее \r\nвсего оно так и останется, благодаря его простоте и популярности.  \r\nclassName \r\nЭто свойство позволяет добавлять и удалять классы в DOM-элементе. Оно существует во всех элементах \r\nDOM. Причиной его отдельного упоминания стало  название — className, в котором нарушен ожидаемый порядок \r\nслов. Это странное название связано с тем, что слово class зарезервировано в большинстве объектно-\r\nориентированных языков программирования; поэтому его использования избегают, чтобы не создавать трудности \r\nв программировании веб-браузера. В листинге А.18 показан пример использования свойства className для \r\nскрытия некоторых элементов.  \r\nЛистинг A.18. Обнаружение всех <div>-элементов, имеющих класс special и их скрытие  \r\n  \r\n// Обнаружение всех имеющихся в документе элементов <div> \r\nvar div = document.getElementsByTagName(\"div\"); \r\nfor ( var i = 0; i < div.length; i++ ) { \r\n    // Обнаружение всех элементов <div>, имеющих общий класс 'special' \r\n    if ( div[i].className == \"special\" ) { \r\n       // И их скрытие \r\n       div[i].style.display = 'none'; \r\n    } \r\n}  \r\ngetAttribute( имяАтрибута ) \r\nЭта функция служит хорошим способом доступа к значению атрибута, содержащегося внутри DOM-\r\nэлемента. Атрибуты инициализируются значением, которое пользователь предоставляет в обычном HTML-\r\nдокументе.  \r\nФункция принимает единственный аргумент: имя атрибута, значение которого нужно извлечь. В \r\nлистинге А.19 показан пример использования функции getAttribute() для поиска элементов input определенного \r\nтипа.  \r\nЛистинг A.19. Обнаружение элемента <input>, у которого атрибут name имеет значение text и \r\nкопирование его значения в элемент, у которого атрибут ID имеет значение preview \r\n  \r\n// Обнаружение всех элементов ввода данных формы — input \r\nvar input = document.getElementsByTagName(\"input\"); \r\nfor ( var i = 0; i < input.length; i++ ) { \r\n  \r\n    // Обнаружение элемента, у которого атрибут name имеет значение \"text\" \r\n    if ( input[i].getAttribute(\"name\") == \"text\" ) { \r\n","\r\n 297\r\n  \r\n       // Копирование значения в другой элемент \r\n       document.getElementById(\"preview\").innerHTML = \r\n           input[i].getAttribute(\"value\"); \r\n    } \r\n}  \r\nremoveAttribute( имяАтрибута ) \r\nЭту функцию можно использовать для полного удаления атрибута из элемента. Обычно результат \r\nиспользования этой функции можно сравнить с результатом применения функции setAttribute со значением \" \" \r\n(пустой строки) или null; но на практике лучше все же всегда полностью удалять лишние атрибуты, чтобы \r\nизбежать любых неожиданных последствий.  \r\nЭта функция принимает единственный аргумент: имя атрибута, требующего удаления. В листинге А.20 \r\nпоказан пример снятия в форме некоторых флажков.  \r\nЛистинг A.20. Обнаружение всех флажков, имеющихся в документе, и их снятие  \r\n  \r\n// Обнаружение всех элементов ввода данных формы \r\nvar input = document.getElementsByTagName(\"input\"); \r\nfor ( var i = 0; i < input.length; i++ ) { \r\n  \r\n    // Обнаружение всех флажков \r\n    if ( input[i].getAttribute(\"type\") == \"checkbox\" ) { \r\n  \r\n       // Снятие флажков \r\n       input[i].removeAttribute(\"checked\"); \r\n    } \r\n}  \r\nsetAttribute( attrName, attrValue ) \r\nЭта функция служит хорошим способом установки значений атрибута, содержащегося внутри DOM-\r\nэлемента. Кроме этого она может добавить ваши собственные атрибуты, к которым позже можно будет обратиться, \r\nне оказывая влияния на появление DOM-элементов. Функция setAttribute склонна вести себя в Internet Explorer \r\nнесколько странным образом, не позволяя устанавливать определенные атрибуты (например, class или \r\nmaxlength). Все это подробнее объяснено в главе 5.  \r\nФункция принимает два аргумента. Первый — имя атрибута, а второй — присваиваемое ему значение. В \r\nлистинге А.21 показан пример установки значения атрибута DOM-элемента.  \r\nЛистинг A.21. Использование функции setAttribute для создания <a>-ссылки на Google \r\n  \r\n// Создание нового элемента <a> \r\nvar a = document.createElement(\"a\"). \r\n  \r\n// Установка URL для посещения веб-сайта Google \r\na.setAttribute(\"href\",\"http://google.com/\"); \r\n","\r\n 298\r\n  \r\n// Добавление внутреннего текста, на котором пользователь может сделать \r\n// щелчок \r\na.appendChild( document.createTextNode( \"Посетите Google!\" ) ); \r\n  \r\n// Добавление ссылки в самый конец документа \r\ndocument.body.appendChild( a );  \r\nМодификация DOM \r\nЗдесь представлены все свойства и функции, которые можно использовать для работы с DOM.  \r\nappendChild( добавляемыйУзел ) \r\nЭту функцию можно использовать для добавления дочернего узла к элементу-контейнеру. Если \r\nдополняемый узел уже существует в документе, он перемещается со своего текущего места и добавляется к \r\nтекущему элементу. Функция appendChild должна быть вызвана для элемента, который требуется дополнить.  \r\nФункция принимает единственный аргумент: ссылку на DOM-узел (он может быть только что созданным, \r\nили ссылка может быть на узел, который уже существует в каком-нибудь месте документа). В листинге А.22 \r\nпоказан пример создания нового элемента <ul> и перемещения в него всех <li>-элементов с их первоначального \r\nместа в DOM, а затем добавления нового <ul> к телу документа.  \r\nЛистинг A.22. Добавление серии <li>-элементов к отдельному <ul>  \r\n  \r\n// Создание нового элемента <ul> \r\nvar ul = document.createElement(\"ul\"); \r\n  \r\n// Обнаружение всех первых элементов <li> \r\nvar li = document.getElementsByTagName(\"li\"); \r\nfor ( var i = 0; i < li.length; i++ ) { \r\n  \r\n    // добавление каждого соответствующего <li> к новому \r\n    // элементу <ul> \r\n    ul.appendChild( li[i] ); \r\n} \r\n  \r\n// Добавление нашего нового элемента <ul> к концу тела документа — body \r\ndocument.body.appendChild( ul ); \r\ncloneNode( true|false ) \r\nЭта функция является для разработчиков способом упрощения кода за счет создания дубликатов \r\nсуществующих узлов, которые затем могут быть вставлены в DOM. Если обычный вызов insertBefore или \r\nappendChild приведет к физическому перемещению DOM-узла в документе, то функция cloneNode может быть \r\nиспользована для создания его дубликата.  \r\nФункция принимает один из аргументов — true или false. Если передан аргумент true, то клонируется узел \r\nсо всем его содержимым; а если false, то клонируется только сам узел. В листинге А.23 показан пример \r\nиспользования этой функции для клонирования элемента и его добавления к нему самому.  \r\n","\r\n 299\r\nЛистинг A.23. Обнаружение в документе первого элемента <ul>, создание его полной копии и добавление \r\nее к нему самому  \r\n  \r\n// Обнаружение первого элемента <ul> \r\nvar ul = document.getElementsByTagName(\"ul\")[0]; \r\n  \r\n// клонирование узла и добавление его сразу после старого узла \r\nul.parentNode.appendChild( ul.cloneNode( true ) );  \r\ncreateElement( имяТега ) \r\nЭто основная функция, используемая для создания новых элементов внутри DOM-структуры. Функция \r\nсуществует в виде свойства документа, внутри которого вы хотите создать элемент.  \r\nПРИМЕЧАНИЕ \r\nЕсли вы используете XHTML,  для которого указан тип контекста (content-type)  application/xhtml+xml, \r\nвместо обычного HTML, для которого указан тип контекста text/html, то вместо функции createElement нужно \r\nиспользовать функцию createElementNS.  \r\nЭта функция принимает один аргумент: имя тега создаваемого элемента. В листинге А.24 показан пример \r\nиспользования этой функции для создания элемента и помещения в него нескольких других элементов.  \r\nЛистинг A.24. Помещение содержимого элемента <p> в элемент <strong>  \r\n  \r\n// Создание нового элемента <strong> \r\nvar s = document.createElement(\"strong\"); \r\n  \r\n// Обнаружение первого абзаца \r\nvar p = document.getElementsByTagName(\"p\")[0]; \r\n  \r\n// Помещение содержимого <p> в элемент <strong> \r\nwhile ( p.firstChild ) { \r\n    s.appendChild( p.firstChild ); \r\n} \r\n  \r\n// Помещение элемента <strong> (содержащего прежнее содержимое элемента <p>) \r\n// обратно в элемент <p> \r\np.appendChild( s ); \r\ncreateElementNS( пространство_имен, имяТега ) \r\nЭта функция очень похожа на функцию createElement, она тоже создает новый элемент, но она также \r\nпредоставляет возможность указать для элемента пространство имен (если, к примеру, элемент добавляется к \r\nдокументу XML или XHTML).  \r\nЭта функция принимает два аргумента: пространство имен добавляемого элемента, и имя тега элемента. В \r\nлистинге А.25 показан пример использования этой функции для создания DOM-элемента в допустимом XHTML-\r\nдокументе.  \r\n","\r\n 300\r\nЛистинг A.25. Создание нового XHTML <p>-элемента, заполнение его некоторым текстом и добавление его \r\nк телу документа  \r\n  \r\n// Создание нового XHTML-совместимого <p> \r\nvar p = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"p\"); \r\n  \r\n// Добавление в элемент <p> некоторого текста \r\np.appendChild( document.createTextNode( \"Welcome to my site.\" ) ); \r\n  \r\n// Добавление элемента <p> в документ \r\ndocument.body.insertBefore( p, document.body.firstChild );  \r\ncreateTextNode( тесктоваяСтрока ) \r\nЭто подходящий способ создания новой текстовой строки для вставки ее в DOM-документ. Поскольку \r\nтекстовые узлы это всего лишь существующая только в DOM оболочка текста, важно помнить, что они не могут \r\nбыть стилизованы или дополнены. Эта функция существует только как свойство DOM-документа. \r\nФункция принимает один аргумент: строку, которая станет содержимым текстового узла. В листинге А.26 \r\nпоказан пример использования этой функции для создания нового текстового узла  и добавления его к телу HTML-\r\nстраницы.  \r\nЛистинг A.26. Создание элемента <h1> и добавление нового текстового узла  \r\n  \r\n// Создание нового элемента <h1> \r\nvar h = document.createElement(\"h1\"); \r\n  \r\n// Создание текста заголовка и добавление его к элементу <h1> \r\nh.appendChild( document.createTextNode(\"Главная страница\") ); \r\n  \r\n// Добавление заголовка в начале <body> \r\ndocument.body.insertBefore( h, document.body.firstChild );  \r\ninnerHTML \r\nЭто свойство, характерное для HTML DOM, предназначено для обращения к текстовой версии HTML-\r\nсодержимого DOM-элемента и работе с ним. Если вы работаете только с HTML-документом (который не имеет \r\nотношения к XML), этот метод может быть очень полезным, поскольку код, который нужен для генерации нового \r\nDOM-элемента, может быть существенно сокращен (если не считать, что это более быстрая альтернатива \r\nтрадиционным DOM-методам). Хотя это свойство не входит ни в один W3C-стандарт, оно все же существует во \r\nвсех современных браузерах.  \r\nВ листинге А.27 показан пример использования свойства innerHTML для изменения содержимого элемента \r\nпри изменении содержимого <textarea>.  \r\nЛистинг A.27. Отслеживание изменения в <textarea> и обновление предварительного просмотра его \r\nзначением в реальном времени  \r\n  \r\n// Получение textarea для отслеживания обновлений \r\n","\r\n 301\r\nvar t = document.getElementsByTagName(\"textarea\")[0]; \r\n  \r\n// Захват текущего значения <textarea> и обновление предварительного \r\n// просмотра в реальном времени при каждом изменении \r\nt.onkeypress = function() { \r\n    document.getElementById(\"preview\").innerHTML = this.value; \r\n}; \r\ninsertBefore( узелДляВставки, узелПередКоторымВставлять) \r\nЭта функция используется для вставки DOM-узла в любое место документа. Она должна быть вызвана для \r\nродительского элемента узла, перед которым нужно сделать вставку. Так сделано для того, чтобы вы могли \r\nуказать null в качестве узла, перед которым нужно сделать вставку, чтобы ваш узел был вставлен в качестве \r\nпоследнего  дочернего узла.  \r\nФункция принимает два аргумента. Первый аргумент является узлом, который нужно вставить в DOM, а \r\nвторой — это DOM-узел, перед которым будет осуществлена вставка. Он должен ссылаться на существующий \r\nузел. В листинге А.28 показан пример использования этой функции для вставки значка сайта (который \r\nпредшествует URL в адресной строке браузера) рядом с набором URL веб-сайтов на странице.  \r\nЛистинг A.28. Проход по всем элементам <a> и добавление изображения значка веб-сайта \r\n  \r\n// Обнаружение в документе всех ссылок <a> \r\nvar a = document.getElementsByTagName(\"a\"); \r\nfor ( var i = 0; i < a.length; i++ ) { \r\n  \r\n    // Создание изображения значка веб-сайта, на который указывает \r\n    // ссылка \r\n    var img = document.createElement(\"img\"); \r\n    img.src = a[i].href.split('/').splice(0,3).join('/') + '/favicon.ico'; \r\n  \r\n    // Вставка изображения перед ссылкой \r\n    a[i].parentNode.insertBefore( img, a[i] ); \r\n}  \r\nremoveChild( удаляемыйУзел ) \r\nЭта функция используется для удаления узла из DOM-документа. Функция removeChild должна быть \r\nвызвана для родительского элемента того узла, который нужно удалить.  \r\nФункция принимает один аргумент: ссылку на DOM-узел, удаляемый из документа. В листинге А.29 \r\nпоказан пример ее запуска в отношении всех <div>-элементов документа и удаления каждого из них, который \r\nимеет особый класс warning.  \r\nЛистинг A.29. Удаление всех элементов, которые имеют особое имя класса  \r\n  \r\n// Обнаружение всех элементов <div>  \r\nvar div = document.getElementsByTagName(\"div\"); \r\nfor ( var i = 0; i < div.length; i++ ) { \r\n","\r\n 302\r\n    // Если значение класса <div> равно 'warning' \r\n    if ( div[i].className == \"warning\" ) { \r\n  \r\n       // Удалить <div> из документа \r\n       div[i].parentNode.removeChild( div[i] ); \r\n  \r\n    } \r\n}  \r\nreplaceChild( вставляемыйУзел, заменяемыйУзел ) \r\nЭта функция служит альтернативой процессу удаления узла и вставляет на его место другой узел. Она \r\nможет быть вызвана родительским элементом заменяемого узла.  \r\nЭта функция принимает два аргумента: узел, который нужно вставить в DOM, и узел, который вы \r\nсобираетесь заменить. В листинге А.30 показан пример замены всех элементов <a> элементом <strong>, \r\nсодержащим URL, на который первоначально была сделана ссылка.  \r\nЛистинг A.30. Преобразование набора ссылок в обычные URL \r\n  \r\n// Преобразование всех ссылок в видимые URL (что хорошо подойдет для \r\n// распечатки) \r\n// Обнаружение в документе всех ссылок <a> \r\nvar a = document.getElementsByTagName(\"a\"); \r\nwhile ( a.length ) { \r\n  \r\n    // Создание элемента <strong> \r\n    var s = document.createElement(\"strong\"); \r\n  \r\n    // Создание содержимого, эквивалентного URL, на который ссылается <a> \r\n    s.appendChild( document.createTextNode( a[i].href ) ); \r\n  \r\n    // Замена исходного <a> новым элементом <strong> \r\n    a[i].replaceChild( s, a[i] ); \r\n} \r\n","\r\n 303\r\nПриложение Б Справочник по событиям \r\nЭто приложение служит справочником для главы 6, посвященной событиям. Оно предоставляет полное \r\nописание всех возможных DOM-событий и дополняет общую теорию, представленную в главе  6. Здесь вы найдете \r\nисточники дополнительной информации, определения общепринятой терминологии, связанной с событиями, и \r\nобъяснения всех общих объектов событий и взаимодействия с ними.  \r\nИсточники информации \r\nЕсли выбирать только один источник информации, к которому нужно обратиться за дополнительными \r\nсведениями о событиях, то это Quirksmode.org. Этот веб-сайт предоставляет сравнительную характеристику для \r\nкаждого события во всех современных браузерах. Я настоятельно рекомендую на него зайти и составить \r\nпредставление о том, какие события поддерживает каждый из браузеров \r\n(http://www.quirksmode.org/js/events_compinfo.html).  \r\nКроме этого были использованы две наиболее популярные спецификации: W3C DOM-события и Internet \r\nExplorer HTML-события. На каждом веб-сайте имеется подробный список  всех возможных событий и изложена \r\nкаждая особенность их поведения:  \r\n• W3C DOM Level 2 events: http://www.w3.org/TR/DOM-Level-2-Events/events.html  \r\n• Internet Explorer HTML events: http://msdn.microsoft.com/workshop/author/dhtml/reference/events.asp \r\nТерминология \r\nВ этом разделе определяется ряд новых терминов, введенных по теме обработки событий в JavaScript, \r\nкоторые могут быть незнакомы для тех , кто не работал с событиями JavaScript, или с асинхронной обработкой \r\nсобытий.  \r\nАсинхронный \r\nАсинхронные события имеют общую структуру обратного вызова, в отличие от потоковой прикладной \r\nструктуры. Это означает, что какой-то единственный фрагмент кода (обратный вызов) зарегистрирован в качестве \r\nобработчика события. При наступлении события выполняется обратный вызов. \r\nПрикрепление  / Привязка / Регистрация обратного вызова \r\nПрикрепление (иногда называемое привязкой) обратного вызова к обработчику события является \r\nрегистрацией кода в асинхронной модели события. Как только событие произойдет, вызывается обработчик \r\nсобытия, в котором содержится ссылка на зарегистрированный обратный вызов. Этот обратный вызов  является \r\nчастью кода в форме функции, которая вызывается по ссылке, как только завершится наступление события.  \r\nВсплытие \r\nФаза всплытия события происходит после фазы захвата, относящейся к этому событию. Эта фаза \r\nначинается с источника события (такого как ссылка, на которой щелкнул пользователь) и перемещается вверх \r\nпод дереву DOM к корневому элементу документа.  \r\nЗахват \r\nФаза захвата (возникающая только в модели события W3C) это первая имеющая место фаза события, \r\nкоторая состоит из перемещения события вниз по дереву DOM к местоположению элемента, которому \r\nприписывается событие.  \r\n","\r\n 304\r\nИсходное действие (или действие по умолчанию) \r\nИсходное действие предопределяется браузером и совершается независимо от того, имеет пользователь \r\nпривязанный обработчик события, или нет. Примером исходного действия, предоставляемого браузером может \r\nпослужить переход на другую веб-страницу по щелчку пользователя на ссылке.  \r\nСобытие   \r\nСобытие — действие, которое запущено (инициировано) в пределах веб-страницы. Как правило, события \r\nинициируются пользователем (например,  перемещение указателя мыши, нажатие клавиши и т.д.), но могут \r\nвозникать и без участия пользователя (например, загрузка страницы, или возникновение ошибки).  \r\nОбработчик события \r\nОбработчик события (в частности, ссылка на функцию) является кодом, который вызывается при \r\nнаступлении события. Если в качестве обработчика события не был зарегистрирован обратный вызов, то ничего \r\nне произойдет (кроме исходного действия).  \r\nПотоковый \r\nВ потоковом приложении обычно существует несколько отдельно текущих процессов, выполняющих \r\nпостоянную задачу (к примеру, отслеживание доступности ресурса). JavaScript не занимается какой-либо \r\nобработкой потоков, и является чисто асинхронным языком.  \r\nОбъект события \r\nОбъект события является объектом, предоставляемым или доступным внутри каждой функции обработчика \r\nсобытия. Их работа в Internet Explorer и в других браузерах происходит по-разному.  \r\nБраузеры, совместимые со спецификацией W3C, предоставляют функции обработчика события \r\nединственный аргумент, в котором содержится ссылка на объект события. В Internet Explorer объект события \r\nвсегда доступен в свойстве window.event, доступ к которому может быть открыт только в обработчике события.  \r\nОбщие свойства \r\nДля любого типа захваченных событий в объекте события имеется ряд свойств. Все эти свойства объекта \r\nсобытия относятся  непосредственно к самому событию и не содержат никакой специфики, относящейся к типу \r\nсобытия. Далее приводится список всех свойств объекта события с пояснениями и примерами кода.  \r\ntype \r\nЭто свойство содержит имя текущего инициированного события (например, click, mouseover и т.д.). Оно \r\nможет быть использовано для предоставления универсальной функции обработки события, которая затем \r\nпредопределенно выполнить соответствующие функции (например, функции addEvent/removeEvent, \r\nрассмотренные в главе 6).  В листинге Б.1 показан пример использования этого свойства для создания \r\nобработчика, производящего различный эффект в зависимости от типа обрабатываемого события.  \r\nЛистинг Б.1. Использование свойства type для придания элементу возможности изменения при \r\nпрохождении над ним указателя мыши  \r\n// Обнаружение <div>,для которого создается эффект прохождения \r\nvar div = document.getElementsByTagName('div')[0]; \r\n  \r\n","\r\n 305\r\n// Привязка одной и той же функции к обоим событиям mouseover и mouseout \r\ndiv.onmouseover = div.onmouseout = function(e){ \r\n    // Нормализация объекта события \r\n    e = e || window.event; \r\n  \r\n    // Переключение цвета фона <div>, в зависимости от типа \r\n    // возникшего события мыши \r\n    this.style.background = (e.type == 'mouseover') ? '#EEE' : '#FFF'; \r\n}; \r\ntarget / srcElement \r\nЭто свойство содержит ссылку на элемент, который инициировал событие. Например, привязка \r\nобработчика щелчка (click), к элементу  <a> приведет к тому, что свойство target будет равно самому элементу \r\n<a>. Свойство srcElement является эквивалентом свойства target, но работает в Internet Explorer. В листинге Б.2 \r\nпоказан пример использования этого свойства для работы с глобальным обработчиком событий.  \r\nЛистинг Б.2. Двойной щелчок на узле, принадлежащем HTML DOM, приводит к его удалению  \r\n// Привязка к документу отслеживателя двойного щелчка \r\ndocument.ondblclick = function(e) { \r\n    // Нормализация объекта события \r\n    e = e || window.event; \r\n  \r\n    // Обнаружение правильного целевого узла \r\n    var t = e.target || e.srcElement; \r\n  \r\n    // удаление узла из DOM \r\n    t.parentNode.removeChild( t ); \r\n};  \r\nstopPropagation() / cancelBubble \r\nМетод stopPropagation() останавливает процесс всплытия (или захвата) события, делая текущий элемент \r\nпоследним получателем данного события. Фазы события подробно рассмотрены в главе 6. Свойство cancelBubble \r\nдоступно в Internet Explorer; если установить его значение в true, то это будет эквивалентно вызову метода \r\nstopPropagation() для W3C-совместимых браузеров. В листинге Б.3 показан пример использования этой \r\nтехнологии для прекращения распространения события.  \r\nЛистинг Б.3. Динамическая подсветка всех элементов  <li>, имеющихся в документе  \r\n// Обнаружение в документе всех элементов <li> \r\nvar li = document.getElementsByTagName('li'); \r\nfor ( var i = 0; i < li.length; i++ ) { \r\n  \r\n    // Отслеживание прохождения над <li> указателя мыши \r\n    li[i].onmouseover = function(e){ \r\n       // Если браузер W3C-совместимый \r\n       if ( e ) \r\n           // Использование stopPropogation для остановки всплытия \r\n           e.stopPropagation(); \r\n","\r\n 306\r\n  \r\n       // Если нет, то это Internet Explorer \r\n       else \r\n           // поэтому для остановки всплытия cancelBubble \r\n           // устанавливается в true \r\n           e.cancelBubble = true; \r\n  \r\n       // В заключение, подсветка фона элемента <li> \r\n       this.style.background = '#EEE'; \r\n    }; \r\n  \r\n    // Когда указатель мыши уходит с <li> \r\n    li[i].onmouseout = function(){ \r\n       // Переключение фонового цвета обратно на белый \r\n       this.style.background = '#FFF'; \r\n    }; \r\n}  \r\npreventDefault() / returnValue = false \r\nВызов метода preventDefault() останавливает выполнение исходного действия браузера во всех \r\nсовременных W3C-совместимых браузерах. В Internet Explorer, чтобы остановить выполнение исходного действия \r\nбраузера, нужно установить значение свойства returnValue, принадлежащее объекту события, в false.  \r\nОбъяснение процесса выполнения исходного действия приведено в главе 6. Код в листинге Б.4 делает так, \r\nчто при каждом щелчке на расположенной на странице ссылке, вместо перехода на другую страницу (как это \r\nобычно происходит), заголовок документа становится URL ссылки.  \r\nЛистинг Б.4. Предотвращение исходного действия браузера  \r\n// Обнаружение на странице всех элементов <a> \r\nvar a = document.getElementsByTagName('a'); \r\nfor ( var i = 0; i < a.length; i++ ) { \r\n  \r\n    // Привязка к <a> обработчика щелчка \r\n    a[i].onclick = function(e) { \r\n       // Установка заголовка страницы в качестве URL этой ссылки, вместо \r\n       // перехода по прежнему URL \r\n       document.title = this.href; \r\n  \r\n       // Предотвращение визитов браузера на веб-сайт, указанный в \r\n       // <a> (что является его исходным действием) \r\n       if ( e ) { \r\n           e.preventDefault(); \r\n  \r\n       // Предотвращение действия по умолчанию в IE \r\n       } else { \r\n           window.event.returnValue = false; \r\n       } \r\n    }; \r\n","\r\n 307\r\n}  \r\nСвойства мыши \r\nСвойства мыши существуют в объекте события только при инициации событий, связанных с мышью (среди \r\nкоторых click, mousedown, mouseup, mouseover, mousemove и mouseout). Во всех остальных случаях можно \r\nсчитать, что возвращенные значения не существуют или наверняка отсутствуют. В этом разделе приводится \r\nперечень всех свойств, которые присутствуют в объекте события в то время, когда имеет место событие, \r\nсвязанное с мышью.  \r\nclientX / clientY \r\nЭто свойство содержит координаты x и y указателя мыши относительно окна браузера. Пример \r\nиспользования этого свойства показан в листинге Б.5.  \r\nЛистинг Б.5. Определение текущей позиции указателя мыши на веб-странице  \r\n// Определение горизонтальной позиции указателя \r\nfunction getX(e) { \r\n    // Сначала проверка позиции в не-IE браузере, потом в IE, \r\n    // и только потом возвращение нуля \r\n    return e.pageX || (e.clientX + \r\n       (document.documentElement.scrollLeft || document.body.scrollLeft)); \r\n} \r\n  \r\n// Определение вертикальной позиции указателя \r\nfunction getY(e) { \r\n    // Сначала проверка позиции в не-IE браузере, потом в IE, \r\n    // и только потом возвращение нуля \r\n    return e.pageY || (e.clientY + \r\n       (document.documentElement.scrollTop || document.body.scrollTop)); \r\npageX / pageY \r\nЭти свойства содержат координаты x и y указателя мыши относительно отображаемого документа (к \r\nпримеру, если вы прокрутили документ вниз, значения уже не будут соответствовать тем, что содержатся в \r\nсвойствах clientX/clientY). В Internet Explorer эти свойства не работают. Чтобы получить позицию курсора в IE, \r\nнужно воспользоваться свойствами  clientX/clientY, и добавить к ним текущее смещение прокрутки.  \r\nlayerX / layerY и offsetX / offsetY \r\nЭти свойства содержат координаты x и y указателя мыши относительно элемента назначение события. \r\nСвойства layerX/layerY доступны только в браузерах, работающих на движке  Mozilla и Safari,  а свойства \r\noffsetX/offsetY доступны в Opera и Internet Explorer. (Примеры их использования можно посмотреть в \r\nлистинге Б.17.)  \r\nbutton \r\nЭто свойство содержит число, представляющее кнопку мыши, нажатую в данный момент (доступно только \r\nв событиях click, mousedown и mouseup). К сожалению, в представлении соответствия чисел нажатой кнопке тоже \r\nприсутствует некоторая неразбериха. Хорошо, что хоть число 2 используется во всех браузерах для \r\nпредставления щелчка правой кнопкой, и вы можете чувствовать себя вполне свободно хотя бы при проверке \r\n","\r\n 308\r\nщелчка этой кнопкой. В таблице Б.1 показаны все возможные значения свойства button как в Internet Explorer, \r\nтак и в W3C-совместимых браузерах.  \r\nТаблица Б.1. Возможные значения для свойства button объекта события \r\nЩелчок Internet Explorer W3C \r\nЛевой кнопкой 1                          0 \r\nПравой кнопкой 1                            0 \r\nСредней кнопкой 4                              1 \r\nВ листинге Б.6 показан фрагмент кода, предотвращающий пользовательский щелчок правой кнопкой \r\nмыши (и вызов контекстного меню) в любом месте веб-страницы.  \r\nЛистинг Б.6. Использование свойства button объекта события  \r\n// Привязка обработчика щелчка ко всему документу \r\ndocument.onclick = function(e) { \r\n    // Нормализиция объекта события \r\n    e = e || window.event; \r\n  \r\n    // Если произведен щелчок правой кнопкой мыши \r\n    if ( e.button== 2 ) { \r\n       // Предотвращение выполнения исходного действия \r\n       e.preventDefault(); \r\n       return false; \r\n    } \r\n};  \r\nrelatedTarget \r\nЭто свойство события содержит ссылку на элемент, пространство которого указатель мыши только что \r\nпокинул. Почти всегда оно используется в ситуациях, когда нужно воспользоваться событиями \r\nmouseover/mouseout, но вам нужно знать, где указатель только что был, или по какому элементу он проходит. В \r\nлистинге  Б.7 показан вариант древовидного меню (элементы <ol> содержат другие элементы <ol>) в котором \r\nподдеревья отображаются в первый раз только тогда, когда пользователь перемещает элемент над подэлементом \r\n<li>.  \r\nЛистинг Б.7. Использование свойства relatedTarget для создания дерева, по которому можно перемещаться  \r\n// Обнаружение всех элементов <li>, содержащихся в документе \r\nvar li = document.getElementsByTagName('li'); \r\nfor ( var i = 0; i < li.length; i++ ) { \r\n  \r\n    // и прикрепление к ним обработчика события mouseover \r\n    li[i].onmouseover = function(e){ \r\n  \r\n       // Если указатель мыши входит на элемент в первый раз (от родителя) \r\n       if ( e.relatedTarget == this.parentNode ) { \r\n               // отображение последнего дочернего элемента (который \r\n               // является другим <ol>) \r\n","\r\n 309\r\n               this.lastChild.style.display = 'block'; \r\n       } \r\n    }; \r\n} \r\n  \r\n// Пример HTML: \r\n<ol> \r\n    <li>Hello <ol> \r\n       <li>Another</li> \r\n       <li>Item</li> \r\n    </ol></li> \r\n    <li>Test <ol> \r\n       <li>More</li> \r\n       <li>Items</li> \r\n    </ol></li> \r\n</ol>  \r\nСвойства клавиатуры \r\nОбычно свойства клавиатуры существуют в объекте события только при инициации событий, связанных с \r\nклавиатурой (среди которых keydown, keyup и keypress). Исключение из этого правила относится к свойствам \r\nctrlKey и shiftKey, которые доступны во время наступления событий, связанных с мышью (позволяя вам \r\nотслеживать CtrlClick на элементе). Во всех остальных случаях можно считать, что значения, содержащиеся в \r\nсвойстве, не существуют или наверняка отсутствуют.  \r\nctrlKey \r\nЭто свойство возвращает булево значение, отображающее, нажата ли клавиша Ctr Оно доступно для \r\nсобытий, связанных как с клавиатурой, так и с мышью. Код в листинге Б.8 отслеживает пользовательский щелчок \r\nмышью и удержание клавиши control; когда это происходит, элемент, на котором произошел щелчок, удаляется из \r\nдокумента.  \r\nЛистинг Б.8. Применение свойства ctrlKey для создания разновидности взаимодействия, использующего \r\nщелчок мыши  \r\n// Привязка обработчика щелчка ко всему документу \r\ndocument.onclick = function(e){ \r\n    // Нормализация объекта события \r\n    e = e || window.event; \r\n    var t = e.target || e.srcElement; \r\n  \r\n    // Если клавиша control удерживается нажатой во время щелчка, \r\n    if ( e.ctrlKey ) \r\n       // удаление узла, на котором произведен щелчок \r\n       t.parentNode.removeChild( t ); \r\n}; \r\nkeyCode \r\nЭто свойство содержит число, соответствующее различным клавишам клавиатуры. Возможность \r\nиспользования конкретных клавиш (таких как Page Up и Home) может варьироваться, но вообще-то все другие \r\n","\r\n 310\r\nклавиши работают вполне надежно. В табл. Б.2 дается справка по всем часто используемым клавишам и \r\nсвязанных с ними кодам.  \r\nТаблица Б.2. Наиболее часто используемые коды клавиатуры \r\nКлавиша Код клавиши \r\nЗабой (Backspace)                                                                         8 \r\nТабуляция (Tab)                                                                            9 \r\nВвод (Enter)                                                                                   13 \r\nПробел 32 \r\nСтрелка влево 37 \r\nСтрелка вверх 38 \r\nСтрелка вправо 39 \r\nСтрелка вниз 40 \r\n0–9 48–57 \r\nA–Z 65–90 \r\nВ листинге Б.9 показан код, необходимый для запуска простого показа слайдов. В этом коде \r\nпредполагается наличие ряда <li>-элементов внутри единственного элемента <ol> или <ul>.  Каждый элемент \r\n<li> может содержать все что угодно (например, изображение). Когда нажимаются клавиши стрелок вправо и \r\nвлево, пользователю показывается следующий или предыдущий элемент <li>.  \r\nЛистинг Б.9. Использование свойства keyCode для создания простого показа слайдов  \r\n// Обнаружение первого элемента <li> на странице \r\nvar cur = document.getElementsByTagName('li')[0]; \r\n  \r\n// и обеспечение его видимости \r\ncur.style.display = 'block'; \r\n  \r\n// отслеживание любого нажатия клавиши на странице \r\ndocument.onkeyup = function(e){ \r\n    // Нормализация объекта события \r\n    e = e || window.event; \r\n  \r\n    // Если нажаты клавиши левой или правой стрелок \r\n    if ( e.keyCode == 37 || e.keyCode == 39 ) { \r\n  \r\n       // скрытие текущего отображаемого <li>-элемента \r\n       cur.style.display = 'none'; \r\n  \r\n       // Если нажата клавиша левой стрелки, обнаружение \r\n       // предыдущего <li>-элемента \r\n       // (или циклический переход на самый последний элемент) \r\n       if ( e.keyCode == 37 ) \r\n           cur = cur.previousSibling || cur.parentNode.lastChild; \r\n","\r\n 311\r\n  \r\n       // Если нажата клавиша правой стрелки, обнаружение следующего \r\n       // <li>-элемента, или, если текущий элемент был последним, \r\n       // возвращение к первому <li>-элементу \r\n       else if ( e.keyCode == 39 ) \r\n           cur = cur.nextSibling || cur.parentNode.firstChild; \r\n  \r\n       // показ очередного <li>-элемента последовательности \r\n       cur.style.display = 'block'; \r\n    } \r\n}; \r\nshiftKey \r\nЭто свойство возвращает булево значение, отображающее, нажата ли клавиша Shift. Оно доступно для \r\nсобытий, связанных как с клавиатурой, так и с мышью. Код в листинге Б.8 отслеживает пользовательский щелчок \r\nмышью и удержание клавиши Shift; когда это происходит, отображается контекстное меню.  \r\nЛистинг Б.10. Использование свойства shiftKey для отображения специального меню  \r\n// Привязка обработчика щелчка ко всему документу \r\ndocument.onclick = function(e){ \r\n    // Нормализация объекта события \r\n    e = e || window.event; \r\n  \r\n    // Если клавиша Shift удерживается нажатой при совершении щелчка, \r\n    if ( e.shiftKey ) \r\n       // Отображение щелчка \r\n       document.getElementById('menu').style.display = 'block'; \r\n    };  \r\nСобытия страницы \r\nВсе события страницы работают конкретно с функционированием и состоянием всей страницы. \r\nБольшинство типов событий имеют дело с загрузкой и выгрузкой страницы (когда пользователь посещает \r\nстраницу, а затем снова ее покидает).  \r\nload \r\nСобытие load возникает, когда страница полностью завершает свою загрузку; это событие включает \r\nзагрузку всех изображений, внешних файлов JavaScript, и внешних файлов CSS. Оно может быть использовано в \r\nкачестве способа запуска вашего DOM-зависимого кода, но, если нужно ускорить время реакции, можно \r\nобратиться к функции domReady(), рассмотренной в главе 6. \r\nВ листинге Б.11показан код, ожидающий загрузки страницы, после чего он привязывает обработчик \r\nщелчка к элементу, значение ID которого равен cancel. Как только будет запущен обработчик события, он скроет \r\nэлемент, ID которого равен main.  \r\nЛистинг Б.11. Использование события load для ожидания окончания загрузки всей страницы  \r\n// Ожидание завершения загрузки страницы \r\nwindow.onload = function(){ \r\n","\r\n 312\r\n  \r\n    // Обнаружение элемента, значение ID которого равно 'cancel' и привязка \r\n    // к нему обработчика щелчка \r\n    document.getElementById('cancel').onclick = function(){ \r\n  \r\n       // Затем при щелчке скрыть элемент 'main' \r\n       document.getElementById('main').style.display = 'none'; \r\n    }; \r\n};  \r\nbeforeunload \r\nЭто несколько неординарное событие, поскольку оно совершенно не стандартное, но широко \r\nподдерживаемое. Оно ведет себя очень похоже на событие unload, но с одной существенной разницей. Если из \r\nобработчика события beforeunload будет возвращена строка, она появится в подтверждающем сообщении, \r\nспрашивающем пользователей, хотят ли они покинуть текущую страницу. Если ответ будет отрицательным, \r\nпользователь останется на текущей странице. Динамические веб-приложения, вроде Gmail, используют его, чтобы \r\nуберечь пользователей от потенциальных потерь  любых несохраненных данных.  \r\nВ листинге Б.12 к событию прикрепляется простой обработчик (который всего лишь возвращает строку), \r\nобъясняющий, почему пользователь не должен покидать текущую страницу, на которой он находится. Браузер \r\nотобразит окно подтверждения с полным объяснением, включая составленное вами сообщение.  \r\nЛистинг Б.12. Использование события beforeunload для удержания пользователей от ухода со страницы  \r\n// Прикрепление обработчика к beforeunload \r\nwindow.onbeforeunload = function(){ \r\n  \r\n    // Возвращение объяснения, почему пользователю не нужно покидать \r\n    // страницу. \r\n    return 'Ваши данные не было сохранены.'; \r\n}; \r\nerror \r\nСобытие error возникает при обнаружении ошибки в коде JavaScript. Оно может послужить для перехвата \r\nсообщений об ошибках и их отображения, или для того чтобы успешно справиться с возникшей ошибкой. \r\nОбработчик этого события ведет себя не так как все остальные обработчики, вместо того, чтобы передать объект \r\nсобытия, он передает сообщение, поясняющее суть возникшей ошибки.  \r\nВ листинге Б.13 показан самостоятельно разработанный способ обработки и отображения сообщений об \r\nошибках в маркированном списке в отличие от вывода их в традиционную консоль ошибок.  \r\nЛистинг Б.13. Использование события error для ведения просматриваемого журнала регистрации ошибок  \r\n  \r\n// Прикрепление обработчика события error \r\nwindow.onerror = function( message ){ \r\n  \r\n    // Создание элемента <li>, чтобы сохранить сообщение об ошибке \r\n    var li = document.createElement('li'); \r\n","\r\n 313\r\n    li.innerHTML = message; \r\n  \r\n    // Обнаружение нашего списка ошибок (ID элементов которого имеет \r\n    // значение  'errors') \r\n    var errors = document.getElementById('errors'); \r\n    \r\n    // и добавление нашего сообщения об ошибке к верхней части списка \r\n    errors.insertBefore( li, errors.firstChild ); \r\n};  \r\nresize \r\nСобытие resize возникает, как только пользователь изменяет размер окна браузера. Когда пользователь \r\nкорректирует размер окна браузера, событие resize возникнет только когда процесс завершится, но не в ходе его \r\nвыполнения.  \r\nВ листинге Б.14 показан код, отслеживающий случаи уменьшения пользователем размеров окна браузера \r\nдо определенных пределов, применяя дополнительный класс к элементу document (чтобы предоставить лучшее \r\nстилевое оформление документа для меньшего по размерам окна).  \r\nЛистинг Б.14. Использование события resize для динамического изменения размера элемента  \r\n// Отслеживание изменения размеров окна пользователем \r\nwindow.onresize = function() { \r\n    // Обнаружение элемента document \r\n    // (используемого для определения ширины окна) \r\n    var de = document.documentElement; \r\n  \r\n    // Определение ширины окна браузера \r\n// (К сожалению, каждый браузер предпочитает делать это \r\n// по-своему) \r\n    var w = window.innerWidth || (de && de.clientWidth) \r\n       || document.body.clientWidth; \r\n  \r\n    // Если окно уменьшилось до определенных пределов \r\n    // добавить класс к элементу document \r\n    de.className = w < 990 ? 'small' : ''; \r\n};  \r\nscroll \r\nСобытие scroll возникает, когда пользователь перемещает позицию документа в окне браузера. Оно может \r\nвозникнуть в результате нажатия клавиши (использования клавишей стрелок, Page Up/Down или пробела) или \r\nпутем использования полосы прокрутки.  \r\nunload \r\nЭто событие возникает, когда пользователь покидает текущую страницу (возможно, он щелкнул на ссылке, \r\nна кнопке возврата или даже закрыл окно браузера). Предотвращение исходного действия для этого события не \r\nработает (другим событием, представляющим интерес в этом плане является beforeunload).  \r\n","\r\n 314\r\nВ листинге Б.15 показан код, привязывающий обработчик к событию unload, показывающий пользователю \r\nсообщение, когда тот покидает текущую страницу.  \r\nЛистинг Б.15. Событие unload  \r\n// Отслеживание момента, когда пользователь покидает веб-сайт \r\nwindow.onunload = function(){ \r\n    \r\n    // Отображение сообщения для пользователя с благодарностью за визит \r\n    alert( 'Спасибо, что Вы нас посетили!' ); \r\n};  \r\nСобытия пользовательского интерфейса (UI) \r\nСобытия пользовательского интерфейса относятся к тому, как пользователь взаимодействует непосредственно с браузером или с \r\nэлементами страницы. Они помогают определить, с какими элементами страница пользователь взаимодействует в \r\nнастоящий момент, и предоставить этим элементам дополнительное информационное наполнение (например, \r\nподсветку или вспомогательные меню).  \r\nfocus \r\nСобытие focus является способом определения, где в настоящий момент находится курсор страницы. По \r\nумолчанию он находится внутри всего документа; но по щелчку на ссылке или на элементе ввода формы, или по \r\nпереходу на них с использованием клавиши табуляции, фокус перемещается на эти элементы. (Пример \r\nиспользования этого события показан в листинге Б.18.)  \r\nblur \r\nСобытие blur возникает когда пользователь переводит фокус с одного элемента на другой (в пределах \r\nсодержимого ссылок, элементов ввода или самой страницы). (Пример использования этого события показан в \r\nлистинге Б.18.)  \r\nСобытия мыши \r\nСобытия мыши возникают либо когда пользователь перемещает указатель мыши, либо когда он щелкает \r\nодной из ее кнопок.  \r\nclick \r\nСобытие click возникает, когда пользователь нажимает левую кнопку мыши на элементе (см. событие \r\nmousedown) и отпускает ее (см. событие mouseup) на том же самом элементе. В листинге Б.16 показан пример \r\nиспользования события click для предотвращения перехода по ссылке, которая ссылается на текущую страницу.  \r\nЛистинг Б.16. Отключение всех попыток щелчков по ссылкам, указывающим на текущую страницу  \r\n// Обнаружение всех имеющихся в документе элементов <a> \r\nvar a = document.getElementsByTagName('a'); \r\nfor ( var i = 0; i < a.length; i++ ) { \r\n  \r\n    // Если ссылка указывает на ту же самую страницу, на которой мы \r\n    // находимся \r\n    if ( a[i].href == window.location.href ) { \r\n  \r\n","\r\n 315\r\n       // превращение ее в 'недействующую' по щелчку \r\n       a[i].onclick = function(e){ \r\n           return false; \r\n       }; \r\n    } \r\n}  \r\ndblclick \r\nСобытие dblclick возникает после того, как пользователь достаточно быстро совершил два щелчка. \r\nВременной диапазон двойного щелчка зависит от настроек операционной системы.  \r\nmousedown \r\nСобытие mousedown возникает, когда пользователь нажимает кнопку мыши. В отличие от события \r\nkeydown, это событие возникает при нажатии кнопки лишь один раз. Пример использования этого события \r\nпоказан в листинге Б.17.  \r\nmouseup \r\nСобытие mouseup возникает, когда пользователь освобождает ранее нажатую кнопку мыши. Если кнопка \r\nосвобождается на том же самом элементе, на котором она была нажата, то в дополнение к этому событию \r\nвозникает также и событие click. Пример использования этого события показан в листинге Б.17.  \r\nmousemove \r\nСобытие mousemove возникает, когда пользователь перемещает указатель мыши по странице хотя бы на \r\nодин пиксел. Сколько событий mousemove произойдет (за полное перемещение указателя мыши) зависит от того, \r\nнасколько быстро пользователь перемещает мышь, и насколько быстро браузер успевает обновлять положение \r\nкурсора. В листинге Б.17 показан пример простого перетаскивания.  \r\nЛистинг Б.17. Элементы со значением класса draggable могут быть перетащены пользователем \r\n// Инициализация всех переменных, которые будут использованы \r\nvar curDrag, origX, origY; \r\n  \r\n// Отслеживание каждого нажатия кнопки мыши на элементе \r\ndocument.onmousedown = function(e){ \r\n    // Нормализация объекта события \r\n    e = fixEvent( e ); \r\n  \r\n    // Перетаскиваются только элементы, имеющий класс 'draggable' \r\n    if ( e.target.className == 'draggable' ) { \r\n       // Текущий перетаскиваемый элемент \r\n       curDrag = e.target; \r\n  \r\n       // Запоминание начальной позиции указателя мыши и местоположения \r\n       // элемента \r\n       origX = getX( e ) + (parseInt( curDrag.style.left ) || 0); \r\n       origY = getY( e ) + (parseInt( curDrag.style.top ) || 0); \r\n  \r\n","\r\n 316\r\n       // отслеживание перемещения мыши или освобождения ее кнопки \r\n       document.onmousemove = dragMove; \r\n       document.onmouseup = dragStop; \r\n    } \r\n}; \r\n// Отслеживание перемещения мыши \r\nfunction dragMove(e) { \r\n    // Нормализация объекта события \r\n    e = fixEvent( e ); \r\n  \r\n    // Обеспечение отслеживания нужного элемента \r\n    if ( !curDrag || e.target == curDrag ) return; \r\n  \r\n    // Установка новой позиции указателя \r\n    curDrag.style.left = (getX(e)) + 'px'; \r\n    curDrag.style.top = (getY(e)) + 'px'; \r\n} \r\n  \r\n// Ожидание окончания перетаскивания \r\nfunction dragStop(e) { \r\n    // Нормализация объекта события \r\n    e = fixEvent( e ); \r\n  \r\n    // Перезапуск всех наших методов отслеживания \r\n    curDrag = document.mousemove = document.mouseup = null; \r\n} \r\n  \r\n// Настройка объекта события для его нормализации \r\nfunction fixEvent(e) { \r\n// Превращение всех IE-ориентированных параметров в \r\n// W3C-подобные \r\n    if (!e) { \r\n       e = window.event; \r\n       e.target = e.srcElement; \r\n       e.layerX = e.offsetX; \r\n       e.layerY = e.offsetY; \r\n    } \r\n    return e; \r\n}  \r\nmouseover \r\nСобытие mouseover возникает, когда пользователь перемещает указатель мыши на текущий элемент с \r\nдругого элемента. Если нужно узнать, с какого элемента пришел пользователь, используется свойство \r\nrelatedTarget. Пример использования этого события показан в листинге Б.18.  \r\nmouseout \r\nСобытие mouseout возникает, когда пользователь перемещает  указатель мыши за пределы элемента. \r\nСюда включается перемещение указателя мыши с родительского на дочерний элемент (которое может поначалу \r\n","\r\n 317\r\nпоказаться не вполне очевидным). Если нужно узнать, к какому элементу пользователь перемещает указатель, \r\nиспользуется свойство relatedTarget.  \r\nВ листинге Б.18 показан пример прикрепления пар событий к элементам, чтобы позволить веб-странице \r\nиспользоваться в режиме управления с помощью клавиатуры (и мыши). Когда пользователь перемещает \r\nуказатель мыши над ссылкой, или когда он для перехода на нее пользуется клавиатурой, ссылка получает \r\nдополнительное цветовое выделение.  \r\nЛистинг Б.18. Создание эффекта прохождения с использованием событий mouseover и mouseout \r\n// Обнаружение всех <a>-элементов для прикрепления к ним обработчиков \r\n// событий \r\nvar a = document.getElementsByTagName('a'); \r\nfor ( var i = 0; i < a.length; i++ ) { \r\n  \r\n    // Прикрепление к <a>-элементу обработчиков событий mouseover \r\n    // и focus, которые изменяют фон на синий, когда пользователь \r\n    // либо перемещает над ним указатель мыши, либо переводит на него \r\n    // фокус (используя клавиатуру) \r\n    a[i].onmouseover = a[i].onfocus = function() { \r\n       this.style.backgroundColor = 'blue'; \r\n    }; \r\n  \r\n    // Прикрепление к <a>-элементу обработчиков событий mouseout \r\n    // и blur, которые возвращают белый фоновый цвет элемента, \r\n    // когда пользователь уходит со ссылки \r\n  \r\n    a[i].onmouseout = a[i].onblur = function() { \r\n       this.style.backgroundColor = 'white'; \r\n    }; \r\n}  \r\nСобытия клавиатуры \r\nСобытия клавиатуры оперируют с со всеми случаями нажатия клавиш, как внутри, так и снаружи области \r\nввода текста.  \r\nkeydown / keypress \r\nСобытие keydown является первым событием, которое возникает при нажатии клавиши. Если пользовать \r\nпродолжает удерживать клавишу нажатой, событие keydown будет возникать снова и снова. Событие keypress \r\nявляется общепринятым синонимом события keydown, их поведение практически идентично, за одним \r\nисключением: если нужно предотвратить исходное действие по нажатию клавиши, это следует делать в \r\nотношении события keypress. В листинге Б.19 показан пример использования обработчика keypress, чтобы \r\nпредотвратить нажатие определенных клавиш в пределах элемента <input>.  \r\nЛистинг Б.19. Предотвращение отправки формы по нечаянному нажатию клавиши Enter из элемента \r\n<input>  \r\n// Обнаружение всех имеющихся в документе элементов <input> \r\nvar input = document.getElementsByTagName('input'); \r\n","\r\n 318\r\nfor ( var i = 0; i < input.length; i++ ) { \r\n  \r\n    // Привязка обработчика keypress к элементу <input> \r\n    input[i].onkeypress = function(e) { \r\n       // Предотвращение исходного действия, если нажата клавиша ввода \r\n       return e.keyCode != 13; \r\n    }; \r\n}  \r\nkeyup \r\nСобытие keyup является заключительным возникающим событием клавиатуры (после события keydown). В \r\nотличие от события keydown, это событие возникает при освобождении лишь однажды (поскольку клавишу \r\nневозможно освобождать в течение довольно длительного периода времени).  \r\nСобытия форма \r\nСобытия формы имеют отношение непосредственно к элементам <form>, <input>, <select>, <button> и \r\n<textarea>, основных элементов HTML-форм.  \r\nselect \r\nСобытие select возникает, когда пользователь выделяет различные блоки текста в пределах области \r\nввода, используя мышь. С помощью этого события можно переопределить порядок взаимодействия пользователя с \r\nформой. В листинге Б.20 показан пример использования события select для предотвращения выделения текста в \r\nполе формы.  \r\nЛистинг Б.20. Предотвращение выделения текста пользователем внутри элемента <textarea>  \r\n// Обнаружение первого элемента <textarea> на странице \r\nvar textarea = document.getElementsByTagName('textarea')[0]; \r\n  \r\n// Привязка отслеживателя события select \r\ntextarea.onselect = function(){ \r\n    // Когда осуществляется новое выделение, предотвращение действия \r\n    return false; \r\n};  \r\nchange \r\nСобытие change возникает, когда значение элемента ввода (сюда включаются элементы <select> и \r\n<textarea>) изменяется пользователем. Это событие возникает, когда пользователь уже покинул элемент, и он \r\nутратил фокус.  \r\nКод, показанный в листинге Б.21 способен отслеживать изменения и обновления в элементе, ID которого \r\nимеет значение entryArea (элемент должен быть типа <textarea>), в связанной с ним области предварительного \r\nпросмотра  его содержимого в реальном времени.  \r\nЛистинг Б.21. Отслеживание события change для обновления связанного элемента  \r\n// Отслеживание любых изменений 'entryArea' (типа <textarea>) \r\ndocument.getElementById('entryArea').onchange = function(){ \r\n","\r\n 319\r\n  \r\n    // Как только область будет изменена, обновление \r\n    // предварительного просмотра \r\n    document.getElementById('preview').innerHTML = this.value; \r\n};  \r\nsubmit \r\nСобытие submit возникает только в формах, и только когда пользователь щелкнет на кнопке отправки — \r\nSubmit (находящейся в пределах формы) или нажмет клавишу Enter/Return на одном из элементов ввода. \r\nПривязав обработчик submit к форме, и не привязывая обработчик click к кнопке Submit, вы обеспечите перехват \r\nвсех попыток со стороны пользователя отправить данные формы.  \r\nВ листинге Б.22 показан код, отслеживающий первую форму на странице, перехватывающий отправку, и \r\nотображающий сообщение для пользователя, вместо отправки данных на сервер.  \r\nЛистинг Б.22. Использование submit для осуществления альтернативного действия  \r\n// Привязка обработчика submit к первой форме документа \r\ndocument.getElementsByTagName('form')[0].onsubmit = function(e) { \r\n  \r\n    // Получение имени, введенного пользователем \r\n    var name = document.getElementById('name').value; \r\n  \r\n    // Установка в элемент  <h1> содержимого Привет, Имя! (где Имя — это \r\n    // значение name, введенного пользователем в форму) \r\n    document.getElementsByTagName('h1')[0].innerHTML = \r\n       'Привет, ' + name + '!'; \r\n  \r\n    // Предотвращение передачи данных формы на сервер \r\n    return false; \r\n};  \r\nreset \r\nСобытие reset возникает только если пользователь щелкнул на кнопке Reset (Сброс) внутри формы (в \r\nотличие от кнопки   Submit, действие которой может быть продублировано нажатием клавиши Enter).  В \r\nлистинге Б.23 показан пример отслеживания сброса данных формы (события reset), чтобы предоставить \r\nпользователю альтернативное действие.  \r\nЛистинг Б.23. Созданный наспех способ управления сбросом данных формы  \r\n// Обнаружение первой формы на странице \r\nvar form = document.getElementsByTagName('form')[0]; \r\n  \r\n// Отслеживание щелчка на кнопке reset \r\nform.onreset = function(){ \r\n  \r\n    // Обнаружение всех элементов <input> внутри формы \r\n    var input = form.getElementsByTagName('input'); \r\n  \r\n","\r\n 320\r\n    // и сброс их значений за счет присвоения пустой строки \r\n    for ( var i = 0; i < input.length; i++ ) \r\n       input[i].value = ''; \r\n}; \r\n","\r\n 321\r\nПриложение В Браузеры \r\nПрограммирование на JavaScript всегда обуславливалось степенью разработки веб-браузеров. Поскольку \r\nиспользование JavaScript за пределами браузерной среды (например, на стороне сервера) до сих пор не вышло за \r\nрамки экспериментов, набор функциональных возможностей этого языка имеет ярко выраженную браузерную \r\nнаправленность. Поэтому возможности, доступные в JavaScript, очень тесно связаны с процессами развития \r\nбраузеров, и с теми свойствами, которые их разработчики (или пользователи) считают наиболее важными.  \r\nСовременные браузеры \r\nИз всех браузеров, доступных в Интернете, есть лишь несколько, идущих в ногу со временем и \r\nподдерживающих самые последние технологии, и только немногие из них расширяют границы своих \r\nвозможностей. В конечном счете тот круг браузеров, который будет выбран вами для поддержки, скорее всего \r\nбудет зависеть от состава вашей аудитории и от того, сколько времени вы готовы потратить на то, чтобы \r\nсоздаваемое приложение нормально работало на каждом из этих браузеров.  \r\nК слову сказать, теперь, по сравнению с прежними временами, создавать работоспособные JavaScript-\r\nприложения стало намного легче. Благодаря процессу стандартизации многих методов (DOM, XMLHttpRequest и \r\nт.д.) пройдет еще немного времени, и для поддержки всех современных браузеров уже не придется прикладывать \r\nкаких-нибудь дополнительных усилий. Но пока это время еще не настало, поэтому сегодня существует ряд \r\nнаиболее популярных браузеров, и технологий, которые ими поддерживаются.  \r\nInternet Explorer \r\nСозданный компанией Microsoft и входящий в состав ее операционных систем (начиная с Windows 95), \r\nInternet Explorer на данный момент является наиболее популярным веб-браузером. С годами, как только Microsoft \r\nзаняла доминирующие позиции на рынке браузеров, его развитие замедлилось.  \r\nНедавно, в связи с выпуском  новой операционной системы Microsoft Windows Vista (в состав которой \r\nвошел Internet Explorer 7), команда разработчиков снова взялась за работу.  \r\nВерсии 5.5 и 6.0 \r\nВерсия 5.5 является обновлением версии IE, принадлежащего Windows 98, а версия 6.0 является исходной \r\nдля Windows XP. Хотя обе эти версии так и не избавились от ошибок и от непоследовательности в своей \r\nреализации CSS и DOM, они обладают хорошей функциональностью, которая может быть поддержана любым веб-\r\nприложением.  \r\nВерсия 7 \r\nЭто самая последняя версия браузера Internet Explorer, доступная для использования в Windows XP и в \r\nWindows Vista. Пока ее применение ограничено, но ожидается, что с ростом популярности   Vista круг ее \r\nпользователей также возрастет.  \r\nХотя в движке JavaScript мало что изменилось, в механизме отображения была исправлена масса ошибок, \r\nсвязанных с CSS. Для JavaScript произошло лишь одно приметное событие, теперь для объектов XMLHttpRequest \r\nне требуется использование ActiveXObject, и к ним (по умолчанию) имеется прямой доступ.  \r\nMozilla \r\n","\r\n 322\r\nРодившийся на базе того, что осталось от Netscape, Mozilla представляет собой плоды усилий по \r\nразработки популярного браузера с открытым кодом. Благодаря последним выпускам Firefox и ростом его \r\nпопулярности, Mozilla завоевал передовые позиции в современной разработке браузеров.  \r\nFirefox 1.0, Netscape 8 и Mozilla 1.7 \r\nВсе три этих браузера основаны на версии 1.7 движка отображения Gecko. Этот движок обладает полной \r\nсовместимостью со всеми современными технологиями создания сценариев. Все эти браузеры отличаются \r\nхорошей надежностью, стабильностью и удобством в работе.  \r\nFirefox 1.5 и 2.0 \r\nВ самой последней версии движка отображения  Gecko (1.8), использованной в последних версиях \r\nбраузера Firefox, поддерживается ряд новых усовершенствований, которые в ближайшие годы будут играть \r\nвесьма существенную роль. Сюда включается частичная поддержка SVG 1.1, поддержка элементов <canvas>, и \r\nподдержка JavaScript 1.6. Все эти свойства рассмотрены в главе 14.  \r\nSafari \r\nSafari является результатом попытки компании Apple создать лучший (по сравнению с неприглядным \r\nInternet Explorer 5) браузер для OS X. Сначала (в версии 1.0), его движок отображения работал грубовато, \r\nсоздавая проблемы разработчикам при создании полностью поддерживающего его кода. Но с новыми выпусками \r\nего движок постоянно совершенствовался.  \r\nВ наиболее распространенных версиях Safari (1.3 для OS X 10.3, 2.0 для OS X 10.4) устранены наиболее \r\nсущественные ошибки, и добавлены новые возможности. Теперь в том, что ваше приложение, загруженное в \r\nSafari, вполне прилично работает, уже нет ничего необычного.  \r\nКроме того в этих браузерах введена поддержка нового элемента <canvas>, весьма полезного свойства \r\nвысокодинамичных приложений, позволяющего разработчикам рисовать на веб-странице.  \r\nOpera \r\nБраузер Opera — ветеран браузерных войн с Netscape и Microsoft. Его популярность взлетела вверх после \r\nтого как этот норвежский браузер стал совершенно бесплатным (до этого он поддерживался за счет рекламных \r\nвставок или продажи лицензии). Наряду с Mozilla, Opera находится в стадии активной разработки и \r\nпроектирования новой спецификации HTML 5, и реализации составляющих этой спецификации в своих браузерах.  \r\nВерсия 8.5 \r\nВерсия 8.5 стала первой, полностью свободной версией браузера Opera, поэтому она используется более \r\nшироко, чем другие версии. Она надежно поддерживает все современные свойства, хотя разработчики время от \r\nвремени сталкиваются с тем, что ее реализация CSS отличается от реализации в других браузерах; а вот \r\nреализация JavaScript более чем достаточна.  \r\nВерсия 9.0 \r\nВ самом последнем обновлении браузера Opera устранен ряд ошибок в движке JavaScript, а также \r\nдобавлена поддержка нового элемента <canvas>.  \r\n \r\n \r\n","\r\n"]